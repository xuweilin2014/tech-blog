# å®šæ—¶å™¨

## 1.åŸºäºå‡åºé“¾è¡¨çš„å®šæ—¶å™¨

å®šæ—¶å™¨é€šå¸¸è‡³å°‘è¦åŒ…å«ä¸¤ä¸ªæˆå‘˜ï¼š**ä¸€ä¸ªè¶…æ—¶æ—¶é—´ï¼ˆç›¸å¯¹æ—¶é—´æˆ–è€…ç»å¯¹æ—¶é—´ï¼‰å’Œä¸€ä¸ªä»»åŠ¡å›è°ƒå‡½æ•°**ã€‚æœ‰çš„æ—¶å€™è¿˜å¯èƒ½åŒ…å«å›è°ƒå‡½æ•°è¢«æ‰§è¡Œæ—¶éœ€è¦ä¼ å…¥çš„å‚æ•°ï¼Œä»¥åŠæ˜¯å¦é‡å¯å®šæ—¶å™¨ç­‰ä¿¡æ¯ã€‚è¿™é‡Œä½¿ç”¨åŒå‘é“¾è¡¨æ¥å°†å®šæ—¶å™¨è¿›è¡Œä¸²è”ï¼Œå¹¶ä¸”å°†å®šæ—¶å™¨æŒ‰åˆ°æœŸæ—¶é—´å¤§å°è¿›è¡Œå‡åºæ’åˆ—ã€‚å…·ä½“çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```cpp{.line-numbers}
#ifndef LST_TIMER
#define LST_TIMER

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include "time.h"

#define BUFFER_SIZE 64
/* å‰å‘å£°æ˜ */
class util_timer;

/* ç”¨æˆ·æ•°æ®ç»“æ„ï¼šå®¢æˆ·ç«¯ socket åœ°å€ã€socket æ–‡ä»¶æè¿°ç¬¦ã€è¯»ç¼“å­˜å’Œå®šæ—¶å™¨ */
struct client_data {
    sockaddr_in address;
    int sockfd;
    char buf[BUFFER_SIZE];
    util_timer* timer;
};

/* å®šæ—¶å™¨ç±» */
class util_timer {
public:
    /* ä»»åŠ¡è¶…æ—¶æ—¶é—´ï¼Œè¿™é‡Œä½¿ç”¨ç»å¯¹æ—¶é—´ */
    time_t expire;
    /* å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¡¨ç¤ºä»»åŠ¡å›è°ƒå‡½æ•° */
    void (*cb_func)(client_data* );
    /* å›è°ƒå‡½æ•°å¤„ç†çš„å®¢æˆ·æ•°æ®ï¼Œç”±å®šæ—¶å™¨çš„æ‰§è¡Œè€…ä¼ é€’ç»™å›è°ƒå‡½æ•° */
    client_data* user_data;
    /* æŒ‡å‘å‰ä¸€ä¸ªå®šæ—¶å™¨ */
    util_timer* prev;
    /* æŒ‡å‘åä¸€ä¸ªå®šæ—¶å™¨ */
    util_timer* next;

public:
    util_timer(): prev(NULL), next(NULL) {}
};

/* å®šæ—¶å™¨é“¾è¡¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡åºã€åŒå‘é“¾è¡¨ï¼Œä¸”å¸¦æœ‰å¤´ç»“ç‚¹å’Œå°¾èŠ‚ç‚¹ */
class sort_timer_list {

private:
    util_timer* head;
    util_timer* tail;

public:
    sort_timer_list(): head(NULL), tail(NULL) {}

    /* é“¾è¡¨è¢«é”€æ¯æ—¶ï¼Œåˆ é™¤å…¶ä¸­æ‰€æœ‰çš„å®šæ—¶å™¨ */
    ~sort_timer_list() {
        util_timer* tmp = head;
        while (tmp) {
            head = tmp->next;
            delete tmp;
            tmp = head;
        }
    }

    /* å°†ç›®æ ‡å®šæ—¶å™¨ timer æ·»åŠ åˆ°é“¾è¡¨ä¸­ */
    void add_timer(util_timer* timer) {
        if (!timer) {
            return;
        }
        // å¦‚æœå½“å‰é“¾è¡¨ä¸ºç©º
        if (!head) {
            head = tail = timer;
            return;
        }

        /* å¦‚æœç›®æ ‡å®šæ—¶å™¨çš„è¶…æ—¶æ—¶é—´å°äºå½“å‰é“¾è¡¨ä¸­æ‰€æœ‰çš„å®šæ—¶å™¨è¶…æ—¶æ—¶é—´ï¼Œåˆ™æŠŠè¯¥å®šæ—¶å™¨æ’å…¥é“¾è¡¨å¤´éƒ¨ï¼Œä½œä¸ºé“¾è¡¨æ–°çš„å¤´èŠ‚ç‚¹,
         * å¦åˆ™å°±éœ€è¦è°ƒç”¨é‡è½½å‡½æ•°ï¼ŒæŠŠå®ƒæ’å…¥ğŸ—¼é“¾è¡¨ä¸­åˆé€‚çš„ä½ç½®ï¼Œä»¥ä¿è¯é“¾è¡¨çš„å‡åºç‰¹æ€§
         */
        if (timer->expire < head->expire) {
            timer->next = head;
            head->prev = timer;
            head = timer;
            return;
        }

        add_timer(timer, head);
    }

    /* å½“æŸä¸ªå®šæ—¶ä»»åŠ¡å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè°ƒæ•´å¯¹åº”çš„å®šæ—¶å™¨åœ¨é“¾è¡¨ä¸­çš„ä½ç½®ï¼Œè¿™ä¸ªå‡½æ•°åªè€ƒè™‘è¢«è°ƒæ•´çš„å®šæ—¶å™¨çš„è¶…æ—¶æ—¶é—´å»¶é•¿çš„æƒ…å†µï¼Œ
     * å³è¯¥å®šæ—¶å™¨éœ€è¦åœ¨é“¾è¡¨çš„å°¾éƒ¨ç§»åŠ¨
     */
    void adjust_timer(util_timer* timer) {
        if (!timer) {
            return;
        }
        util_timer* tmp = timer->next;
        /* å¦‚æœè¢«è°ƒæ•´çš„ç›®æ ‡å®šæ—¶å™¨å¤„åœ¨é“¾è¡¨å°¾éƒ¨ï¼Œæˆ–è€…è¯¥å®šæ—¶å™¨æ–°çš„è¶…æ—¶å€¼ä»ç„¶å°äºå…¶ä¸‹ä¸€ä¸ªå®šæ—¶å™¨çš„è¶…æ—¶å€¼ï¼Œåˆ™ä¸ç”¨è°ƒæ•´ */
        if (!tmp || (timer->expire < tmp->expire)) {
            return;
        }

        /* å¦‚æœç›®æ ‡å®šæ—¶å™¨æ˜¯é“¾è¡¨çš„å¤´ç»“ç‚¹ï¼Œåˆ™å°†è¯¥å®šæ—¶å™¨ä»é“¾è¡¨ä¸­å–å‡ºå¹¶é‡æ–°æ’å…¥é“¾è¡¨ */
        if (timer == head) {
            head = head->next;
            head->prev = NULL;
            timer->next = NULL;
            add_timer(timer, head);
        } else {
            /* å¦‚æœç›®æ ‡å®šæ—¶å™¨ä¸æ˜¯é“¾è¡¨çš„å¤´ç»“ç‚¹ï¼Œåˆ™å°†è¯¥å®šæ—¶å™¨ä»é“¾è¡¨ä¸­å–å‡ºï¼Œç„¶åæ’å…¥å…¶åŸæ¥æ‰€åœ¨ä½ç½®ä¹‹åçš„éƒ¨åˆ†é“¾è¡¨ */
            timer->prev->next = timer->next;
            timer->next->prev = timer->prev;
            add_timer(timer, timer->next);
        }
    }

    /* å°†ç›®æ ‡å®šæ—¶å™¨ timer ä»é“¾è¡¨ä¸­åˆ é™¤ */
    void del_timer(util_timer* timer) {
        if (!timer) {
            return;
        }

        /* ä¸‹é¢è¿™ä¸ªæ¡ä»¶æˆç«‹è¡¨ç¤ºé“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªå®šæ—¶å™¨ */
        if ((timer == head) && (timer == tail)) {
            delete timer;
            head = NULL;
            tail = NULL;
            return;
        }

        /* å¦‚æœé“¾è¡¨ä¸­è‡³å°‘æœ‰ä¸¤ä¸ªå®šæ—¶å™¨ï¼Œä¸”ç›®æ ‡å®šæ—¶å™¨æ˜¯é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œ
         * åˆ™å°†é“¾è¡¨çš„å¤´èŠ‚ç‚¹é‡ç½®ä¸ºåŸå¤´ç»“ç‚¹çš„ä¸‹ä¸€ç»“ç‚¹ï¼Œç„¶ååˆ é™¤ç›®æ ‡å®šæ—¶å™¨
         */
        if (timer == head) {
            head = head->next;
            head->prev = NULL;
            delete timer;
            return;
        }

        /* å¦‚æœé“¾è¡¨ä¸­è‡³å°‘æœ‰ä¸¤ä¸ªå®šæ—¶å™¨ï¼Œä¸”ç›®æ ‡å®šæ—¶å™¨æ˜¯é“¾è¡¨çš„å°¾ç»“ç‚¹ï¼Œ
         * åˆ™å°†é“¾è¡¨çš„å°¾ç»“ç‚¹é‡ç½®ä¸ºåŸå°¾ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œç„¶ååˆ é™¤ç›®æ ‡å®šæ—¶å™¨
         */
        if (timer == tail) {
            tail = tail->prev;
            tail->next = NULL;
            delete timer;
            return;
        }

        /* å¦‚æœç›®æ ‡å®šæ—¶å™¨ä½äºé“¾è¡¨çš„ä¸­é—´ï¼Œåˆ™æŠŠå®ƒå‰åçš„å®šæ—¶å™¨ä¸²è”èµ·æ¥ï¼Œç„¶ååˆ é™¤ç›®æ ‡å®šæ—¶å™¨ */
        timer->prev->next = timer->next;
        timer->next->prev = timer->prev;
        delete timer;
    }

    /* SIGALRM ä¿¡å·æ¯æ¬¡è¢«è§¦å‘å°±åœ¨å…¶ä¿¡å·å¤„ç†å‡½æ•°ï¼ˆå¦‚æœä½¿ç”¨ç»Ÿä¸€äº‹ä»¶æºï¼Œåˆ™æ˜¯ä¸»å‡½æ•°ï¼‰ä¸­æ‰§è¡Œä¸€æ¬¡ tick å‡½æ•°ï¼Œä»¥å¤„ç†é“¾è¡¨ä¸Šåˆ°æœŸçš„ä»»åŠ¡ */
    void tick() {
        if (!head) {
            return;
        }

        printf("timer tick\n");
        /* è·å¾—ç³»ç»Ÿå½“å‰çš„æ—¶é—´ */
        time_t cur = time(NULL);
        util_timer* tmp = head;
        /* ä»å¤´ç»“ç‚¹å¼€å§‹ä¾æ¬¡å¤„ç†æ¯ä¸ªå®šæ—¶å™¨ï¼Œç›´åˆ°é‡åˆ°ä¸€ä¸ªå°šæœªåˆ°æœŸçš„å®šæ—¶å™¨ï¼Œè¿™å°±æ˜¯å®šæ—¶å™¨çš„æ ¸å¿ƒé€»è¾‘ */
        while (tmp) {
            /* å› ä¸ºæ¯ä¸ªå®šæ—¶å™¨éƒ½ä½¿ç”¨ç»å¯¹æ—¶é—´ä½œä¸ºè¶…æ—¶å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠå®šæ—¶å™¨çš„è¶…æ—¶å€¼å’Œç³»ç»Ÿå½“å‰æ—¶é—´ï¼Œæ¯”è¾ƒä»¥åˆ¤æ–­å®šæ—¶å™¨æ˜¯å¦åˆ°æœŸ */
            if (cur < tmp->expire) {
                break;
            }

            /* è°ƒç”¨å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°ï¼Œä»¥æ‰§è¡Œå®šæ—¶ä»»åŠ¡ */
            tmp->cb_func(tmp->user_data);
            /* æ‰§è¡Œå®Œå®šæ—¶å™¨ä¸­çš„å®šæ—¶ä»»åŠ¡ä¹‹åï¼Œå°±å°†å®ƒä»é“¾è¡¨ä¸­åˆ é™¤ï¼Œå¹¶é‡ç½®é“¾è¡¨å¤´ç»“ç‚¹ */
            head = tmp->next;
            if (head) {
                head->prev = NULL;
            }
            delete tmp;
            tmp = head;
        }
    }

private:

    /* ä¸€ä¸ªé‡è¦çš„è¾…åŠ©å‡½æ•°ï¼Œè¯¥å‡½æ•°è¡¨ç¤ºå°†ç›®æ ‡å®šæ—¶å™¨ timer æ·»åŠ åˆ°èŠ‚ç‚¹ lst_head ä¹‹åçš„éƒ¨åˆ†é“¾è¡¨ä¸­ */
    void add_timer(util_timer* timer, util_timer* lst_head) {
        util_timer* prev = lst_head;
        util_timer* tmp = prev->next;

        /* éå† lst_head èŠ‚ç‚¹ä¹‹åçš„éƒ¨åˆ†é“¾è¡¨ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªè¶…æ—¶æ—¶é—´å¤§äºç›®æ ‡å®šæ—¶å™¨çš„è¶…æ—¶æ—¶é—´çš„èŠ‚ç‚¹ï¼Œ
         * å¹¶å°†ç›®æ ‡å®šæ—¶å™¨æ’å…¥è¯¥èŠ‚ç‚¹ä¹‹å‰
         */
        while (tmp) {
            if (timer->expire < tmp->expire) {
                prev->next = timer;
                timer->next = tmp;
                tmp->prev = timer;
                timer->prev = prev;
                break;
            }

            prev = tmp;
            tmp = tmp->next;
        }

        /* å¦‚æœéå†å®Œ lst_head èŠ‚ç‚¹ä¹‹åçš„éƒ¨åˆ†é“¾è¡¨ï¼Œä»ç„¶æœªæ‰¾åˆ°è¶…æ—¶æ—¶é—´å¤§äºç›®æ ‡å®š
         * æ—¶å™¨çš„è¶…æ—¶æ—¶é—´çš„èŠ‚ç‚¹ï¼Œåˆ™å°†ç›®æ ‡å®šæ—¶å™¨æ’å…¥é“¾è¡¨å°¾éƒ¨ï¼Œå¹¶æŠŠå®ƒè®¾ç½®ä¸ºé“¾è¡¨æ–°çš„å°¾èŠ‚ç‚¹
         */
        if (!tmp) {
            prev->next = timer;
            timer->prev = prev;
            timer->next = NULL;
            tail = timer;
        }
    }

};

#endif
```

**`sort_timer_lst`** æ˜¯ä¸€ä¸ªå‡åºé“¾è¡¨ã€‚å…¶æ ¸å¿ƒå‡½æ•° **`tick`** ç›¸å½“äºä¸€ä¸ªå¿ƒæå‡½æ•°ï¼Œå®ƒæ¯éš”ä¸€æ®µå›ºå®šçš„æ—¶é—´å°±æ‰§è¡Œä¸€æ¬¡ï¼Œä»¥æ£€æµ‹åˆ°æœŸçš„ä»»åŠ¡ï¼Œå¦‚æœä¸€ä¸ªå®šæ—¶å™¨åˆ°æœŸï¼Œé‚£ä¹ˆå°±ä¼šè°ƒç”¨æ­¤å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°ï¼Œä»¥æ‰§è¡Œå®šæ—¶ä»»åŠ¡ã€‚å¹¶ä¸”å°†æ­¤å®šæ—¶å™¨ä»åŒå‘é“¾è¡¨ä¸­ç§»é™¤ã€‚åˆ¤æ–­å®šæ—¶ä»»åŠ¡åˆ°æœŸçš„ä¾æ®æ˜¯å®šæ—¶å™¨çš„ **`expire`** å€¼å°äºå½“å‰çš„ç³»ç»Ÿæ—¶é—´ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‡åºé“¾è¡¨çš„å®šæ—¶å™¨æ¥å¤„ç†éæ´»åŠ¨è¿æ¥ï¼ŒæœåŠ¡å™¨ç¨‹åºé€šå¸¸è¦å®šæœŸå¤„ç†éæ´»åŠ¨è¿æ¥ï¼šç»™å®¢æˆ·ç«¯å‘ä¸€ä¸ªé‡è¿è¯·æ±‚ï¼Œæˆ–è€…å…³é—­è¯¥è¿æ¥ï¼Œæˆ–è€…å…¶ä»–ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘åœ¨åº”ç”¨å±‚å®ç°ç±»ä¼¼äº **`KEEPALIVE`** çš„æœºåˆ¶ï¼Œä»¥ç®¡ç†æ‰€æœ‰é•¿æ—¶é—´å¤„äºéæ´»åŠ¨çŠ¶æ€çš„è¿æ¥ã€‚

åœ¨ä¸‹é¢çš„ä»£ç ä¸­åˆ©ç”¨ **`alarm`** å‡½æ•°å‘¨æœŸæ€§åœ°è§¦å‘ **`SIGALRM`** ä¿¡å·ï¼Œè¯¥ä¿¡å·çš„ä¿¡å·å¤„ç†å‡½æ•°åˆ©ç”¨ç®¡é“é€šçŸ¥ä¸»å¾ªç¯æ‰§è¡Œ **`tick`** å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¸…ç†é“¾è¡¨ä¸­åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œå¹¶ä¸”æ‰§è¡Œæ¯ä¸ªå®šæ—¶å™¨çš„å›è°ƒå‡½æ•°ï¼Œå³å…³é—­ä¸æ­¤å®šæ—¶å™¨æœ‰å…³çš„å¥—æ¥å­—æè¿°ç¬¦ sockfdï¼Œå¹¶ä¸”ä» epoll ç›‘å¬äº‹ä»¶ä¸­ç§»é™¤ã€‚è¿™äº›è¢«æ¸…ç†çš„å®šæ—¶å™¨è¯´æ˜ï¼Œåœ¨å¿ƒè·³æ—¶é—´å†…ï¼ŒæœåŠ¡å™¨æ²¡æœ‰ä»å…¶å¯¹åº”çš„å¥—æ¥å­— sockfd ä¸Šæ”¶åˆ°ä»»ä½•æ•°æ®ï¼Œè¿™äº› sockfd è¢«åˆ¤å®šä¸ºéæ´»åŠ¨è¿æ¥ï¼Œè¿›è€Œè¢«æ¸…é™¤ã€‚ä½†æ˜¯å¦‚æœ **`sockfd`** ä¸Šæ”¶åˆ°äº†å®¢æˆ·ç«¯å‘è¿‡æ¥çš„æ•°æ®ï¼Œé‚£ä¹ˆå°±è¦å°†å®šæ—¶å™¨çš„ expireï¼ˆè¶…æ—¶æ—¶é—´ï¼‰å»¶å **`TIMESLOT`** æ—¶é—´ï¼ˆæš‚æ—¶ä¸ä¼šè¢«æ¸…ç†ï¼‰ã€‚å…·ä½“ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```cpp{.line-numbers}
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include "signal.h"
#include "time.h"
#include "lst_timer.h"

#define FD_LIMIT 65535
#define MAX_EVENT_NUMBER 1024
#define TIMESLOT 5
#define SERV_PORT 9523

static int pipefd[2];
static sort_timer_list timer_lst;
static int epollfd = 0;

int set_nonblocking(int fd) {
    int old_option = fcntl(fd, F_GETFL);
    int new_option = old_option | O_NONBLOCK;
    fcntl(fd, F_SETFL, new_option);
    return old_option;
}

void addfd(int epfd, int fd) {
    struct epoll_event event;
    event.data.fd = fd;
    event.events = EPOLLIN | EPOLLET;
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
    set_nonblocking(fd);
}

/* å¦‚æœå½“æŸä¸€ä¸ªä¿¡å·äº§ç”Ÿæ—¶ï¼Œä¼šè°ƒç”¨è¿™ä¸ª sig_handler å‡½æ•°ï¼Œå°†äº§ç”Ÿçš„ä¿¡å·é€šè¿‡ç®¡é“å‘é€ç»™ä¸»ç¨‹åºå¾ªç¯ */
void sig_handler(int sig) {
    int save_errno = errno;
    int msg = sig;
    send(pipefd[1], (char*)&msg, 1, 0);
    errno = save_errno;
}

void add_sig(int sig) {
    struct sigaction sa;
    memset(&sa, '\0', sizeof(sa));
    sa.sa_handler = sig_handler;
    /* å½“è°ƒç”¨ä¿¡å·å¤„ç†å™¨æ—¶ï¼Œå¦‚æœé˜»å¡åœ¨æŸä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ä¸Šï¼Œé‚£ä¹ˆå½“ä¿¡å·å¤„ç†å™¨æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œä¼šé‡æ–°æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ */
    sa.sa_flags |= SA_RESTART;
    /* ä¿¡å·å¤„ç†å™¨æ‰§è¡ŒæœŸé—´é˜»å¡æ‰æ‰€æœ‰çš„ä¿¡å·ä¼ é€’ */
    sigfillset(&sa.sa_mask);
    sigaction(sig, &sa, nullptr);
}

void timer_handler() {
    /* å®šæ—¶å¤„ç†ä»»åŠ¡ï¼Œå®é™…ä¸Šå°±æ˜¯è°ƒç”¨ tick å‡½æ•° */
    /* tick å‡½æ•°å¤„ç†å®šæ—¶å™¨åˆ—è¡¨ä¸Šåˆ°æœŸçš„å®šæ—¶å™¨ï¼Œå¹¶æ‰§è¡Œå›è°ƒå‡½æ•° */
    timer_lst.tick();
    /* å› ä¸ºä¸€æ¬¡ alarm è°ƒç”¨åªä¼šå¼•èµ·ä¸€æ¬¡ SIGALRM ä¿¡å·ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦é‡æ–°å®šæ—¶ï¼Œä»¥ä¸æ–­è§¦å‘ SIGALRM ä¿¡å· */
    alarm(TIMESLOT);
}

/* å®šæ—¶å™¨å›è°ƒå‡½æ•°ï¼Œå®ƒåˆ é™¤éæ´»åŠ¨è¿æ¥ socket ä¸Šçš„æ³¨å†Œäº‹ä»¶ï¼Œå¹¶ä¸”å…³é—­ä¹‹ */
void cb_func(client_data* user_data) {
    epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data->sockfd, 0);
    close(user_data->sockfd);
    printf("close fd %d\n", user_data->sockfd);
}

int main() {

    const char* ip = "127.0.0.1";
    int port = SERV_PORT;

    int ret = 0;
    struct sockaddr_in address;
    bzero(&address, sizeof(address));
    address.sin_family = AF_INET;
    inet_pton(AF_INET, ip, &address.sin_addr);
    address.sin_port = htons(port);

    int listenfd = socket(PF_INET, SOCK_STREAM, 0);
    bind(listenfd, (struct sockaddr*)&address, sizeof(address));
    listen(listenfd, 5);

    struct epoll_event events[MAX_EVENT_NUMBER];
    epollfd = epoll_create(5);
    addfd(epollfd, listenfd);

    socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);
    set_nonblocking(pipefd[1]);
    /* å¯¹ç®¡é“è¯»ç«¯è¿›è¡Œç›‘å¬ï¼Œå¦‚æœæœ‰ä¿¡å·äº§ç”Ÿå°±ä¼šè¢«ä¼ é€’ç»™ä¸»ç¨‹åºå¾ªç¯ */
    addfd(epollfd, pipefd[0]);

    /* è®¾ç½®ä¿¡å·å¤„ç†å‡½æ•° */
    add_sig(SIGALRM);
    add_sig(SIGTERM);
    bool stop_server = false;

    client_data* users = new client_data[FD_LIMIT];
    bool timeout = false;
    alarm(TIMESLOT);

    while (!stop_server) {
        int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);
        if ((number < 0) && (errno != EINTR)) {
            printf("epoll failure\n");
            break;
        }

        for (int i = 0; i < number; i++) {
            int sockfd = events[i].data.fd;

            /* å¤„ç†æ–°åˆ°çš„å®¢æˆ·è¿æ¥ */
            if (sockfd == listenfd) {

                struct sockaddr_in client_address;
                socklen_t client_addr_length = sizeof(client_address);
                int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addr_length);

                addfd(epollfd, connfd);
                users[connfd].address = client_address;
                users[connfd].sockfd = connfd;

                /* åˆ›å»ºå®šæ—¶å™¨ï¼Œè®¾ç½®å…¶å›è°ƒå‡½æ•°ä¸è¶…æ—¶æ—¶é—´ï¼Œç„¶åç»‘å®šå®šæ—¶å™¨ä¸ç”¨æˆ·æ•°æ®ï¼Œæœ€åå°†å®šæ—¶å™¨æ·»åŠ åˆ°é“¾è¡¨ timer_lst ä¸­ */
                util_timer* timer = new util_timer();
                timer->user_data = &users[connfd];
                timer->cb_func = cb_func;
                time_t cur = time(nullptr);
                timer->expire = cur + 3 * TIMESLOT;
                timer_lst.add_timer(timer);
                users[connfd].timer = timer;

            /* æœ‰ä¿¡å·äº§ç”Ÿå¹¶ä¸”è¢«ä¼ é€’ç»™è¿›ç¨‹ */
            } else if ((sockfd == pipefd[0]) && (events[i].events & EPOLLIN)) {

                /* å¤„ç†ä¿¡å· */
                int sig;
                char signals[1024];
                ret = recv(pipefd[0], signals, sizeof(signals), 0);

                if (ret == -1) {
                    // handle the error
                    continue;
                } else if (ret == 0) {
                    continue;
                } else {

                    for (int i = 0; i < ret; i++) {
                        switch (signals[i]) {
                            case SIGALRM: {
                                /* ç”¨ timeout å˜é‡æ ‡è®°æœ‰å®šæ—¶ä»»åŠ¡éœ€è¦å¤„ç†ï¼Œä½†ä¸ç«‹å³å¤„ç†å®šæ—¶ä»»åŠ¡ã€‚
                                 * è¿™æ˜¯å› ä¸ºå®šæ—¶ä»»åŠ¡çš„ä¼˜å…ˆçº§ä¸æ˜¯å¾ˆé«˜ï¼Œæˆ‘ä»¬ä¼˜å…ˆå¤„ç†å…¶ä»–æ›´é‡è¦çš„ä»»åŠ¡
                                 */
                                timeout = true;
                                break;
                            }
                            case SIGTERM: {
                                stop_server = true;
                            }
                        }
                    }
                }

            } else if (events[i].events & EPOLLIN) {

                /* å¤„ç†å®¢æˆ·è¿æ¥ä¸Šæ¥æ”¶åˆ°çš„æ•°æ® */
                memset(users[sockfd].buf, '\0', BUFFER_SIZE);
                ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - 1, 0);
                printf("get %d bytes of client data %s from %d\n", ret, users[sockfd].buf, sockfd);
                util_timer* timer = users[sockfd].timer;

                if (ret < 0) {
                    /* å¦‚æœå‘ç”Ÿè¯»é”™è¯¯ï¼Œåˆ™å…³é—­è¿æ¥ï¼Œå¹¶ä¸”ç§»é™¤å…¶å¯¹åº”çš„å®šæ—¶å™¨ */
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        cb_func(&users[sockfd]);
                        if (timer) {
                            timer_lst.del_timer(timer);
                        }
                    }
                } else if (ret == 0) {
                    /* å¦‚æœå¯¹æ–¹å·²ç»å…³é—­è¿æ¥ï¼Œåˆ™æˆ‘ä»¬ä¹Ÿå…³é—­è¿æ¥ï¼Œå¹¶ä¸”ç§»é™¤å¯¹åº”çš„å®šæ—¶å™¨ */
                    cb_func(&users[sockfd]);
                    if (timer) {
                        timer_lst.del_timer(timer);
                    }
                } else {
                    /* å¦‚æœæŸä¸ªå®¢æˆ·è¿æ¥ä¸Šæœ‰æ•°æ®å¯è¯»ï¼Œåˆ™æˆ‘ä»¬è¦è°ƒæ•´è¯¥è¿æ¥å¯¹åº”çš„å®šæ—¶å™¨ï¼Œä»¥å»¶è¿Ÿè¯¥è¿æ¥è¢«å…³é—­çš„æ—¶é—´ */
                    if (timer) {
                        time_t cur = time(nullptr);
                        timer->expire = cur + 3 * TIMESLOT;
                        printf("adjust timer once\n");
                        timer_lst.adjust_timer(timer);
                    }
                }
            } else {
                // others
            }
        }

        /* æœ€åå¤„ç†å®šæ—¶äº‹ä»¶ï¼Œå› ä¸º I/O äº‹ä»¶æœ‰æ›´é«˜æ•ˆçš„ä¼˜å…ˆçº§ã€‚å½“ç„¶ï¼Œè¿™æ ·åšå°†å¯¼è‡´å®šæ—¶ä»»åŠ¡ä¸èƒ½ç²¾ç¡®åœ°æŒ‰ç…§é¢„æœŸçš„æ—¶é—´æ‰§è¡Œ */
        if (timeout) {
            /* è°ƒç”¨å®šæ—¶å™¨åˆ—è¡¨çš„ tick å‡½æ•°ï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œå³ä¸€æ®µæ—¶é—´æ²¡æœ‰æ•°æ®ä¼ è¾“çš„è¿æ¥ï¼Œå¹¶ä¸”å°†è¿æ¥å…³é—­ */
            timer_handler();
            timeout = false;
        }
    }

    close(listenfd);
    close(pipefd[1]);
    close(pipefd[0]);
    delete [] users;
    return 0;
}
```

## 2.æ—¶é—´è½®å®šæ—¶å™¨

å‰é¢æ‰€è¿°åŸºäºæ’åºé“¾è¡¨çš„å®šæ—¶å™¨å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼šæ‰€æœ‰çš„å®šæ—¶å™¨éƒ½ä¿å­˜åœ¨ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œæ‰€ä»¥æ·»åŠ å’Œåˆ é™¤å®šæ—¶å™¨çš„æ•ˆç‡åä½ï¼Œä¸‹é¢æˆ‘ä»¬é€šè¿‡ä½¿ç”¨æ—¶é—´è½®æŠ€æœ¯æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œ**æ—¶é—´è½®çš„åŸºæœ¬æ€æƒ³å°±æ˜¯å°†å®šæ—¶å™¨æ•£åˆ—ï¼ˆå“ˆå¸Œ hashï¼‰åˆ°ä¸åŒçš„ entry ä¸­ï¼Œè¿›è€Œå‡å°‘æ·»åŠ å®šæ—¶å™¨çš„æ—¶é—´ï¼Œæé«˜æ•ˆç‡**ã€‚ä¸€ä¸ªç®€å•çš„å®šæ—¶å™¨å¦‚ä¸‹æ‰€ç¤ºï¼š

<div align="center">
    <img src="å®šæ—¶å™¨_static/1.png" width="600"/>
</div>

ä¸Šå›¾æ‰€ç¤ºçš„æ—¶é—´è½®å†…ï¼Œ(å®çº¿ï¼‰æŒ‡é’ˆæŒ‡å‘è½®å­ä¸Šçš„ä¸€ä¸ªæ§½ï¼ˆslot)ã€‚å®ƒä»¥æ’å®šçš„é€Ÿåº¦é¡ºæ—¶é’ˆè½¬åŠ¨ï¼Œæ¯è½¬åŠ¨ä¸€æ­¥å°±æŒ‡å‘ä¸‹ä¸€ä¸ªæ§½ï¼ˆè™šçº¿æŒ‡é’ˆæŒ‡å‘çš„æ§½ï¼‰ï¼Œæ¯æ¬¡è½¬åŠ¨ç§°ä¸ºä¸€ä¸ªæ»´ç­”ï¼ˆtickï¼‰ã€‚ä¸€ä¸ªæ»´ç­”çš„æ—¶é—´ç§°ä¸ºæ—¶é—´è½®çš„æ§½é—´éš” siï¼ˆslot intervalï¼‰ï¼Œå®ƒå®é™…ä¸Šå°±æ˜¯å¿ƒææ—¶é—´ã€‚è¯¥æ—¶é—´è½®å…±æœ‰ N ä¸ªæ§½ï¼Œå› æ­¤å®ƒè¿è½¬ä¸€å‘¨çš„æ—¶é—´æ˜¯ N * siã€‚

æ¯ä¸ªæ§½æŒ‡å‘ä¸€æ¡å®šæ—¶å™¨é“¾è¡¨ï¼Œæ¯æ¡é“¾è¡¨ä¸Šçš„å®šæ—¶å™¨å…·æœ‰ç›¸åŒçš„ç‰¹å¾ï¼š**å®ƒä»¬çš„å®šæ—¶æ—¶é—´ç›¸å·® N * si çš„æ•´æ•°å€**ã€‚æ—¶é—´è½®æ­£æ˜¯åˆ©ç”¨è¿™ä¸ªå…³ç³»å°†å®šæ—¶å™¨æ•£åˆ—åˆ°ä¸åŒçš„é“¾è¡¨ä¸­ã€‚å‡å¦‚ç°åœ¨æŒ‡é’ˆæŒ‡å‘æ§½ $cs$ï¼Œæˆ‘ä»¬è¦æ·»åŠ ä¸€ä¸ªå®šæ—¶æ—¶é—´ä¸º $ti$ çš„å®šæ—¶å™¨ï¼ˆ$ti$ æ˜¯ç›¸å¯¹äºå½“å‰æ—¶é—´çš„ï¼‰ï¼Œåˆ™è¯¥å®šæ—¶å™¨å°†è¢«æ’å…¥æ§½ $ts$ (timer slot) å¯¹åº”çš„é“¾è¡¨ä¸­ï¼š

$$ts = (cs + ti \% N) \% N $$

åŸºäºæ’åºé“¾è¡¨çš„å®šæ—¶å™¨ä½¿ç”¨å”¯ä¸€çš„ä¸€æ¡é“¾è¡¨æ¥ç®¡ç†æ‰€æœ‰å®šæ—¶å™¨ï¼Œæ‰€ä»¥æ’å…¥æ“ä½œçš„æ•ˆç‡éšç€å®šæ—¶å™¨æ•°ç›®çš„å¢å¤šè€Œé™ä½ã€‚**è€Œæ—¶é—´è½®ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ€æƒ³ï¼Œå°†å®šæ—¶å™¨æ•£åˆ—åˆ°ä¸åŒçš„é“¾è¡¨ä¸Šã€‚è¿™æ ·æ¯æ¡é“¾è¡¨ä¸Šçš„å®šæ—¶å™¨æ•°ç›®éƒ½å°†æ˜æ˜¾å°‘äºåŸæ¥çš„æ’åºé“¾è¡¨ä¸Šçš„å®šæ—¶å™¨æ•°ç›®**ï¼Œæ’äººæ“ä½œçš„æ•ˆç‡åŸºæœ¬ä¸å—å®šæ—¶å™¨æ•°ç›®çš„å½±å“ã€‚

å¾ˆæ˜¾ç„¶ï¼Œå¯¹æ—¶é—´è½®è€Œè¨€ï¼Œè¦æé«˜å®šæ—¶ç²¾åº¦ï¼Œå°±è¦ä½¿ $si$ å€¼è¶³å¤Ÿå°ï¼›è¦æé«˜æ‰§è¡Œæ•ˆç‡ï¼Œåˆ™è¦æ±‚ $N$ å€¼è¶³å¤Ÿå¤§ï¼ˆN è¶Šå¤§ï¼Œæ•£åˆ—åˆ°æ¯ä¸€ä¸ªé“¾è¡¨çš„å®šæ—¶å™¨æ€»æ•°ç›®å°±è¶Šå°ï¼Œæ‰§è¡Œæ•ˆç‡ä¹Ÿå°±è¶Šé«˜ï¼‰ã€‚æ—¶é—´è½®çš„ç®€å•å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š

```cpp{.line-numbers}
#ifndef HTTP_PARSER_TIME_WHEEL_H
#define HTTP_PARSER_TIME_WHEEL_H

#include "time.h"
#include "netinet/in.h"
#include "stdio.h"

#define BUFFER_SIZE 64
class tw_timer;

/* ç»‘å®š socket å’Œå®šæ—¶å™¨ */
struct client_data {
    sockaddr_in address;
    int sockfd;
    char buf[BUFFER_SIZE];
    tw_timer* timer;
};

/* å®šæ—¶å™¨ç±» */
class tw_timer {
public:
    /* è®°å½•å®šæ—¶å™¨åœ¨æ—¶é—´è½®è½¬å¤šå°‘åœˆä¹‹åç”Ÿæ•ˆ */
    int rotation;
    /* è®°å½•å®šæ—¶å™¨å±äºæ—¶é—´è½®ä¸Šå“ªä¸ªæ§½ï¼ˆå¯¹åº”çš„é“¾è¡¨ï¼‰ */
    int time_slot;
    void (*cb_func) (client_data*);
    client_data* user_data;

    tw_timer* next;
    tw_timer* prev;
public:
    tw_timer(int rot, int ts): next(nullptr), prev(nullptr), rotation(rot), time_slot(ts) {}
};

class time_wheel {
private:
    /* æ—¶é—´è½®ä¸Šæ§½çš„æ•°ç›® */ 
    static const int N = 60;
    /* æ—¶é—´è½®ä¸Šæ§½é—´éš”å¤§å°ï¼Œå³æ§½çš„é¢—ç²’åº¦ */
    static const int SI = 1;
    tw_timer* slots[N];
    int cur_slot;

public:
    time_wheel(): cur_slot(0) {
        for (int i = 0; i < N; ++i) {
            /* åˆå§‹åŒ–æ¯ä¸ªæ§½çš„å¤´ç»“ç‚¹ */
            slots[i] = nullptr;
        }
    }

    ~time_wheel() {
        /* éå†æ¯ä¸ªæ§½ï¼Œå¹¶ä¸”é”€æ¯å…¶ä¸­çš„å®šæ—¶å™¨ */
        for (int i = 0; i < N; ++i) {
            tw_timer* tmp = slots[i];
            while (tmp) {
                slots[i] = tmp->next;
                delete tmp;
                tmp = slots[i];
            }
        }
    }

    /* æ ¹æ®å®šæ—¶å€¼ timeout åˆ›å»ºä¸€ä¸ªå®šæ—¶å™¨ï¼Œå¹¶ä¸”æŠŠå®ƒæ’å…¥åˆé€‚çš„æ§½ä¸­ */
    tw_timer* add_timer(int timeout) {
        if (timeout < 0) {
            return nullptr;
        }

        int ticks = 0;
        /* 
         * ä¸‹é¢æ ¹æ®å¾…æ’å…¥å®šæ—¶å™¨çš„è¶…æ—¶å€¼è®¡ç®—å®ƒå°†åœ¨æ—¶é—´è½®è½¬åŠ¨å¤šå°‘ä¸ªæ»´ç­”åè¢«è§¦å‘ï¼Œå¹¶å°†è¯¥æ»´ç­”æ•°å­˜å‚¨äºå˜é‡ ticks ä¸­ã€‚
         * å¦‚æœå¾…æ’å…¥å®šæ—¶å™¨çš„è¶…æ—¶å€¼å°äºæ—¶é—´è½®çš„æ§½é—´éš” SIï¼Œåˆ™å°† ticks å‘ä¸ŠæŠ˜åˆä¸º 1ï¼Œå¦åˆ™å°±å°† ticks å‘ä¸‹æŠ˜åˆä¸º 
         * timeout / SIã€‚è¿™ä¸ªè¶…æ—¶å€¼æŒ‡çš„æ˜¯ç›¸å¯¹äºå½“å‰æ—¶é—´è€Œè¨€ï¼Œå³ä»å½“å‰æ—¶é—´å¼€å§‹ï¼Œç»è¿‡ timeout æ—¶é—´ä¼šè¶…æ—¶ã€‚
         */
        if (timeout < SI) {
            ticks = 1;
        } else {
            ticks = timeout / SI;
        }

        /* è®¡ç®—å¾…æ’å…¥çš„å®šæ—¶å™¨åœ¨æ—¶é—´è½®è½¬åŠ¨å¤šå°‘åœˆåè¢«è§¦å‘ */
        int rotation = ticks / N;
        /* è®¡ç®—å¾…æ’å…¥çš„å®šæ—¶å™¨åº”è¯¥è¢«æ’å…¥å“ªä¸ªæ§½ä¸­ï¼Œå®é™…ä¸Šæ˜¯è¿›è¡Œä¸€ä¸ª hash è¿‡ç¨‹ */
        int ts = (cur_slot + (ticks % N)) % N;
        /* åˆ›å»ºæ–°çš„å®šæ—¶å™¨ï¼Œå®ƒåœ¨æ—¶é—´è½®è½¬åŠ¨ rotation åœˆä¹‹åè¢«è§¦å‘ï¼Œä¸”ä½äºç¬¬ ts ä¸ªæ§½ä¸­ */
        tw_timer* timer = new tw_timer(rotation, ts);

        if (!slots[ts]) {
            printf("add timer, rotation is %d, ts is %d, cur_slot is %d\n",
                   rotation, ts, cur_slot);
            slots[ts] = timer;
        } else {
            timer->next = slots[ts];
            slots[ts]->prev = timer;
            slots[ts] = timer;
        }

        return timer;
    }

    void del_timer(tw_timer* timer) {
        if (!timer) {
            return;
        }

        int ts = timer->time_slot;
        if (timer == slots[ts]) {
            slots[ts] = slots[ts]->next;
            if (slots[ts]) {
                slots[ts]->prev = nullptr;
            }
            delete timer;
        } else {
            timer->prev->next = timer->next;
            if (timer->next) {
                timer->next->prev = timer->prev;
            }
            delete timer;
        }
    }

    /* SI æ—¶é—´åˆ°åï¼Œè°ƒç”¨è¯¥å‡½æ•°ï¼Œæ—¶é—´è½®å‘å‰æ»šåŠ¨ä¸€ä¸ªæ§½çš„é—´éš” */
    void tick() {

        tw_timer* tmp = slots[cur_slot];
        printf("current slot is %d\n", cur_slot);

        /* éå†å½“å‰æ§½ï¼ˆcur_slotï¼‰ä¸­æ‰€æœ‰çš„å®šæ—¶å™¨ï¼Œå½“å®šæ—¶å™¨åˆ°æœŸä¹‹åï¼ˆrotation å€¼ä¸º 0ï¼‰ï¼Œæ‰§è¡Œå®šæ—¶ä»»åŠ¡ */
        while (tmp) {
            printf("tick the timer once\n");
            /* å¦‚æœå®šæ—¶å™¨çš„ rotation å€¼å¤§äº 0ï¼Œåˆ™å®ƒåœ¨è¿™ä¸€è½®ä¸èµ·ä½œç”¨ */
            if (tmp->rotation) {
                tmp->rotation--;
                tmp = tmp->next;
            /* å¦åˆ™ï¼Œè¯´æ˜å®šæ—¶å™¨å·²ç»åˆ°æœŸï¼Œäºæ˜¯æ‰§è¡Œå®šæ—¶ä»»åŠ¡ï¼Œç„¶ååˆ é™¤è¯¥å®šæ—¶å™¨ */    
            } else {
                tmp->cb_func(tmp->user_data);

                if (tmp == slots[cur_slot]) {
                    printf("delete header in cur_slot\n");
                    slots[cur_slot] = tmp->next;
                    delete tmp;
                    if (slots[cur_slot]) {
                        slots[cur_slot]->prev = nullptr;
                    }
                    tmp = slots[cur_slot];
                } else {
                    tmp->prev->next = tmp->next;
                    if (tmp->next) {
                        tmp->next->prev = tmp->prev;
                    }
                    tw_timer* tmp2 = tmp->next;
                    delete tmp;
                    tmp = tmp2;
                }
            }
        }

        /* æ›´æ–°æ—¶é—´è½®çš„å½“å‰æ§½ï¼Œä»¥åæ˜ æ—¶é—´è½®çš„è½¬åŠ¨ */ 
        cur_slot = (++cur_slot) % N;
    }
};

#endif //HTTP_PARSER_TIME_WHEEL_H
```

åœ¨ä¸Šè¿°æ—¶é—´è½®çš„ä»£ç ä¸­ï¼Œå½“ä¸€ä¸ªå®šæ—¶å™¨ï¼ˆ**`timeout`** æ—¶é—´åè¶…æ—¶ï¼‰è¢«æ·»åŠ åˆ°æ—¶é—´è½®ä¸­æ—¶ï¼Œé¦–å…ˆä¼šåšçš„å°±æ˜¯ä¾æ® **`timeout`** å€¼å°†å…¶å“ˆå¸Œ/æ•£åˆ—åˆ°æ—¶é—´è½®æŸä¸€ä¸ªæ§½çš„é“¾è¡¨ä¸­ï¼Œå¹¶ä¸”è®¡ç®—å‡º **`rotation`** å€¼å’Œ **`ts`** å€¼ã€‚ç„¶åæ¯æ¬¡è°ƒç”¨æ—¶é—´è½®çš„ tick å‡½æ•°æ—¶ï¼Œéƒ½ä¼šå°† **`cur_slot`** è¡¨ç¤ºçš„å½“å‰æ—¶é—´æ§½é“¾è¡¨ä¸­åˆ°æœŸï¼ˆ**`rotation`** å€¼ä¸º 0ï¼‰çš„å®šæ—¶å™¨æ¸…é™¤æ‰ï¼Œå¹¶ä¸”æ‰§è¡Œè¯¥å®šæ—¶å™¨çš„ä»»åŠ¡ï¼Œæœ€åå°† **`cur_slot`** æŒ‡å‘æ—¶é—´è½®çš„ä¸‹ä¸€ä¸ªæ§½ã€‚æˆ‘ä»¬ä½¿ç”¨æ­¤æ—¶é—´è½®æ¥æ£€æµ‹éæ´»åŠ¨è¿æ¥ï¼Œä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```cpp{.line-numbers}
#define FD_LIMIT 65535
#define MAX_EVENT_NUMBER 1024
#define TIMESLOT 5
#define SERV_PORT 9523

static int pipefd[2];
static time_wheel wheel;
static int epollfd = 0;

int set_nonblocking(int fd) {
    int old_option = fcntl(fd, F_GETFL);
    int new_option = old_option | O_NONBLOCK;
    fcntl(fd, F_SETFL, new_option);
    return old_option;
}

void addfd(int epfd, int fd) {
    struct epoll_event event{};
    event.data.fd = fd;
    event.events = EPOLLIN | EPOLLET;
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
    set_nonblocking(fd);
}

/* å¦‚æœå½“æŸä¸€ä¸ªä¿¡å·äº§ç”Ÿæ—¶ï¼Œä¼šè°ƒç”¨è¿™ä¸ª sig_handler å‡½æ•°ï¼Œå°†äº§ç”Ÿçš„ä¿¡å·é€šè¿‡ç®¡é“å‘é€ç»™ä¸»ç¨‹åºå¾ªç¯ */
void sig_handler(int sig) {
    int save_errno = errno;
    int msg = sig;
    send(pipefd[1], (char*)&msg, 1, 0);
    errno = save_errno;
}

void add_sig(int sig) {
    struct sigaction sa{};
    memset(&sa, '\0', sizeof(sa));
    sa.sa_handler = sig_handler;
    /* å½“è°ƒç”¨ä¿¡å·å¤„ç†å™¨æ—¶ï¼Œå¦‚æœé˜»å¡åœ¨æŸä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ä¸Šï¼Œé‚£ä¹ˆå½“ä¿¡å·å¤„ç†å™¨æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œä¼šé‡æ–°æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ */
    sa.sa_flags |= SA_RESTART;
    /* ä¿¡å·å¤„ç†å™¨æ‰§è¡ŒæœŸé—´é˜»å¡æ‰æ‰€æœ‰çš„ä¿¡å·ä¼ é€’ */
    sigfillset(&sa.sa_mask);
    sigaction(sig, &sa, nullptr);
}

void timer_handler() {
    /* å®šæ—¶å¤„ç†ä»»åŠ¡ï¼Œå®é™…ä¸Šå°±æ˜¯è°ƒç”¨ tick å‡½æ•° */
    /* tick å‡½æ•°å¤„ç†å®šæ—¶å™¨åˆ—è¡¨ä¸Šåˆ°æœŸçš„å®šæ—¶å™¨ï¼Œå¹¶æ‰§è¡Œå›è°ƒå‡½æ•° */
    wheel.tick();
    /* å› ä¸ºä¸€æ¬¡ alarm è°ƒç”¨åªä¼šå¼•èµ·ä¸€æ¬¡ SIGALRM ä¿¡å·ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦é‡æ–°å®šæ—¶ï¼Œä»¥ä¸æ–­è§¦å‘ SIGALRM ä¿¡å· */
    alarm(TIMESLOT);
}

/* å®šæ—¶å™¨å›è°ƒå‡½æ•°ï¼Œå®ƒåˆ é™¤éæ´»åŠ¨è¿æ¥ socket ä¸Šçš„æ³¨å†Œäº‹ä»¶ï¼Œå¹¶ä¸”å…³é—­ä¹‹ */
void cb_func(client_data* user_data) {
    epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data->sockfd, 0);
    close(user_data->sockfd);
    printf("close fd %d\n", user_data->sockfd);
}

int main() {

    const char* ip = "127.0.0.1";
    int port = SERV_PORT;

    int ret = 0;
    struct sockaddr_in address{};
    bzero(&address, sizeof(address));
    address.sin_family = AF_INET;
    inet_pton(AF_INET, ip, &address.sin_addr);
    address.sin_port = htons(port);

    int listenfd = socket(PF_INET, SOCK_STREAM, 0);
    bind(listenfd, (struct sockaddr*)&address, sizeof(address));
    listen(listenfd, 5);

    struct epoll_event events[MAX_EVENT_NUMBER];
    epollfd = epoll_create(5);
    addfd(epollfd, listenfd);

    socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);
    set_nonblocking(pipefd[1]);
    /* å¯¹ç®¡é“è¯»ç«¯è¿›è¡Œç›‘å¬ï¼Œå¦‚æœæœ‰ä¿¡å·äº§ç”Ÿå°±ä¼šè¢«ä¼ é€’ç»™ä¸»ç¨‹åºå¾ªç¯ */
    addfd(epollfd, pipefd[0]);

    /* è®¾ç½®ä¿¡å·å¤„ç†å‡½æ•° */
    add_sig(SIGALRM);
    add_sig(SIGTERM);
    bool stop_server = false;

    client_data* users = new client_data[FD_LIMIT];
    bool timeout = false;
    alarm(TIMESLOT);

    while (!stop_server) {

        int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);
        if ((number < 0) && (errno != EINTR)) {
            printf("epoll failure\n");
            break;
        }

        for (int i = 0; i < number; i++) {

            int sockfd = events[i].data.fd;

            /* å¤„ç†æ–°åˆ°çš„å®¢æˆ·è¿æ¥ */
            if (sockfd == listenfd) {
                struct sockaddr_in client_address{};
                socklen_t client_addr_length = sizeof(client_address);
                int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addr_length);

                addfd(epollfd, connfd);
                users[connfd].address = client_address;
                users[connfd].sockfd = connfd;

                /* åˆ›å»ºå®šæ—¶å™¨ï¼Œè®¾ç½®å…¶å›è°ƒå‡½æ•°ä¸è¶…æ—¶æ—¶é—´ï¼Œç„¶åç»‘å®šå®šæ—¶å™¨ä¸ç”¨æˆ·æ•°æ®ï¼Œæœ€åå°†å®šæ—¶å™¨æ·»åŠ åˆ°é“¾è¡¨ timer_lst ä¸­ */
                tw_timer* timer = wheel.add_timer(3 * TIMESLOT);
                timer->user_data = &users[connfd];
                timer->cb_func = cb_func;
                users[connfd].timer = timer;
                
            /* æœ‰ä¿¡å·äº§ç”Ÿå¹¶ä¸”è¢«ä¼ é€’ç»™è¿›ç¨‹ */
            } else if ((sockfd == pipefd[0]) && (events[i].events & EPOLLIN)) {
                /* å¤„ç†ä¿¡å· */
                int sig;
                char signals[1024];
                ret = recv(pipefd[0], signals, sizeof(signals), 0);

                if (ret == -1 || ret == 0) {
                    // handle the error
                    continue;
                } else {
                    for (int j = 0; j < ret; j++) {
                        switch (signals[j]) {
                            case SIGALRM: {
                                /* ç”¨ timeout å˜é‡æ ‡è®°æœ‰å®šæ—¶ä»»åŠ¡éœ€è¦å¤„ç†ï¼Œä½†ä¸ç«‹å³å¤„ç†å®šæ—¶ä»»åŠ¡ã€‚
                                 * è¿™æ˜¯å› ä¸ºå®šæ—¶ä»»åŠ¡çš„ä¼˜å…ˆçº§ä¸æ˜¯å¾ˆé«˜ï¼Œæˆ‘ä»¬ä¼˜å…ˆå¤„ç†å…¶ä»–æ›´é‡è¦çš„ä»»åŠ¡
                                 */
                                timeout = true;
                                break;
                            }
                            case SIGTERM: {
                                stop_server = true;
                            }
                        }
                    }
                }
            } else if (events[i].events & EPOLLIN) {
                /* å¤„ç†å®¢æˆ·è¿æ¥ä¸Šæ¥æ”¶åˆ°çš„æ•°æ® */
                memset(users[sockfd].buf, '\0', BUFFER_SIZE);
                ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - 1, 0);
                printf("get %d bytes of client data %s from %d\n", ret, users[sockfd].buf, sockfd);

                tw_timer* timer = users[sockfd].timer;

                if (ret < 0) {
                    /* å¦‚æœå‘ç”Ÿè¯»é”™è¯¯ï¼Œåˆ™å…³é—­è¿æ¥ï¼Œå¹¶ä¸”ç§»é™¤å…¶å¯¹åº”çš„å®šæ—¶å™¨ */
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        cb_func(&users[sockfd]);
                        if (timer) {
                            wheel.del_timer(timer);
                        }
                    }
                } else if (ret == 0) {
                    /* å¦‚æœå¯¹æ–¹å·²ç»å…³é—­è¿æ¥ï¼Œåˆ™æˆ‘ä»¬ä¹Ÿå…³é—­è¿æ¥ï¼Œå¹¶ä¸”ç§»é™¤å¯¹åº”çš„å®šæ—¶å™¨ */
                    cb_func(&users[sockfd]);
                    if (timer) {
                        wheel.del_timer(timer);
                    }
                } else {
                    /* å¦‚æœæŸä¸ªå®¢æˆ·è¿æ¥ä¸Šæœ‰æ•°æ®å¯è¯»ï¼Œåˆ™æˆ‘ä»¬è¦è°ƒæ•´è¯¥è¿æ¥å¯¹åº”çš„å®šæ—¶å™¨ï¼Œä»¥å»¶è¿Ÿè¯¥è¿æ¥è¢«å…³é—­çš„æ—¶é—´ */
                    if (timer) {
                        wheel.del_timer(timer);
                        tw_timer* tw = wheel.add_timer(3 * TIMESLOT);
                        tw->cb_func = cb_func;
                        tw->user_data = &users[sockfd];

                        users[sockfd].timer = tw;
                        printf("adjust timer once\n");
                    }
                }
            } else {
                // others
            }
        }

        /* æœ€åå¤„ç†å®šæ—¶äº‹ä»¶ï¼Œå› ä¸º I/O äº‹ä»¶æœ‰æ›´é«˜æ•ˆçš„ä¼˜å…ˆçº§ã€‚å½“ç„¶ï¼Œè¿™æ ·åšå°†å¯¼è‡´å®šæ—¶ä»»åŠ¡ä¸èƒ½ç²¾ç¡®åœ°æŒ‰ç…§é¢„æœŸçš„æ—¶é—´æ‰§è¡Œ */
        if (timeout) {
            /* è°ƒç”¨å®šæ—¶å™¨åˆ—è¡¨çš„ tick å‡½æ•°ï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œå³ä¸€æ®µæ—¶é—´æ²¡æœ‰æ•°æ®ä¼ è¾“çš„è¿æ¥ï¼Œå¹¶ä¸”å°†è¿æ¥å…³é—­ */
            timer_handler();
            timeout = false;
        }
    }

    close(listenfd);
    close(pipefd[1]);
    close(pipefd[0]);
    delete [] users;

    return 0;
}
```

å½“è¿è¡Œä¸Šè¿°æœåŠ¡å™¨è¿›ç¨‹æ—¶ï¼Œç”±äºæ¯éš” **`TIMESLOT`**ï¼ˆ5sï¼‰æ—¶é—´å°±ä¼šäº§ç”Ÿ **`SIGALRM`** ä¿¡å·ï¼Œä¿¡å·å¤„ç†å™¨æ•è·ä¹‹åå°±ä¼šå°†å…¶ä¼ é€’ç»™è¿›ç¨‹ä¸»å¾ªç¯ï¼Œè¿›è€Œå°† timeout è®¾ç½®ä¸º trueï¼Œæœ€ååœ¨ timer_handler ä¸­è°ƒç”¨æ—¶é—´è½®çš„ tick å‡½æ•°ï¼Œåœ¨æ§åˆ¶å°æ‰“å° **`current slot is X`**ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åœ¨ç»ˆç«¯ä½¿ç”¨ **`telnet`** å‘æœåŠ¡å™¨å‘é€è¿æ¥è¯·æ±‚ï¼ŒæœåŠ¡å™¨è¿›ç¨‹å°†ä¾æ®æ­¤è¿æ¥è¶…æ—¶æ—¶é—´åˆ›å»ºä¸€ä¸ªå®šæ—¶å™¨ï¼Œå¹¶æ·»åŠ åˆ°æ—¶é—´è½®ä¸­ï¼Œä¸‹é¢åˆ›å»ºçš„å®šæ—¶å™¨æ§½ **`ts = 41ï¼Œrotation = 0`**ï¼Œç„¶åå½“ telnet å‘é€æ•°æ®æ—¶ï¼Œä¼šé‡ç½®å®šæ—¶å™¨çš„è¶…æ—¶æ—¶é—´ï¼Œè¿›è€Œé‡ç½®å®šæ—¶å™¨åœ¨æ—¶é—´è½®ä¸­çš„ä½ç½® **`ts = 53ï¼Œrotation = 0`**ï¼Œåç»­åŒç†ï¼Œé‡ç½®åˆ° **`ts = 55ï¼Œrotation = 0`**ã€‚å½“æ—¶é—´è½®çš„ tick åˆ°ç¬¬ 55 ä¸ªæ§½æ—¶ï¼Œä¾¿ä¼šæ¸…ç†è¯¥æ—¶é—´æ§½é“¾è¡¨ä¸­æ‰€æœ‰åˆ°æœŸçš„å®šæ—¶å™¨ï¼ˆåŒ…æ‹¬ä¸Šé¢é‡ç½®åçš„å®šæ—¶å™¨ï¼‰ï¼Œæ‰§è¡Œå®šæ—¶ä»»åŠ¡ï¼Œå³å…³é—­åœ¨è¶…æ—¶æ—¶é—´èŒƒå›´å†…æ²¡æœ‰æ”¶åˆ°ä»»ä½•æ•°æ®çš„å¥—æ¥å­—æè¿°ç¬¦ sockfdã€‚

```shell{.line-numbers}
/home/xuweilin/CLionProjects/http_parser/cmake-build-debug/time_wheel
current slot is 0
current slot is 1
current slot is 2
......
current slot is 24
current slot is 25
add timer, rotation is 0, ts is 41, cur_slot is 26
current slot is 26
......
current slot is 31
current slot is 32
......
current slot is 37
get 2 bytes of client data ok from 8
add timer, rotation is 0, ts is 53, cur_slot is 38
adjust timer once
current slot is 38
current slot is 39
get 7 bytes of client data hello from 8
add timer, rotation is 0, ts is 55, cur_slot is 40
adjust timer once
current slot is 40
current slot is 41
......
current slot is 55
tick the timer once
close fd 8
delete header in cur_slot
```

## 3.æ—¶é—´å †

å‰é¢è®¨è®ºçš„å®šæ—¶æ–¹æ¡ˆéƒ½æ˜¯ä»¥å›ºå®šçš„é¢‘ç‡è°ƒç”¨å¿ƒæå‡½æ•° **`tick`ï¼ˆå³æ¯éš”ä¸€æ®µæ—¶é—´è§¦å‘ **`SIGALRM`** ä¿¡å·ï¼Œä¿¡å·é€šçŸ¥è¿›ç¨‹ä¸»å¾ªç¯è°ƒç”¨ **`tick`** å‡½æ•°ï¼‰**ï¼Œå¹¶åœ¨å…¶ä¸­ä¾æ¬¡æ£€æµ‹åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œç„¶åæ‰§è¡Œåˆ°æœŸå®šæ—¶å™¨ä¸Šçš„å›è°ƒå‡½æ•°ã€‚

è®¾è®¡å®šæ—¶å™¨çš„å¦å¤–ä¸€ç§æ€è·¯æ˜¯ï¼š**å°†æ‰€æœ‰å®šæ—¶å™¨ä¸­è¶…æ—¶æ—¶é—´æœ€å°çš„ä¸€ä¸ªå®šæ—¶å™¨çš„è¶…æ—¶å€¼ä½œä¸ºå¿ƒæé—´éš”**ã€‚è¿™æ ·ï¼Œä¸€æ—¦å¿ƒæå‡½æ•° tick è¢«è°ƒç”¨ï¼Œè¶…æ—¶æ—¶é—´æœ€å°çš„å®šæ—¶å™¨å¿…ç„¶åˆ°æœŸï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ tick å‡½æ•°ä¸­å¤„ç†è¯¥å®šæ—¶å™¨ã€‚ç„¶åï¼Œå†æ¬¡ä»å‰©ä½™çš„å®šæ—¶å™¨ä¸­æ‰¾å‡ºè¶…æ—¶æ—¶é—´æœ€å°çš„ä¸€ä¸ªï¼Œå¹¶å°†è¿™æ®µæœ€å°æ—¶é—´è®¾ç½®ä¸ºä¸‹ä¸€æ¬¡å¿ƒæé—´éš”ã€‚å¦‚æ­¤åå¤ï¼Œå°±å®ç°äº†è¾ƒä¸ºç²¾ç¡®çš„å®šæ—¶ã€‚

å‡è®¾æˆ‘ä»¬å·²ç»æœ‰ä¸€ä¸ªåŒ…å« **`N`** ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œç°åœ¨è¦æŠŠå®ƒåˆå§‹åŒ–ä¸ºä¸€ä¸ªæœ€å°å †ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼š

- æœ€ç®€å•çš„æ–¹æ³•æ˜¯ï¼šåˆå§‹åŒ–ä¸€ä¸ªç©ºå †ï¼Œç„¶åå°†æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ’å…¥è¯¥å †ä¸­ï¼Œæ¯ä¸ªå…ƒç´ è¢«æ’å…¥è¯¥æ•°ç»„çš„æœ«å°¾ï¼Œå³è¯¥å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªå¶å­ç»“ç‚¹ï¼Œç„¶åæ‰§è¡Œä¸Šè™‘æ“ä½œï¼Œå°†è¯¥å…ƒç´ äº¤æ¢åˆ°åˆé€‚çš„ä½ç½®ï¼Œä¸è¿‡è¿™æ ·åšçš„æ•ˆç‡åä½ã€‚
- ç¬¬äºŒç§æ–¹æ³•ï¼šæˆ‘ä»¬åªéœ€è¦å¯¹æ•°ç»„ä¸­çš„ç¬¬ **`[(N - 1) / 2] ~ 0`** ä¸ªå…ƒç´ æ‰§è¡Œä¸‹è™‘æ“ä½œï¼Œå³å¯ç¡®ä¿è¯¥æ•°ç»„æ„æˆä¸€ä¸ªæœ€å°å †ã€‚**è¿™æ˜¯å› ä¸ºå¯¹åŒ…å« N ä¸ªå…ƒç´ çš„å®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼Œå®ƒå…·æœ‰ **`[(N - 1) / 2]`** ä¸ªéå¶å­èŠ‚ç‚¹**ï¼Œè¿™äº›éå¶å­èŠ‚ç‚¹æ­£æ˜¯è¯¥å®Œå…¨äºŒå‰æ ‘çš„ç¬¬ **`0 ï½ [(N - 1) / 2]`** ä¸ªèŠ‚ç‚¹ã€‚**æˆ‘ä»¬åªè¦ç¡®ä¿è¿™äº›éå¶å­èŠ‚ç‚¹æ„æˆçš„å­æ ‘éƒ½å…·æœ‰å †åºæ€§è´¨ï¼Œæ•´ä¸ªæ ‘å°±å…·æœ‰å †åºæ€§è´¨**ã€‚

```cpp{.line-numbers}
#ifndef HTTP_PARSER_MEAN_HEAP_H
#define HTTP_PARSER_MEAN_HEAP_H

#include <iostream>
#include <netinet/in.h>
#include <ctime>

using std::exception;
#define BUFFER_SIZE 64

class heap_timer;
/* ç»‘å®š socket å’Œå®šæ—¶å™¨ */
struct client_data {
    sockaddr_in address;
    int sockfd;
    char buf[BUFFER_SIZE];
    heap_timer* timer;
};

class heap_timer {
public:
    /* å®šæ—¶å™¨ç”Ÿæ•ˆçš„ç»å¯¹æ—¶é—´ */
    time_t expire;
    /* å®šæ—¶å™¨çš„å›è°ƒå‡½æ•° */
    void (*cb_func)(client_data*);
    /* ç”¨æˆ·æ•°æ® */
    client_data* user_data;
public:
    heap_timer(int delay) {
        expire = time(nullptr) + delay;
    }
};

class time_heap {
private:
    /* å †æ•°ç»„ */
    heap_timer** array;
    /* å †æ•°ç»„çš„å®¹é‡ */
    int capacity;
    /* å †æ•°ç»„å½“å‰åŒ…å«å…ƒç´ çš„ä¸ªæ•° */
    int cur_size;
public:
    /* æ„é€ å‡½æ•°ä¹‹ä¸€ï¼Œåˆå§‹åŒ–ä¸€ä¸ªå¤§å°ä¸º cap çš„ç©ºå † */
    time_heap(int cap) throw(std::exception): capacity(cap), cur_size(0) {
        /* åˆ›å»ºå †æ•°ç»„ */
        array = new heap_timer *[cap];

        for (int i = 0; i < capacity; ++i) {
            array[i] = nullptr;
        }
    }

    time_heap(heap_timer** init_array, int size, int capacity)
            throw(std::exception): cur_size(size), capacity(capacity) {
        if (capacity < size) {
            throw std::exception();
        }

        /* åˆ›å»ºå †æ•°ç»„ */
        array = new heap_timer * [capacity];
        for (int i = 0; i < capacity; ++i) {
            array[i] = nullptr;
        }
        if (size != 0) {
            /* åˆå§‹åŒ–å †æ•°ç»„ */
            for (int i = 0; i < size; ++i) {
                array[i] = init_array[i];
            }
            for (int i = (cur_size - 1) / 2; i >= 0; --i) {
                /* å¯¹æ•°ç»„ä¸­çš„ç¬¬ [(cur_size - 1) / 2] ~ 0 ä¸ªå…ƒç´ æ‰§è¡Œä¸‹è™‘æ“ä½œ */
                percolate_down(i);
            }
        }
    }

    /* é”€æ¯æ—¶é—´å † */
    ~time_heap() {
        for (int i = 0; i < cur_size; ++i) {
            delete array[i];
        }
        delete[] array;
    }

public:
    /* æ·»åŠ ç›®æ ‡å®šæ—¶å™¨ timer */
    /* add_timer å°†æ–°çš„å®šæ—¶å™¨æ’å…¥åˆ°å †ä¸­ï¼Œç„¶åå¯¹å…¶æ‰§è¡Œä¸Šè™‘æ“ä½œ */
    void add_timer(heap_timer* timer) throw (std::exception) {
        if (!timer) {
            return;
        }

        if (cur_size >= capacity) {
            /* å¦‚æœå½“å‰å †æ•°ç»„çš„å®¹é‡ä¸å¤Ÿï¼Œåˆ™å°†å…¶æ‰©å¤§ 1 å€ */
            resize();
        }
        /* æ–°æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œå½“å‰å †çš„å¤§å°åŠ  1ï¼Œhole æ˜¯æ–°å»ºç©ºç©´çš„ä½ç½® */
        int hole = cur_size++;
        int parent = 0;
        /* å¯¹ä»ç©ºç©´åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹æ‰§è¡Œä¸Šè™‘æ“ä½œ */
        for (; hole > 0; hole = parent) {
            parent = (hole - 1) / 2;
            if (array[parent]->expire <= timer->expire) {
                break;
            }
            array[hole] = array[parent];
        }
        array[hole] = timer;
    }

    /* åˆ é™¤ç›®æ ‡å®šæ—¶å™¨ timer */
    void del_timer(heap_timer* timer) {
        if (!timer) {
            return;
        }
        /* ä»…å°†ç›®æ ‡å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°è®¾ç½®ä¸ºç©ºï¼Œå®ç°æ‰€è°“çš„å»¶è¿Ÿé”€æ¯ï¼Œè¿™å°†èŠ‚çœçœŸæ­£åˆ é™¤è¯¥å®šæ—¶å™¨é€ æˆçš„å¼€é”€ï¼Œä½†æ˜¯è¿™æ ·åšå®¹æ˜“ä½¿å¾—å †æ•°ç»„è†¨èƒ€ */
        timer->cb_func = nullptr;
    }

    /* è·å¾—å †é¡¶éƒ¨çš„å®šæ—¶å™¨ */
    heap_timer* top() const {
        if (empty()) {
            return nullptr;
        }
        return array[0];
    }

    /* åˆ é™¤å †é¡¶éƒ¨çš„å®šæ—¶å™¨ */
    void pop_timer() {
        if (empty()) {
            return;
        }

        if (array[0]) {
            delete array[0];
            /* å°†åŸæ¥çš„å †é¡¶å…ƒç´ æ›¿æ¢ä¸ºå †æ•°ç»„ä¸­æœ€åä¸€ä¸ªå…ƒç´  */
            array[0] = array[--cur_size];
            /* å¯¹æ–°çš„å †é¡¶å…ƒç´ æ‰§è¡Œä¸‹è™‘æ“ä½œ */
            percolate_down(0);
        }
    }

    /* å¿ƒåšå‡½æ•° */
    void tick() {
        heap_timer* tmp = array[0];
        /* å¾ªç¯å¤„ç†å †ä¸­åˆ°æœŸçš„å®šæ—¶å™¨ */
        time_t cur = time(nullptr);
        while (!empty()) {
            if (!tmp) {
                break;
            }
            /* å¦‚æœå †é¡¶å®šæ—¶å™¨æ²¡åˆ°æœŸï¼Œåˆ™é€€å‡ºå¾ªç¯ */
            if (cur < tmp->expire) {
                break;
            }
            /* å¦åˆ™å°±æ‰§è¡Œå †é¡¶å®šæ—¶å™¨ä¸­çš„ä»»åŠ¡ */
            if (array[0]->cb_func) {
                array[0]->cb_func(array[0]->user_data);
            }
            /* å°†å †é¡¶å…ƒç´ åˆ é™¤ï¼ŒåŒæ—¶ç”Ÿæˆæ–°çš„å †é¡¶å®šæ—¶å™¨ */
            pop_timer();
            tmp = array[0];
        }
    }

    bool empty() const {
        return cur_size == 0;
    }

private:
    /* æœ€å°å †çš„ä¸‹è™‘æ“ä½œï¼Œå®ƒç¡®ä¿å †æ•°ç»„ä¸­ä»¥ç¬¬ hole ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹çš„å­æ ‘æ‹¥æœ‰æœ€å°å †çš„æ€§è´¨ */
    void percolate_down(int hole) {
        heap_timer* temp = array[hole];
        int child = 0;
        for (; ((hole * 2 + 1) <= (cur_size - 1)); hole = child) {
            child = hole * 2 + 1;
            if ((child < (cur_size - 1))
                && (array[child + 1]->expire < array[child]->expire)) {
                child++;
            }

            if (temp->expire > array[child]->expire) {
                array[hole] = array[child];
            } else {
                break;
            }
        }
        array[hole] = temp;
    }

    /* å°†å †çš„æ•°ç»„å®¹é‡æ‰©å¤§ 1 å€ */
    void resize() throw(std::exception) {
        heap_timer** temp = new heap_timer* [2 * capacity];
        for (int i = 0; i < 2 * capacity; ++i) {
            temp[i] = nullptr;
        }

        capacity = 2 * capacity;
        for (int i = 0; i < cur_size; ++i) {
            temp[i] = array[i];
        }
        delete[] array;
        array = temp;
    }
};

#endif //HTTP_PARSER_MEAN_HEAP_H
```

åœ¨ä¸Šé¢çš„æœ€å°æ—¶é—´å † **`min_heap`** ä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ•°ç»„æ¥å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ï¼Œç„¶åå¯¹æ•°ç»„ä¸­çš„ç¬¬ **`[(N - 1) / 2] ~ 0`** ä¸ªå…ƒç´ æ‰§è¡Œä¸‹è™‘æ“ä½œï¼Œå°†æ•°ç»„åˆå§‹åŒ–ä¸ºä¸€ä¸ªæœ€å°å †ã€‚ç„¶åå½“ **`tick`** å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œå¾ªç¯å¤„ç†æ—¶é—´å †ä¸­åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œæœ€å¼€å§‹æ˜¯å †é¡¶çš„å®šæ—¶å™¨ï¼ˆ**array[0]**ï¼‰ï¼Œç„¶åå°†åŸæ¥çš„å †é¡¶å…ƒç´ æ›¿æ¢ä¸ºå †æ•°ç»„ä¸­æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¯¹æ–°çš„å †é¡¶å…ƒç´ æ‰§è¡Œä¸‹è™‘æ“ä½œï¼Œç”Ÿæˆæ–°çš„æœ€å°å †ã€‚

å¾€æœ€å°å †ä¸­æ·»åŠ å®šæ—¶å™¨ï¼ˆ**`time_heap::add_timer`**ï¼‰ä¼šæŠŠæ–°çš„å®šæ—¶å™¨æ·»åŠ åˆ°æ­¤å®Œå…¨äºŒå‰æ ‘æœ€åçš„å¶å­èŠ‚ç‚¹ä¸Šï¼Œç„¶åæ—¶é—´å †ä¼šæ‰§è¡Œä¸Šè™‘æ“ä½œï¼Œå°†æ­¤å®šæ—¶å™¨è°ƒæ•´åˆ°åˆé€‚çš„ä½ç½®ã€‚