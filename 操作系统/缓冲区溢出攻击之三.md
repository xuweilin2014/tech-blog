# 缓冲区溢出攻击之三

## 八、地址和 buffer 大小未知时进行攻击

## 九、防御措施

### 1.地址随机化

为了成功实施缓冲区溢出攻击，**<font color="red">攻击者需要使漏洞程序 "返回/跳转" 到他们注入的代码，因此他们首先需要猜测注入代码在什么地址</font>**，猜测成功率取决于攻击者对栈的位置的预测能力。操作系统以前总是把栈放在固定位置，这给攻击者提供了很大的便利。

栈的起始地址固定是否必要? 答案是否定的。**<font color="red">对于存储在栈中的所有数据而言，它们的地址并非固定写在二进制代码中，而是基于帧指针 %ebp 和栈指针 %esp 计算得到的</font>**。换言之，数据的地址是通过这两个寄存器以及偏移值来表示的，而不是栈的起始地址。因此，即使把栈放在另一个地址，只要 %ebp 和 %esp 被正确设置，程序也能正常运行。

#### 1.1 Linux 中的地址随机化

运行一个程序之前，操作系统需要把该程序加载入系统，这是由操作系统的加载程序完成的。**<font color="red">在加载阶段，加载器为程序准备堆栈内存。因此，地址随机化通常在加载器中实现</font>**。在 Linux 系统中，ELF 是一种通用的二进制文件格式，对于这种类型的二进制程序，地址随机化在 ELF 加载器上实现。ASLR 会在每次程序执行时随机化关键内存区域的地址布局，包括：

- 栈（Stack）：栈的起始位置会被随机化；
- 堆（Heap）：堆的起始位置也会被随机化；
- 共享库（Shared Libraries）：动态链接库（如 .dll 文件）在内存中的加载地址会随机化；
- 程序代码段：程序的代码执行区（通常是 .text 段）位置同样会被随机化；

为了理解地址随机化，下面编写了一个程序，程序中包含 2 个缓冲区，一个在栈上分配，另外一个在堆上分配：

```c{.line-numbers}
#include <stdio.h>
#include <stdlib.h>

void main() {
    char x[12];
    char* y = malloc(sizeof(char)*12);

    printf("Address of buffer x (on stack): 0x%p\n", x);
    printf("Address of buffer y (on heap): 0x%p\n", y);
}
```

我们使用 **`gcc test.c -no-pie`** 命令编译上述代码文件，可以通过设置一个内核变量 **`kernel.randomize_va_space`** 告知加载器我们想要使用的地址随机化类型。当这个内核变量被设置为 0 时，地址随机化将被关闭，每次运行代码都得到相同的 x、y 地址。当将它改为 1 时（保守随机化），栈缓冲区的地址发生改变，而堆仍然保持相同地址，这是因为该类型并不随机化堆的内存。**当将这个值改为 2 时，堆和栈都会做随机化处理**。

>Modern Linux kernels have ASLR enabled by default with the specific value 2.
>Normally you might expect a value of 0 (disabled), or 1 (enabled). In the case of the **`randomize_va_space`** setting, this is true as well. When setting the value to 1, address space is randomized. This includes the positions of the stack itself, virtual dynamic shared object (VDSO) page, and shared memory regions. Setting the option to value 2 will be similar to 1, and add data segments and heap as well. For most systems, this setting is the default and the most secure setting.

```shell{.line-numbers}
# 当 randomize_va_space=0 时，栈和堆的起始位置都保持不变
monica@mxvm:~/csapp/chapter3$ sudo sysctl -w kernel.randomize_va_space=0
kernel.randomize_va_space = 0
monica@xvm:~/csapp/chapter3$ ./a.out 
Address of buffer x (on stack): 0x0x7fffffffdf3c
Address of buffer y (on heap): 0x0x4052a0
monica@xvm:~/csapp/chapter3$ ./a.out 
Address of buffer x (on stack): 0x0x7fffffffdf3c
Address of buffer y (on heap): 0x0x4052a0

# 当 randomize_va_space=1 时，堆的起始位置保持不变，栈的起始位置发生变化
monica@mxvm:~/csapp/chapter3$ sudo sysctl -w kernel.randomize_va_space=1
kernel.randomize_va_space = 1
monica@xvm:~/csapp/chapter3$ ./a.out 
Address of buffer x (on stack): 0x0x7ffecdde069c
Address of buffer y (on heap): 0x0x4052a0
monica@xvm:~/csapp/chapter3$ ./a.out 
Address of buffer x (on stack): 0x0x7ffd08aa490c
Address of buffer y (on heap): 0x0x4052a0

# 当 randomize_va_space=2 时，堆和栈的起始位置均发生变化
monica@xvm:~/csapp/chapter3$ sudo sysctl -w kernel.randomize_va_space=2
kernel.randomize_va_space = 2
monica@xvm:~/csapp/chapter3$ ./a.out 
Address of buffer x (on stack): 0x0x7ffc2642ed8c
Address of buffer y (on heap): 0x0x224212a0
monica@xvm:~/csapp/chapter3$ ./a.out 
Address of buffer x (on stack): 0x0x7ffea0e483dc
Address of buffer y (on heap): 0x0x22bc2a0
```

#### 1.2 地址随机化的有效性

衡量地址空间随机程度的一种方式是熵。如果一个内存空间区域拥有 n 比特 (bit) 熵，这表明此系统上该区域的基地址有 $2^n$ 种等可能的位置。熵取决于在内核中实施的 ASLR 类型。例如在 32 位 Linux 操作系统中，**当使用静态 ASLR (即除了程序映像以外的内存区域都被随机化)，栈的可用熵为 19 bit，也就是栈的起始地址有 $2^{19}$ 种可能，堆为 13 bit**。

实现 ASLR 时，当随机化的可用熵不够大时，攻击者可以采用暴力破解攻击。为了抵御暴力破解，有些 ASLR 的实现，如 grsecurity，在程序崩溃次数达到一定数量后，在一段时间内会禁止该程序再次被执行。

如上所述，在 32 位 Linux 操作系统中，栈只有 19 bit 的熵，意味着栈的基地址只有 $2^{19}=524, 288$ 种可能性。这个数字并不算大，它能被轻易地暴力破解。为了证实这一点，编写下面的脚本来重复地发起缓冲区溢出攻击（即重复执行 stack 二进制程序），希望碰巧猜中栈的内存地址。在运行脚本之前，需要设置 **`kernel.randomize_va_space`** 为 2，从而完全打开内存地址随机化。

```shell{.line-numbers}
SECONDS=0
value=0

while [1]
    do
    value=$(( $value + 1))
    duration=$SECONDS
    min=$(($duration / 60))
    sec=$(($duration % 60))
    echo "$min minutes and $sec seconds elapsed."
    echo "The program has been running $value times so far."
    ./stack
done
```

在本实验中，运行上面的脚本 19 分钟（12518 次尝试）之后，在 badfile 文件中放入的地址恰好正确，恶意代码得到执行。

```shell{.line-numbers}
...
19 minutes and 14 seconds elapsed.
The program has been running 12516 times so far.
...:line 12: 31695 Segmentation fault (core dumped) ./stack
19 minutes and 14 seconds elapsed.
The program has been running 12517 times so far.
...:line 12: 31697 Segmentation fault (core dumped) ./stack
19 minutes and 14 seconds elapsed.
The program has been running 12518 times so far.
#
```

在上面的攻击中，已经把恶意代码置入 badfile 中，但是由于地址随机化，该文件中放入的地址可能是错误的。从前面的 exploit.py 文件可以看出，**放在返回地址中的跳转地址（跳转到恶意代码）是固定的 `0xbfffeaf8 + 100`（下图中的 50 也可以）**。

下面图（a）和图（b）分别是跳转地址命中和未命中的情形，由于跳转地址固定，因此在栈随机化时，当 buffer 地址在 **`0xbfffea8c`** 左右小幅波动时，跳转地址即可命中，即 $\scriptsize{M\leq{RT\leq{N}}}$，如图（a）所示；但是当 buffer 的地址变化较大时， 跳转地址很可能无法命中，即 $\scriptsize{RT\lt{M}}$ 或者 $\scriptsize{RT\gt{N}}$，如图（b）所示。

<div align="center">
    <div align="center" style="color: black; font-size:13px; font-weight:bold">图 (a)  返回地址命中</div>
    <img src="缓冲区溢出攻击_static//16.png" width="500"/><br/>
    <div align="center" style="color: black; font-size:13px; font-weight:bold">图 (b)  返回地址未命中</div>
    <img src="缓冲区溢出攻击_static//17.png" width="600"/>
</div>

对于 64 位的 Linux 操作系统，上述攻击将会困难很多。

### 2.StackGuard

