# 4.高可用 REST 通信

## 4.1 案例工程改造

（1）原有工程的问题

- 公共模块过于庞大
  - 将公共模块按功能拆分为多个小模块，例如 DTO 模块、Util 模块等，确保每个模块职责单一；
- 远程调用代码复杂化
  - **<font color="red">硬编码的服务 URL</font>**：代码中直接使用 Eureka Client 获取服务实例并拼接 URL；
  - **<font color="red">缺乏错误处理</font>**：代码中对服务调用的错误处理不够完善，特别是对用户服务的调用；
  - **<font color="red">缺乏超时和重试机制</font>**：代码中没有配置超时和重试机制，可能导致服务调用长时间挂起；
  - **<font color="red">缺乏日志记录</font>**：代码中缺乏详细的日志记录，特别是在服务调用失败时；
  - **<font color="red">缺乏缓存机制</font>**：代码中没有使用缓存机制，可能导致频繁的服务调用，增加系统负载；

（2）项目结构说明

调整之后的项目结构如下所示：

```yaml{.line-numbers}
architecture-station 父工程
│
├── architecture-station-course-module 课程模块
│   ├── architecture-station-course-service 课程原子服务
│   │   └── src
│   │       └── main
│   │           └── java
│   │               └── com
│   │                   └── sa
│   │                       └── course
│   │                           ├── controller
│   │                           ├── service
│   │                           ├── msmapper
│   │                           ├── mapper
│   │                           └── dataobject
│   └── architecture-station-course-api 课程 API 服务
│       └── src
│           └── main
│               └── java
│                   └── com
│                       └── sa
│                           └── course
│                               └── api
│                                   ├── dto
│                                   ├── feignapi
│																	

├── architecture-station-user-module 用户模块
│
│   ├── architecture-station-user-service 用户原子服务
│   │   └── src
│   │       └── main
│   │           └── java
│   │               └── com
│   │                   └── sa
│   │                       └── user
│   │                           ├── controller
│   │                           ├── service
│   │                           ├── msmapper
│   │                           ├── mapper
│   │                           └── dataobject
│   └── architecture-station-user-api 用户 API 服务
│       └── src
│           └── main
│               └── java
│                   └── com
│                       └── sa
│                           └── user
│                               └── api
│                                   ├── dto
│                                   ├── feignapi
│
└── architecture-station-course-aggregation-service 课程聚合服务
    └── src
        └── main
            └── java
                └── com
                    └── sa
                        └── aggregation
                            ├── controller
                            ├── service
                            └── vo
```

## 4.2 OpenFeign 远程通信

### 4.2.1 概述

在 Spring Cloud 中，Feign 是一个声明式的 HTTP 客户端，**<font color="red">通过使用 OpenFeign，开发者可以像调用本地方法一样调用远程 HTTP 服务，而不需要编写大量的模板代码</font>**。OpenFeign 是 Spring Cloud 生态系统的一部分，通常与 Spring Boot 和 Spring Cloud 一起使用，以实现微服务之间的通信，其主要特性如下所示：

- 声明式接口：通过定义接口和注解，OpenFeign 可以自动生成 HTTP 客户端代码；
  - 注解是定义在聚合服务中，服务调用的发起方（或者说客户端），注解为 **`@EnableFeignClients`**；
  - 接口通常与 Controller 方法签名是匹配的，在本案例中定义在 api 工程中，为服务调用的接收方（或者说服务端），接口注解一般为 **`@FeignClient(name="service-name")`**；
- 负载均衡：**与 Spring Cloud LoadBalancer 集成，<font color="red">支持客户端负载均衡</font>**；
- 重试机制：支持配置重试策略，自动重试失败的请求；
- 请求拦截器：**支持自定义请求拦截器，可以在请求发送前进行处理**；
- 日志记录：支持配置日志记录级别，方便调试和监控；
- 与 Spring Cloud 集成：与 Spring Cloud 生态系统无缝集成，支持 Eureka、Ribbon（已弃用）、Spring Cloud LoadBalancer 等组件；

### 4.2.2 OpenFeign 通信案例

（1）在 **`architecture-station-course-api`** 和 **`architecture-station-user-api`** 工程中引入依赖：

```xml{.line-numbers}
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
```

（2）在 **`course-service`** 和 **`instructor-service`** 中定义属于基于 Feign 的 API 接口

```java{.line-numbers}
// com.sa.user.api.feignapi.InstructorApi
@FeignClient(name = "user-service")
public interface InstructorApi {
    // GetMapping 路径和 Api 接口中的方法参数和 InstructorController 类中的方法一样
    @GetMapping("/api/instructors/{instructorId}")
    public ResponseEntity<InstructorDTO> getInstructorById(@PathVariable Integer instructorId );
}
```

```java{.line-numbers}
// com.sa.course.api.feignapi.CourseApi
@FeignClient(name = "course-service")
public interface CourseApi {
    // GetMapping 路径和 Api 接口中的方法参数和 CourseController 类中的方法一样
    @GetMapping("/api/courses/{courseId}")
    public ResponseEntity<CourseDTO> getCourse(@PathVariable Long courseId );
}
```

（3）课程聚合微服务

```java{.line-numbers}
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
@EnableDiscoveryClient
// 启用 Feign 客户端功能，并指定要扫描的包路径，以便 Spring 能够找到并注册 Feign 客户端接口
@EnableFeignClients(basePackages = {"com.sa.course.api.feignapi", "com.sa.user.api.feignapi"})
public class CourseAggregationApplication {
    public static void main(String[] args) {
        SpringApplication.run(CourseAggregationApplication.class, args);
    }
}
```

```java{.line-numbers}
package com.sa.course.aggregation.controller;

/**
 * @author Architecture Station
 * @version 1.0
 */
@RestController
@RequestMapping(value = "/api/courses")
@RequiredArgsConstructor
@Slf4j
public class CourseAggregationController {

    private final RestTemplate restTemplate;
    private final MsCourseDetailMapper msCourseDetailMapper;
    private final CourseApi courseApi;
    private final InstructorApi instructorApi;


    @GetMapping("/{courseId}")
    public ResponseEntity<CourseDetailVO> getCourseDetail(@PathVariable Long courseId) {

        // 调用课程服务获取课程信息
        ResponseEntity<CourseDTO> courseResponseEntity = courseApi.getCourse(courseId);
        // 判断课程信息是否为空
        if (!courseResponseEntity.getStatusCode().is2xxSuccessful() || courseResponseEntity.getBody() == null) {
            return ResponseEntity.notFound().build();
        }
        CourseDTO courseDTO = courseResponseEntity.getBody();

        // 调用用户服务获取讲师信息
        ResponseEntity<InstructorDTO> instructorResponseEntity = instructorApi.getInstructorById(courseDTO.getInstructorId());
        InstructorDTO instructorDTO = null;

        if (instructorResponseEntity.getStatusCode().is2xxSuccessful() && instructorResponseEntity.getBody() != null) {
            instructorDTO = instructorResponseEntity.getBody();
        } else {
            log.error("获取讲师信息失败,失败的讲师ID：{}", courseDTO.getInstructorId());
        }

        return ResponseEntity.ok(msCourseDetailMapper.toCourseDetailVO(courseDTO, instructorDTO));
    }
}
```

### 4.2.3 OpenFeign 工作原理

通过使用 Feign，开发者可以定义声明式的 HTTP 客户端接口，并使用 **`@FeignClient`** 注解标注这些接口。Spring Cloud Feign 会在应用启动时扫描这些接口，**<font color="red">并为每个接口创建一个动态代理对象</font>。这个动态代理对象会拦截对接口方法的调用，并将其转换为 HTTP 请求**。

**1.声明式接口**

首先，开发者定义一个 Feign 客户端接口，并使用 **`@FeignClient`** 注解标注该接口。这个接口定义了要调用的远程服务的 API。

```java{.line-numbers}
@FeignClient(name = "course-service")
public interface CourseApi {
    @GetMapping("/api/courses/{courseId}")
    ResponseEntity<CourseDTO> getCourse(@PathVariable("courseId") Long courseId);
}

@FeignClient(name = "user-service")
public interface InstructorApi {
    @GetMapping("/api/instructors/{instructorId}")
    ResponseEntity<InstructorDTO> getInstructorById(@PathVariable("instructorId") Long instructorId);
}
```

**2.动态代理**

在应用启动时，**Spring Cloud Feign** 会扫描所有标注了 **`@FeignClient`** 注解的接口，并为每个接口创建一个动态代理对象。这个动态代理对象会拦截对接口方法的调用，并将其转换为 HTTP 请求。

**3.自动配置**

Spring Cloud Feign 提供了一系列自动配置类，这些配置类会在应用启动时自动加载，并配置 Feign 客户端的各种属性，如编码器、解码器、错误处理器等。

