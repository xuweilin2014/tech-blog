# 分页机制和动态页面分配之二

## 一、分页机制概述

页的最小单位是 4096 字节，4KB，用十六进制表示即 0x1000，可见页的物理地址的最低 12 位全部为 0。**段管理机制对于 Intel 处理器来说是最基本的，任何时候都无法关闭**。也就是说，即使启用页管理功能，分段机制依然是起作用的，段部件也依然工作。

4GB 虚拟内存空间不可能用来保存任何数据，因为它是虚拟的，它只是用来指示内存的使用情况。当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。从段部件输出的是线性地址或者叫虚拟地址。**<font color="red">为了根据线性地址找到页的物理地址，操作系统必须维护一张表，把线性地址转换成物理地址</font>**。

另外，从线性地址到物理地址的这种变换不是无缘无故的，而是事先安排好的。当任务加载时，操作系统先创建虚拟的段，并根据段地址的高20位决定它要用到哪些页目录项和页表项。**然后寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中**。只有这样做了，当程序运行的时候，才能以相反的顺序进行地址变换，并找到正确的数据。

>只有在保护模式下，才能开启分页模式。

## 二、创建内核的页目录和页表

### 1.内核的页目录和页表

当从主引导程序跳转到内核的入口点 start 处执行时，此时 MBR 程序已经创建了内核的大部分要素：全局描述符表（GDT）、公共例程段、内核数据段、内核代码段、内核栈，还包括一个用于访问全部 4GB 内存空间的段。在开始介绍本章的代码之前，先总体介绍本章程序的结构：

<div align="center">
    <img src="x86-32汇编保护模式代码_static//22.png" width="1200"/>
</div>

接下来的工作是准备开启页功能，首先必须创建页目录和页表。每个任务都有自己的页目录和页表，内核也不例外，尽管它是为所有任务所共有的，但也包括作为任务而独立存在的部分，以执行必要的系统管理工作。**因此要想内核正常运行，必须创建它自己的页目录和页表**。

麻烦在于，内核已经被 MBR 加载完毕，它的所有部分都已经位于内存中。当然，你可能会问，这怎么会是个麻烦事呢？原因是，在一个理想的分页系统中，**想要加载程序**，**必须<font color="red">先</font>搜索可用的页**，并将它们与段对应起来。在这种情况下，段部件输出的线性地址和页部件输出的物理地址不同，是很自然的事，因为一切都发生在程序加载完毕、段和页已经有了确定的映射关系之后。

总的来说即在分页系统中，**<font color="red">必须先登记后使用，在加载程序之前，先在内存中搜索分配给程序的可用物理页，将物理页的地址登记到页目录和页表中，这样就形成了程序线性地址和物理地址的对应</font>**，最后将程序加载到内存中。通过这种先登记后使用的方式形成的程序线性地址和物理地址不太可能相等。

然而，由于内核是在开启页功能之前由 MBR 加载的，段在内存中的位置已经固定。在这种情况下，即使开启了页功能，线性地址也必须和物理地址相同才行。比如在开启页功能之前，GDT 在内存中的基地址是 0x00007E00，它就是全局描述符表的物理地址，段部件输出的线性地址就是物理地址。在开启页功能之后，它还在那个内存位置，其线性地址 0x7E00 保存在 GDTR 寄存器中。这就要求页部件输出的物理地址和段部件输出的线性地址相同。一句话，要求线性地址等于物理地址才行。

为了解决这个问题，同时因为我们内核足够小，因此我们只需要将低端的 1MB 内存进行特殊处理，使这一部分的线性地址和经过页部件转换之后的物理地址相同即可。

在页目录中，一个目录项对应着 1024 个 4KB 物理页，共计 4MB 内存，所以对于内核来说，只需要一个页目录和一个页表就足够了。**并且我们将内核页目录 PDT 放在物理地址 0x00020000 处，把内核的第一个页表放在物理地址 0x00021000 处**。

<div align="center">
    <img src="x86-32汇编保护模式代码_static//23.png" width="450"/>
</div>

接下来创建系统内核的页目录 PDT，并将页目录清零，页目录中有 1024 个目录项，全部清零，主要是为了将所有目录项的 P 位设置为 0，表明该页表不在内存中。

### 2.页目录最后一项指向自己

在建立了一个为空的页目录表之后，**将页目录表的物理地址登记在它自己的最后一个目录项内**。最后一个目录项的偏移量是 0xFFC（4092）。页目录需要频繁地进行修改，为了方便用线性地址访问页目录表自身，需要使用这项技术。注意，填写的内容是 0x00020003，该数值的前 20 位是内核页目录 PDT 物理地址的高 20 位;P=1，页是位于内存中的;RW=1，该目录项指向的页表可读可写。

比如当使用指令 **`mov dword [es:ebx+esi]，0x00021003`**（其中 ebx+esi 为 0xFFFFF800）时，当前内核程序的页目录表，其物理地址是由控制寄存器 CR3 指示的，即 0x20000。段部件产生的线性地址是 0xFFFFF800，其高 10 位的值为 0x3FF，乘以 4 得到页目录项的偏移量 0xFFC，加上 0x20000 就得到页目录最后一个目录项的物理地址 0x20FFC，从而得到页表的基地址 0x20003。

<div align="center">
    <img src="x86-32汇编保护模式代码_static//24.png" width="440"/>
</div>

但是我们之前已经将页目录 PDT 的物理基地址 0x20003 写入到此项中，**<font color="red">因此该目录项所指向的页表正是当前的页目录表自己，这实际上是把页目录表当成页表来用</font>**。接下来用线性地址 0xFFFFF800 的中间 10 位作为偏移量来访问页表。这一次使用的偏移量仍然为 $\scriptsize{0x3FF\times4=0xFFC}$，再加上前面得到的页表物理基地址 0x20000 得到本次要访问的页表项的物理地址 0x20FFC，从而得到物理页的基地址 0x20003。

<div align="center">
    <img src="x86-32汇编保护模式代码_static//25.png" width="500"/>
</div>

因为访问的又是同一内存地址 0x20003，故最终访问的物理页仍然是页目录自己。这次将物理页的基地址 0x20000 加上偏移量 0x800 得到实际要访问内存单元物理地址 0x20800。

<div align="center">
    <img src="x86-32汇编保护模式代码_static//26.png" width="500"/>
</div>

综上所述，**<font color="red">如果页目录表的最后一个目录项指向当前页目录表自己，那么无论任何时候，当线性地址的高 20 位是 0xFFFFF 时，访问的就是页目录表自己</font>**。

### 3.填写内核页目录和页表

接下来将内核页目录 PDT 中的最后一个目录项中的值修改为 0x20003，将第一个目录项中的值修改为 0x21003，指向内核的第一个页表的基地址 0x21000。然后真正创建内核的第一个页表，并将内存低端 1MB 所包含的那些页的物理地址按顺序一个一个地填写到此页表中，当然仅填写 256 个页表项，表示线性地址范围 0x00000000~0x000FFFFF，同时也对应内存物理地址范围 0x00000000~0x000FFFFF。接下来将页目录 PDT 中第 256~1024 页表项的值全部设置为 0。

接下来将内核页目录 PDT 的基地址赋值给 CR3 寄存器，并且将 CR0 控制寄存器的最高位 31 位设置为 1，表示开启分页功能。此这一刻开始，段部件产生的地址不再被看成是物理地址，而是要送往页部件进行变换，以得到真正的物理地址。

目前为止，内核的页目录和页表已经创建并且初始化完毕。

## 三、任务全局空间和局部空间的页面映射

一般来说，**<font color="red">全局地址空间占据着任务 4GB 地址空间的高 2GB，对应的线性地址范围是 0x80000000~0xFFFFFFFF</font>**; 而局部地址空间则使用低 2GB，对应的线性地址范围是 0x00000000~0x7FFFFFFF。地址空间的分配必须在每个任务的页目录中体现，页目录的前半部分指向任务自己的页表; 后半部分则指向内核的页表。否则的话，当转到内核中执行时，是无法完成地址转换的，因为找不到对应的目录项和页表项。在任何任务内，在任何时候，如果段部件发出的线性地址高于等于 0x80000000，指向和访问的就是内核自己。

在内核的页目录表中，创建一个和线性地址 0x80000000 对应的目录项，并使它指向同一个页表。毕竟，我们只改变了线性地址空间范围，内核的数据和代码仍然在原来的页内，没有改变。因此代码中使用 **`mov dword [es:ebx+esi],0x00021003`** 指令将 0x00021003 保存到内核页目录 PDT 中偏移量 0x800 处的页目录项中。

最终，页目录表内有两个目录项都指向同一个页表。不过，尽管指向的是同一个页表，这两个目录项所映射的线性地址是不一样的，旧表项依然对应着线性地址 0x00000000~0x000FFFFF; 新表项则对应着一个高端的地址范围 0x80000000~0x800FFFFF，此两个表项对应的线性地址范围为 1MB。如下图所示。

<div align="center">
    <img src="x86-32汇编保护模式代码_static//27.png" width="450"/>
</div>

仅仅修改页目录表是没有用的，**<font color="red">如果段部件给出的线性地址并不在 0x80000000 以上，是没有用的</font>**。因此必须修改与内核有关的段描述符，包括全局描述符表 (GDT) 自己的线性地址。由于内核各段的地址实际上是在 GDT 的段描述符中指明的，所以需要将 GDT 中的段描述符映射到线性地址 0x80000000 以上，也包括 GDT 起始地址本身。

在 1066~1073 行将 GDT 中 MBR 代码段、内核栈段、文本模式显存段、内核公用例程段、内核数据段和代码段的段描述符中基地址加上 0x80000000。并且将 GDT 的基地址也加上 0x80000000。最后更新 GDTR 寄存器的值。

