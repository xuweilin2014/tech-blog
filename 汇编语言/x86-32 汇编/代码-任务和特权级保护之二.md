# 任务和特权级保护之二

## 一、内核程序的初始化

### 1.内核常数初始化

在内核程序的开头定义了内核需要使用的所有段选择子以及代码段、数据段、公用例程段的偏移量。很显然，这些选择子的 RPL 字段都是 0。这是因为，只有具备能动性的代码段（不一定是当前代码段）才能发出请求，**<font color="red">所以 RPL 是指【真正】发出访问请求的程序的特权级</font>**。但是真正发出访问请求的代码段和当前正在执行的代码段可能不是同一个，所以 CPL 不一定等于 RPL。

但是在这里定义的段选择子都是由内核自己使用，内核自己就是真正的请求访问者，所以 RPL=CPL=0，请求特权级应当为 0。

```armasm{.line-numbers}
    ;内核代码段选择子
    core_code_seg_sel     equ  0x38
    ;内核数据段选择子
    core_data_seg_sel     equ  0x30
    ;系统公共例程代码段的选择子
    sys_routine_seg_sel   equ  0x28
    ;视频显示缓冲区的段选择子
    video_ram_seg_sel     equ  0x20
    ;内核堆栈段选择子
    core_stack_seg_sel    equ  0x18
    ;整个 0-4GB 内存的段的选择子
    mem_0_4_gb_seg_sel    equ  0x08    

    ;以下是系统核心的头部，用于加载核心程序 
    ;核心程序总长度 #00
    core_length      dd core_end       
    ;系统公用例程段偏移量 #04
    sys_routine_seg  dd section.sys_routine.start                
    ;核心数据段偏移量 #08
    core_data_seg    dd section.core_data.start                
    ;核心代码段偏移量 #0c
    core_code_seg    dd section.core_code.start
    ;核心代码段入口点 #10
    core_entry       dd start          
                     dw core_code_seg_sel
```

由于内核工作在 0 特权级，所以主引导程序在初始化内核时，所创建的内核各段的描述符 DPL 均为 0。描述符总是指向它所描述的目标对象，代表着该对象，因此该字段实际上是目标对象的特权级。并且以上各段描述符都是在 GDT 中创建的，如下所示：

<div align="center">
    <img src="x86-32汇编保护模式代码_static//8.png" width="390"/>
</div>

### 2.调用门

在上一章《程序的动态加载和执行》里，内核的主要功能是加载用户程序，为用户程序创建安装段描述符以及重定位用户程序内的符号地址，并将处理器的控制权移交过去。用户程序执行完毕，还要重新回收控制。

现在我们已经知道，在上一章里，内核赋予用户程序的特权级别是 0，所以用户程序是在 0 特权级上运行的。也正是因为如此，当用户程序通过 U-SALT 表中的重定位后的符号地址直接调用内核例程时，才会通过特权级检查（**<font color="red">毕竟相同特权级之间的代码转移总是允许的</font>**）。

