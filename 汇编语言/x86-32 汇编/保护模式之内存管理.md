# 内存管理

## 一、内存寻址

内存是指一组有序字节组成的数组，每个字节有唯一的内存地址。内存寻址则是指对存储在内存中的某个指定数据对象的地址进行定位。80x86 支持多种数据类型：1 字节、2 字节 (1 个字) 或 4 字节 (双字) 的无符号整型数或带符号整型数，以及多字节字符串等。**通常内存地址从 0 开始编址**，对于 80x86 CPU 来说，其地址总线宽度为 32 位，因此一共有 $2^{32}$ 个不同物理地址，因此总共可以寻址 4GB 的物理内存。

>对于多字节数据类型 (例如 2 字节整数数据类型)，80x86 首先存放低值字节，随后地址处存放高值字节。因此 80x86 CPU 是一种先存小值 (Little Endian) 的处理器。

对于 8086 CPU，若要定位内存中的操作数，就要进行内存寻址。为此 8086 使用了一种称为段 (Segment) 的寻址技术。**这种寻址技术把内存空间分成一个或多个称为段的线性区域**，从而对内存中一个数据对象的寻址就需要使用一个 **<font color="red">段的起始地址(即段地址)</font>** 和 **<font color="red">一个段内偏移地址</font>** 两部分构成。段地址部分使用 16 位的段选择符指定，段内偏移地址部分使用 32 位的值来指定，因此段内地址可以是0~4GB。即一个段的最大长度可达4GB。

程序中**由 16 位的段选择子和 32 位的偏移构成的 48 位地址称为一个逻辑地址(虚拟地址)**。

8086 为段部分提供了 6 个存放段选择符的段寄存器：CS、DS、ES、SS、FS 和 GS。其中 CS 总是用于寻址代码段，而堆栈段则专门使用 SS 段寄存器。**在任何指定时刻由 CS 寻址的段称为当前代码段**。段间控制转移指令也就是为 CS 和 EIP 赋予新值，从而可以把执行位置改变到其他的代码段中。这样就实现了在不同段中程序控制的转移。

段寄存器 ss 寻址的段称为当前堆栈段，栈顶由 esp 寄存器指定。因此堆栈顶处地址是 ss:[esp]。当指令中没有指定所操作数据的段时，那么 ds 将是默认的数据段寄存器。为了指定内存操作数的段内偏移地址，32 位处理器指令规定了计算偏移量的很多方式，称为指令寻址方式。指令的偏移量由 3 部分组成:基地址寄存器、变址寄存器和一个偏移常量。三者关系为：**`偏移地址=基地址+(变址×比例因子)+偏移量`**。

## 二、地址变换

任何完整的内存管理系统都包含两个关键部分：保护和地址变换。提供保护措施是可以防止一个任务访问另一个任务或操作系统的内存区域。地址变换能够让操作系统在给任务分配内存时具有灵活性，**并且由于可以让某些物理地址不被任何逻辑地址所映射，所以在地址变换过程中同时也提供了内存保护功能**。

程序中的地址是由两部分（【选择符】和【偏移量】）构成的逻辑地址。这种逻辑地址需要使用地址变换机制将它映射到物理内存地址上。**<font color="red">为了减少确定地址变换所需要的信息，变换或映射通常以内存块作为操作单位</font>**。分段机制和分页机制是两种广泛使用的地址变换技术。

分段和分页操作都使用驻留在内存中的表来指定它们各自的变换信息。这些表只能由操作系统访问，以防止应用程序擅自修改。对于分段来说这个表就是 GDT，通过选择符选择 GDT 中某一个段描述符获取到代码段的基地址，再加上偏移地址就得到要访问的线性地址；对于分页来说这个表就是页目录和页表，通过遍历页目录和页表将线性地址转换为要访问的物理地址。因此，不管是分段还是分页都使用内存块作为单位，有效减少了表中的条目数量。

8086 在从逻辑地址到物理地址变换过程中使用了分段和分页两种机制，如下图所示。第一阶段使用分段机制把程序的逻辑地址变换成线性地址。第二阶段使用分页机制把线性地址转换为物理地址。在地址变换过程中，**第一阶段的分段变换机制总是使用的，而第二阶段的分页机制则是供选用的**。如果没有启用分页机制，那么分段机制产生的线性地址就等于物理地址。

<div align="center">
    <img src="x86-32汇编保护模式_static//24.png" width="550"/>
</div>

>**物理地址空间定义为处理器在其地址总线上能够产生的地址范围**。

### 1.分段机制

分段提供了隔绝各个代码、数据和堆栈区域的机制，因此多个程序 (或任务) 可以运行在同一个处理器上而不会互相干扰。分页机制为虚拟内存系统提供了实现机制，也能实现多任务之间的隔离。分段提供了一种机制，用于把处理器**可寻址的线性地址空间**划分成一些较小的称为段的受保护地址空间区域。段可以用来存放程序的代码、数据和堆栈，或者用来存放系统数据结构 (系统段，如 TSS 或 LDT)。如果处理器中有多个程序在运行，那么每个程序可在 LDT 表中分配各自的一套段。通过这种方式可以确保一个程序不会通过访问另一个程序的段而干扰程序的执行。

**一个系统中所有使用的段都包含在处理器线性地址空间中**。为了定位指定段中的一个字节，程序必须提供一个逻辑地址。逻辑地址包括一个段选择符和一个偏移量。段选择符提供了段描述符表 (如 GDT) 中一个数据结构 (称为段描述符) 的偏移量。每个段都有一个段描述符。段描述符指明段的大小、访问权限和段的特权级、段类型以及段的基地址。**逻辑地址的偏移量部分加到段的基地址上就可以定位段中某字节的位置**。

>如果禁用分页机制，那么线性地址空间就是物理地址空间。

<div align="center">
    <img src="x86-32汇编保护模式_static//25.png" width="600"/>
</div>

### 2.分页机制

因为多任务系统通常定义的线性地址空间都要比其含有的物理内存容量大得多，所以需要使用虚拟存储技术，使用这种技术可让编程人员产生内存空间要比计算机中实际物理内存容量大很多的错觉。大容量的线性地址空间需要使用小块的物理内存 (RAM 或 ROM) 以及某些外部存储空间 (如大容量硬盘) 来模拟。

当使用分页时，每个段被划分成页面 (通常每页为 4KB 大小)，页面会被存储于物理内存中或硬盘上。**操作系统通过维护一个页目录和一些页表来记录这些页面**。当程序访问一个线性地址位置时，处理器就会使用页目录和页表把线性地址转换成一个物理地址，**然后在该内存位置上执行所要求的操作 (读或写)**。如果当前被访问的页面不在物理内存中，处理器就会中断程序的执行 (通过产生一个页错误异常)。然后操作系统就可以从硬盘上把该页面读入物理内存中，**并继续执行刚才被中断的程序**。当实现了分页机制时，那么对于程序来说页面在物理内存和硬盘之间的交换就是透明的。

段变换机制把虚拟地址/逻辑地址变换成线性地址，并且在线性地址空间中访问自己的表，但是并不知晓分页机制把这些线性地址转换到物理地址的过程。类似地，分页机制也不知道程序产生地址的虚拟地址空间。分页机制只是简单地把线性地址转换成物理地址，并且在物理内存中访问自己的转换表。

### 3.保护

8086 支持两类保护。其一是通过给每个任务不同的线性地址空间来完全隔离各个任务，**<font color="red">这是通过给每个任务线性地址到物理地址不同的映射来做到的（每个任务有自己单独的页目录和页表）</font>**。另一个保护机制对任务进行操作，以保护操作系统内存段和处理器特殊系统寄存器不被应用程序访问。

#### 3.1 任务间保护

保护的一个重要方面是提供各任务之间的保护能力。8086 使用的方法是通过把每个任务放置在不同的线性地址空间中，并给予每个任务不同的线性地址到物理地址的映射（即不同的页目录和页表）。每个任务中的地址变换功能被定义成一个任务中的逻辑地址映射到物理内存的一部分区域，而另一个任务中的逻辑地址映射到物理内存中的不同区域中。**这样，因为一个任务不可能映射到其他任务线性地址对应使用的物理内存部分**，所以所有任务都被隔绝开了。

**只需给每个任务各自独立的映射表，每个任务就会有不同的地址变换函数**。在 8086 中，每个任务都有自己的段表和页表。当处理器切换去执行一个新任务时，任务切换的 **<font color="blue">关键部分就是切换到新任务的变换表</font>**。通过在所有任务中安排具有相同的线性到物理地址映射部分，并且把操作系统存储在这个公共的线性地址空间部分，操作系统可以被所有任务共享。这个所有任务都具有的相同线性地址空间部分被称为全局地址空间 (Global Address Space)。

每个任务唯一的线性地址空间部分被称为局部地址空间 (Local Address Space)，含有任务自己私有的数据和代码。由于每个任务中具有不同的局部地址空间，因此两个不同任务中相同的线性地址将转换到不同的物理地址处。**这使得操作系统可以给予每个任务的内存相同的虚拟地址，但仍然能隔绝每个任务**。另一方面，所有任务在全局地址空间中相同的线性地址将被转换到同一个物理地址。

#### 3.2 特权级保护

在一个任务中，定义了 4 个执行特权级 (Privilege Levels)，特权级用数字 0~3 表示，其中 0 具有最高特权级；而 3 则是最低特权级。每个内存段/数据段都与一个特权级相关联，只有具有足够特权级的程序才能访问。我们知道，处理器从 CS 寄存器指定的段中取得和执行指令，**<font color="red">当前特权级 (Current Privilege Level，CPL) 就是当前执行代码段的特权级</font>**。

每当程序企图访问一个段时，当前特权级就会与段的特权级进行比较，以确定是否有访问许可。在给定 CPL 级别上执行的程序允许访问同级别或低级别的数据段，而任何对高特权级数据段的引用都是非法的，并且会引发一个异常来通知操作系统。**每个特权级都有自己的程序栈，以避免使用共享栈带来的保护问题**。当程序从一个特权级切换到另一个特权级上执行时，堆栈段也随之改换到新级别的堆栈中。

## 三、分段机制

通常，每个程序 (或任务) 都使用自己的段描述符表以及自己的段。对程序来说段可以是私有的，或者是程序之间共享的（比如内核提供的公用例程段）。对所有段以及系统上运行程序各自执行环境的访问都由硬件控制。访问检查不仅能够用来保护对段界限以外地址的引用，而且也能用来在某些段中防止执行不允许的操作。例如，因为代码段被设计成只读，因此硬件会防止对代码段执行写操作。段中的访问权限信息也可以用来设置保护环或级别，保护级别可用于保护操作系统程序不受应用程序非法访问。

### 1.段的定义

保护模式 8086 提供了 4GB 物理地址空间，这是处理器在其地址总线上可以寻址的地址空间。这个地址空间是平坦的，地址范围从 0 到 0xFFFFFFFF。分段机制就是把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元。80386 虚拟地址空间中的虚拟地址/逻辑地址由一个段部分和一个偏移部分构成，段是虚拟地址到线性地址转换机制的基础。每个段由以下几个参数定义:

- 段基地址(Base Address)：指定段在线性地址空间中的开始地址，**基地址是线性地址，对应于段中偏移 0 处**；
- 段限长(Limit)：它定义了段的长度；
- 段属性(Attributes)：指定段的特性。例如该段是否可读、可写或可作为一个程序执行，段的特权级等；

段限长定义了在虚拟地址空间中段的大小，**段基址和段限长定义了段所映射的线性地址范围或区域**。**段内 0 到 limit 的地址范围对应线性地址中范围 Base 到 Base+Limit**。另外，若访问一个段并没有得到段属性许可则也会导致异常。例如，如果你试图写一个只读的段，那么 80386 就会产生一个异常。另外，多个段映射到线性地址中的范围可以部分重叠或覆盖，甚至完全重叠。

<div align="center">
    <img src="x86-32汇编保护模式_static//26.png" width="450"/>
</div>

段的基地址、段限长以及段的保护属性存储在一个称为段描述符的结构项中。在逻辑地址到线性地址的转换映射过程中会使用这个段描述符。段描述符保存在内存中的段描述符表中。段描述符表是包含段描述符项的一个简单数组。前面介绍的段选择符即用于通过指定表中一个段描述符的位置来指定相应的段。逻辑地址由 16 位的段选择符和 32 位的偏移量组成，如下图所示。**<font color="red">段选择符指定字节所在的段，而偏移量指定该字节在段中相对于段基地址的位置</font>**。处理器会把每个逻辑地址转换成线性地址。**线性地址是处理器线性地址空间中的 32 位地址。与物理地址空间类似，线性地址空间也是平坦的 4GB 地址空间**，地址范围从 0 到 0xFFFFFFFF。线性地址空间中含有为系统定义的所有段和系统表。

<div align="center">
    <img src="x86-32汇编保护模式_static//27.png" width="550"/>
</div>

为了把逻辑地址转换成一个线性地址,处理器会执行以下操作：

1. 使用段选择符中的偏移值 (段索引) 在 GDT 或 LDT 表中定位相应的段描述符 (**仅当一个新的段选择符加载到段寄存器中时才需要这一步**，否则可以使用段描述符高速缓存)；
2. 利用段描述符检验段的访问权限和范围，以确保该段是可访问的并且偏移量位于段界限内；
3. 把段描述符中取得的段基地址加到偏移量上，最后形成一个线性地址；

如果没有开启分页，**那么处理器直接把线性地址映射到物理地址**，即线性地址被送到处理器地址总线上。如果对线性地址空间进行了分页处理，那么就会使用二级地址转换把线性地址转换成物理地址。

### 2.段描述符表

段描述符表是段描述符的一个数组，如下图所示。描述符表的长度可变，最多可以包含 8192 个 8 字节描述符。有两种描述符表：全局描述符表 GDT(Global Descriptor Table) 和局部描述符表 LDT (Local Descriptor Table)。

<div align="center">
    <img src="x86-32汇编保护模式_static//28.png" width="550"/>
</div>

描述符表结构应该保存在仅由操作系统软件访问的受保护的内存区域中，以防止应用程序修改其中的地址转换信息。虚拟地址空间被分割成大小相等的两半。**<font color="red">一半由 GDT 来映射变换到线性地址（全局空间），另一半则由 LDT 来映射（局部空间）</font>**。

当发生任务切换时，**LDT 会更换成新任务的 LDT**，但是 GDT 并不会改变。因此，**GDT 所映射的一半虚拟地址空间是系统中所有任务共有的**，但是 LDT 所映射的另一半则在任务切换时被改变。系统中所有任务共享的段由 GDT 来映射。这样的段通常包括含有操作系统的段以及所有任务各自的 LDT 段描述符（LDT 段描述符安装在 GDT 中）。但是 LDT 表本身以及其中的任务各个段的信息位于任务自己的局部虚拟地址空间中，具体如下所示：

<div align="center">
    <img src="x86-32汇编保护模式_static//29.png" width="550"/>
</div>

上图表明一个任务中的段如何能在 GDT 和 LDT 之间分开。图中共有 6 个段，分别用于两个应用程序 (A 和 B) 以及操作系统。应用程序 A 拥有 LDTA，用来映射段 CodeA 和 DataA。类似地，应用程序 B 使用 LDTB 来映射 CodeB 和 DataB 段。包含操作系统内核的两个段 Codeos 和 Dataos 使用 GDT 来映射，这样它们可以被两个任务所共享。两个 LDT 段（LDTA 和 LDTB）也使用 GDT 来映射，从图中可以看出，LDTA 和 LDTB 的段描述符安装在 GDT 中。

任务切换时，**<font color="red">每个任务使用不同的 LDT（任务切换伴随着 LDTR 的切换，最终导致使用不同的 LDT）和相同的 GDT，因此每个任务的虚拟地址空间被恰当的组织从而相互隔离</font>**。当任务 A 在运行时，任务 B 的私有段不是虚拟地址空间的部分（LDTR 的切换导致 A 没有方法访问 B 的私有段），因此任务 A 没有办法访问任务 B 的内存。对 B 也是同理。

>GDT 本身并不是一个段，而是线性地址空间中的一个数据结构。$\scriptsize\bold{{GDT 限长=总字节数-1=8n-1}}$，其中 n 为 GDT 中段描述符的个数。

处理器并不使用 GDT 中的第 1 个描述符。把这个"空描述符"的段选择符加载进一个**数据段寄存器 (DS、ES、FS 或 GS)** 并不会产生一个异常，但是若使用这些加载了空描述符的段选择符访问内存时就肯定会产生一般保护性异常。通过使用这个段选择符初始化段寄存器，那么意外引用未使用的段寄存器肯定会产生一个异常。**但是当把空选择符加载到 CS 和 SS 段寄存器中时将会导致一个异常**。

### 3.段选择符

段选择符 (或称段选择子) 是段的一个 16 位标识符，如下图所示。段选择符并不直接指向段，而是指向段描述符表中定义段的段描述符。段选择符的 3 个字段分别是:

- 请求特权级 RPL(Requested Privilege Level)
- 表指示标志 TI(Table Index)
- 索引值 (Index)

<div align="center">
    <img src="x86-32汇编保护模式_static//30.png" width="550"/>
</div>

请求特权级字段 RPL 提供了段保护信息。**表索引字段 TI 用来指出包含指定段描述符的段描述符表 GDT 或 LDT**。TI=0 表示描述符在 GDT 中；TI=1 表示描述符在 LDT 中。索引字段给出了描述符在 GDT 或 LDT 表中的索引项号。可见，选择符通过定位段表中的一个描述符来指定一个段。

对应用程序来说段选择符是作为指针变量的一部分而可见，**但选择符的值通常是由链接编辑器或链接加载程序进行设置或修改，而非应用程序**。段寄存器的结构如下所示：

<div align="center">
    <img src="x86-32汇编保护模式_static//31.png" width="550"/>
</div>

另外，为了避免每次访问内存时都去引用描述符表，每个段寄存器都有一个"可见"部分和一个"隐藏"部分。当一个段选择符被加载到一个段寄存器可见部分中时，处理器也同时把段选择符指向的段描述符中的段地址、段限长以及访问控制信息加载到段寄存器的隐藏部分中，起到一个缓存作用，下次寄存器 (可见和隐藏部分) 中的信息使得处理器可以在进行地址转换时不再需要花费时间从段描述符中读取基地址和限长值。

由于影子寄存器含有描述符信息的一个副本，因此操作系统必须确保对描述符表的改动反映在影子寄存器中。处理这种问题最简捷的方法是在对描述符表中的描述符作过任何改动之后就立刻重新加载 6 个段寄存器。或者说：**_<font color="red">In systems in which multiple processors have access to the same descriptor tables, it is the responsibility of software to reload the segment registers when the descriptor tables are modified.</font>_** 。这将把描述符表中的相应段信息重新加载到影子寄存器中。为加载段寄存器，80386 提供了两类指令：

**1.显示加载指令**

像 MOV、POP、LDS、LES、LSS、LGS 以及 LFS，这些指令显式地直接引用段寄存器。lds、les、lss、lgs 和 lfs 是一类指令，同时给一个段寄存器和一个 16 位通用寄存器同时赋值。其中 lds 同时给 ds 段寄存器和一个16位同样寄存器赋值。比如指令：**`lds reg16, mem32`**，那么，**reg16（比如 ax、bx 等）会获取到 **`[mem32]`** 内存地址处低字（低 2 个字节），而 ds 会获取到 **`[mem32]`** 内存地址处的高字（高 2 个字节）**。les、lss、lgs 和 lfs 指令同理。

```armasm{.line-numbers}
;地址 100h  101h  102h  103h
;内容  00h   41h   02h   03h
LDS AX，[100h]
;结果为 AX=4100h    DS=0302h
```

**2.隐式加载指令**

例如使用长指针的 call、jmp 和 ret 指令、iret、INTn、INTO 和 INT3 等指令。这些指令在操作过程中会附带改变 cs 寄存器 (和某些其他段寄存器) 的内容。

into 指令是用于检查溢出标志（OF）并检测溢出的指令。当 OF 标志被设置为 1（表示有溢出发生），执行 into 指令会引发中断（触发中断 4，INT 4），引发一个溢出异常处理程序；否则，into 的效果就是简单的让程序继续执行。而由于 int n、into 和 int3 这类指令会将程序控制权跳转到中断服务程序，**因此会将新的代码段描述符和程序偏移量加载到 cs 和 eip 寄存器中，从而实现段描述符缓存的更新**。

iret 和 ret 指令分别用于从中断服务程序和子程序返回，**在返回的时候都会从栈中弹出之前保存的 CPU 状态到 cs 和 eip 寄存器**。所以也会隐式加载和更新段寄存器 cs 的内容。

call 用于调用子程序，对于远过程调用，会修改 cs 和 ip 寄存器的值；jmp 指令用于直接跳转，对于远跳转，也会同时修改 cs 和 ip 寄存器的值。以上两条指令都会隐式修改 cs 段寄存器的值。

### 4.段描述符

**段描述符是 GDT 和 LDT 表中的一个数据结构项**，用于向处理器提供有关一个段的位置和大小信息以及访问控制的状态信息。主要含有 3 个主要字段：段基地址、段限长和段属性。段描述符通常由编译器、链接器、加载器或者操作系统来创建，用户程序通常是无法建立和修改 GDT。下图给出了所有类型段描述符的一般格式。

<div align="center">
    <img src="x86-32汇编保护模式_static//32.png" width="600"/>
</div>

#### 4.1 段基址

段基地址可以是 0~4GB 范围内的任意地址，不过，还是建议应当选取那些 16 字节对齐的地址。

#### 4.2 段界限

20 位的段界限用来限制段的扩展范围，因为访问内存的方法是用段基地址加上偏移量，**所以对于向上扩展的段，如代码段和数据段来说，偏移量是从 0 开始递增，段界限决定了偏移量的最大值**；对于向下扩展的段，如栈段来说，**段界限决定了偏移量的最小值**。

#### 4.3 G 字段

G 位是粒度 (Granularity) 位，用于解释段界限的含义。**<font color="red">当 G 位是 "0" 时，段界限以字节为单位</font>**。此时，段的扩展范围是从 1 字节到 1 兆字节 (1B~1MB)，因为描述符中的界限值是 20 位的。相反，**<font color="red">如果该位是 1，那么，段界限是以 4KB 为单位的</font>**。这样，段的扩展范围是从 4KB 到 4GB。

#### 4.4 S 字段

S 位用于指定描述符的类型 (Descriptor Type)。当该位是 0 时，表示是一个系统段；为 1 时，表示是一个代码段或者数据段(栈段也是特殊的数据段)。

#### 4.5 DPL 字段

DPL 表示描述符的特权级 (Descriptor Privilege Level,DPL)。这两位用于指定段的特权级。共有 4 种处理器支持的特权级别，分别是 0、1、2、3，其中 0 是最高特权级别，3 是最低特权级别。**刚进入保护模式时执行的代码具有最高特权级 0 (可以看成是从处理器那里继承来的)，这些代码通常都是操作系统代码，因此它的特权级别最高**。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如 3 特权级。有些处理器指令(特权指令)只能由 0 特权级的程序来执行。

#### 4.6 P 字段

P 是段存在位 (Segment Present)。**P 位用于指示描述符所对应的段在内存中是否存在**。一般来说，描述符所指示的段都位于内存中。但是当内存空间紧张时，有可能只是建立了描述符，而其对应的内存空间（数据段和代码段）并不存在，这时，就应当把描述符的 P 位置 0。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，这时同样要把段描述符的 P 位清零。当再次轮到它执行时，再装入内存，然后将 P 位置 1。

#### 4.7 D/B 字段

D/B 位是默认的操作数大小 (Default Operation Size) 或者默认的栈指针大小 (Default Stack Pointer Size)。设立该标志位，主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序。

对于代码段，此位称做 D 位，用于指示指令中默认的偏移地址和操作数尺寸。D=0 表示指令中的偏移地址或者操作数是 16 位的，处理器执行时使用 16 位的指令指针寄存器 IP 来取指令；D=1 指示 32 位的偏移地址或者操作数，处理器使用 32 位的 EIP 寄存器来取指令。

对于栈段来说，该位被叫做 B 位，**用于在进行隐式的栈操作时，指定使用 sp 还是 esp 寄存器**。隐式的栈操作指令包括 push、pop 和 call 等。如果该位是 0，在访问那个段时，使用 sp 寄存器，否则就是使用 esp 寄存器。同时，B 位的值也决定了栈的上部边界。如果 B=0，**<font color="red">那么栈段的上部边界 (也就是 SP 寄存器的最大值) 为 0xFFFF；如果 B=1，那么栈段的上部边界 (也就是 ESP 寄存器的最大值) 为 0xFFFFFFFF</font>**。

#### 4.8 L 字段

L 位是 64 位代码段标志 (64-bit Code Segment)，保留此位给 64 位处理器使用。

#### 4.9 TYPE 字段

TYPE 字段共 4 位，用于指示描述符的类别。如下表所示，对于数据段来说，这 4 位分别是 X、E、W、A 位；而对于代码段来说，这 4 位则分别是 X、C、R、A 位。

<div align="center">
    <img src="x86-32汇编保护模式_static//33.png" width="580"/>
</div>

X 表示是否可以执行 (eXecutable)，数据段总是不可执行的，X=0；代码段总是可以执行的，因此 X=1。

对于数据段来说，E 位指示段的扩展方向。**E=0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段；E=1 是向下扩展的，也就是向低地址方向扩展的，通常是栈段**。W 位指示段的读写属性，W=0 的段是不允许写入的，否则会引发处理器异常中断；W=1 的段是可以正常写入的。

对于代码段来说，C 位指示段是否为特权级依从的 (Conforming)。C=0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用访问更高特权级的代码段；C=1 表示允许从低特权级的程序转移到该段执行，并且执行时保持调用者的特权级，而不需要转移到代码段自身的特权级。

R 位指示代码段是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能由 R 位指定。R=0 表示不能读出，如果企图去读一个 R=0 的代码段，会引发处理器异常中断；如果 R=1，则代码段是可以读出的

>**这里的 R 属性并非用来限制处理器，而是用来限制其它程序和指令的行为**。一个典型的例子是使用段超越前缀 "CS:" 来访问代码段中的内容。

数据段和代码段的 A 位是已访问 (Accessed) 位，**用于指示它所指向的段最近是否被访问过**。在描述符创建的时候应该清零。之后，每当该段被访问时，处理器自动将该位置 1。对该位的清零是由软件 (操作系统) 负责的，**通过定期监视该位的状态，就可以统计出该段的使用频率**。当内存空间紧张时，可以把不经常使用的段退避到硬盘上，从而实现虚拟内存管理。

## 四、地址变换时的保护

### 1.栈操作时的保护

You may be used to thinking in terms of Expand Up data segments only because they are the default type for both code and data segments. In fact, there isn't even a corresponding concept to Expand Down for code segments. As you are already aware, for code and Expand Up data segments, **<font color="red">_the base address is the linear address, and the limit is the length minus one_</font>**.

Expand Down segments, in a sense, switch those and many other concepts you have always taken for granted. For example, were you to toggle the Expand Down bit in a Descriptor Table Entry (DTE), and leave the Base Address and Limit the same, then all offsets which were valid before, become invalid and vice versa.

<div align="center">
    <div align="center" style="color: #000; font-size:13px; font-weight:bold">相同区域向上扩展和向下扩展段描述符属性计算表格</div>
    <img src="x86-32汇编保护模式_static//34.png" width="350"/>
</div>

The following table points out some of the differences between the two types of segments where **<font color="red">_the same area of memory is mapped as an Expand Up and Expand Down segment for a given Linear Address (LA) and Segment Length (Length)_</font>**.

Sometimes the arithmetic is dependent upon the B (Big) bit in the DTE. This bit controls several aspects of how the CPU interprets the Base, Limit, and Valid Offsets of a selector. As you can see from the table above, the B bit has a huge effect on how Expand Down segments are described and no effect on Expand Up segments. **Because the arithmetic is done modulo either 64KB (for B=0) or 4GB (for B=1), we define the Modulus to be 64KB for B=0, and 4GB for B=1**.

The two GDT/LDT rows indicate how to set the corresponding entries in those tables. The rows labeled Smallest and Largest Offsets indicate what indices can be used to address data within the segment.

Thus, if two DTEs were setup as per the GDT/LDT rows in the above table, **the same area of memory would be addressed（寻址）**. The only difference would be in the offsets used to reference the memory. Using the Expand Up selector, the first byte would be addressed as offset zero; using the Expand Down selector, it would be addressed as offset Modulus - Length.

下面举例详细说明上述计算方式，栈段一般是使用向下扩展的内存段，段界限的检查和向上扩展的数据段和代码段不同。当然，栈也可以使用向上扩展的段，即，把数据段用做栈段。在这种情况下，对段界限的检查按数据段的规则进行。但是无论如何，**栈本身始终总是向下增长的，即向低地址方向推进。段的扩展方向用于处理器的界限检查，而对栈的性质以及在栈上进行的操作没有关系**。

现在只讨论 32 位的栈段，即其描述符 B 位是 1 的栈段。处理器在这样的段上执行压栈和出栈操作时，**默认使用 ESP 寄存器（最大值为 0xFFFFFFFF）**。在栈段中，实际使用的段界限也和粒度 (G) 位相关，如果 G=0，实际使用的段界限就是描述符中记载的段界限；如果 G=1，则实际使用的段界限为：

```armasm{.line-numbers}
(描述符中的段界限 + 1) * 0x1000 - 1 = 描述符中的段界限 * 0x1000 + 0xFFF
```

现在定义一个堆栈段，其最低有效地址为 0x00006C00，最高有效地址为 0x00007BFF。可以采用之前计算表格中的公式。如果是向上扩展的栈段（E=0），那么其段描述符的属性如下所示：

```armasm{.line-numbers}
Base=0x6c00
Limit=0x1000-1=0xFFF
Smallest Offset=0
Largest Offset=0x1000-1=0xFFF
Initial ESP=0x1000
```

对于此栈段，其 esp 初始化为 limit+1，在进行栈操作时必须满足以下原则：

```armasm{.line-numbers}
0（Smallest Offset）<= esp - 操作数的长度 <= 0xFFF（Largest Offset）
;栈指针寄存器 ESP 只在访问栈时提供偏移地址，操作数在压入栈时的物理地址要用段基址 base 和 esp 的内容相加得到
0x6C00 <= esp - 操作数的长度 + Base <= 0x7BFF
```

如果是向下扩展的栈段（E=1），则此栈段的 Modulus=4GB=0x10000 0000，那么其段描述符的属性如下所示，在实际创建一个地址范围为 0x6C00~0x7BFF 的向下扩展的栈时，可以将下面计算出来的 base 和 limit 属性填写到栈段的描述符属性中。

```armasm{.line-numbers}
Base=0x6c00+0x1000-0x10000 0000=0x7c00
;Limit=0x10000 0000-1-0x1000=0xFFFF EFFF
;根据前面 G=1 时计算段的实际界限的公式，反推描述符中的段界限为：
Limit=(0xFFFF EFFF-0xFFF) / 0x1000=0xFFFFE
Smallest Offset=0x1000 00000-0x1000=0xFFFF F000
Largest Offset=0x10000 0000-1=0xFFFF FFFF
Initial ESP=0
```

对于此栈段，其 esp 初始化为 0，在进行栈操作时必须满足以下原则：

```armasm{.line-numbers}
0xFFFF F000（Smallest Offset）<= esp - 操作数的长度 <= 0xFFFF FFFF（Largest Offset）
;栈指针寄存器 ESP 只在访问栈时提供偏移地址，操作数在压入栈时的物理地址要用段基址 base 和 esp 的内容相加得到
0x6C00 <= esp - 操作数的长度 + Base <= 0x7BFF
```

向上扩展的栈段和向下扩展的栈段描述符的属性差异如下图所示，这两者的区别为：**_<font color="red">basically, the difference between expand-up and expand-down, is whether the base is the top or bottom of the segment</font>_**，向下扩展的栈，base 指向栈段的最低端，而向上扩展的栈，base 指向其最高端。根据 OSDev wiki，The Expand Down flag for a 32-bit Segment makes the Base actually the **_top_** of the accessed memory, and the **`Limit+Base+1`** becomes the lowest possible offset you can access below that.This is slightly incorrect since the CPU is still adding the offset to the Base - but since the offset is so large it's effectively negative, resulting in a smaller final address.

<div align="center">
    <img src="x86-32汇编保护模式_static//35.png" width="530"/>
</div>

对于向上扩展的栈比较好理解，esp 初始值为 0x1000，其变化范围为 **`0~0xFFF`**，从栈段的最高端向下扩展。对于向下扩展的栈，esp 的初始值为 0，其变化范围为 **`0xFFFF F000~0xFFFF FFFF`**，**此时 esp 的值可以看成是负数**，和 base 相加的结果（base 指向栈段的最高端）变相减小了 base 的值，使得 base+esp 的值不断向低地址端移动。

下面再讨论《任务和特权级保护》中的一个例子，以其中创建 0 特权级栈的代码为例，每个特权级栈的大小为 4KB，并且均为向下扩展的栈。对于此种类型的栈如前所述，段描述符的 base 属性指向栈段的高端，因此在通过 **`allocate_memory`** 得到分配内存的基地址（最低地址）后需加上 4096，最后回写到段描述符中，这里假设为 0x8800。

又因为栈段的大小位 4KB，因此实际使用的段界限为 **`0x10000 0000-1-0x1000=0xFFFF EFFF`**，填写到段描述符中的界限为 **`0xFFFFE`**。esp 的最低和最大偏移量分别为 **`0xFFFF F000`** 和 **`0xFFFF FFFF`**，这里 esp 同样可以看成为负数，和 base 相加得到低端有效物理地址（0x7800）和高端有效物理地址（0x87FF）之间的差为 0x1000，即 4KB。最后登记 esp 的初始值（0）到 TCB 中保存。

```armasm{.line-numbers}
;🫕创建 0-2 特权级堆栈，每个特权级堆栈的大小为 4KB🫕
;创建 0 特权级堆栈
mov ecx,4096
;为生成堆栈高端地址做准备
mov eax,ecx

mov [es:esi+0x1a],ecx
;登记 0 特权级堆栈尺寸到 TCB，由于尺寸是以 4KB 为单位，所以需要将先前保存的尺寸大小逻辑右移 12 位，除以 4096
shr dword [es:esi+0x1a],12
call sys_routine_seg_sel:allocate_memory
;堆栈必须使用高端地址为基地址
add eax,ecx
;登记 0 特权级堆栈基地址到 TCB
mov [es:esi+0x1e],eax
;0 特权级堆栈段界限
mov ebx,0xffffe
;4KB 粒度，读写堆栈段，DPL 特权级 0，向下扩展
mov ecx,0x00c09600
call sys_routine_seg_sel:make_seg_descriptor
mov ebx,esi
;安装生成的 0 特权级堆栈描述符到 LDT 中
call fill_descriptor_in_ldt
;设置选择子的 RPL 特权级为 0，由于上面过程返回的选择子 RPL 本身为 0，因此下面这条指令是作为注释存在的
;or cx,0000_0000_0000_0000
;登记 0 特权级堆栈选择子到 TCB
mov [es:esi+0x22],cx
;登记 0 特权级堆栈初始 ESP 到 TCB
mov dword [es:esi+0x24],0
```

至于引入向下扩展的栈段的目的，即：With normal segments limit controls what the highest valid address in the segment is, but with the expansion-direction flag set it determines the **lower valid address**. The base address becomes the **upper limit of the physical memory** you can access through the segment instead of the lower limit.**<font color="red">This means that lowering the limit will increase the space in an expand-down segment, adding extra addressable memory to the bottom of the segment</font>**. 在段描述符中的段界限 limit 值减小后，base+limit 的值相较于之前更靠近低地址处，从而使得最低有效物理地址和最高有效物理地之间的地址范围扩大，变相为栈段分配了内存空间。

根据默认栈指针大小标志 B 的设置，偏移值范围可从段限长 Limit 到 0xFFFFFFFF 或 0xFFFF。而小于段限长 Limit 的偏移值将产生一般保护性异常。对于下扩段，减小段限长字段中的值会在该段地址空间底部分配新的内存，而不是在顶部分配。8086 的栈总是向下扩展的，因此这种实现方式很适合扩展堆栈段。