# 目标文件 

**编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有符号或者某些地址还没有被调整**。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。

## 1.目标文件的格式

现在 PC 平台流行的可执行文件格式（Executable）主要是 Windows 下的 PE（Portable Executable）和 Linux 的 ELF（Executable Linkable Format），它们都是 COFF（Common file format）格式的变种。**<font color="red">目标文件就是源代码编译后但未进行链接的那些中间文件（Windows 的 **`.obj`** 和 Linux 下的 **`.o`**）</font>**。它跟可执行文件的内容与结构相似，所以一般跟可执行文件格式一起采用一种格式来存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是一类类型的文件。在 Windows 下，我们可以统称它们为 PE-COFF 文件格式。在 Linux 下，我们可以将它们统称为 ELF 文件。

不光是可执行文件（Windows 的 **`.exe`** 和 Linux 下的 ELF 可执行文件）按照可执行文件格式来存储。**<font color="red">动态链接库（DLL，Dynamic Linking Library）（Windows 的 `.dll` 和 Linux 的 `.so`）及静态链接库（Static Linking Library）（Windows 的 `.lib` 和 Linux 的 `.a`）文件都按照可执行文件格式存储</font>**。它们在 Windows 下都按照 PE-COFF 格式存储，Linux 下按照 ELF 格式存储。

>静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单地把它理解为一个包含有很多目标文件的文件包。

ELF 文件标准中把系统重采用的 ELF 格式文件分为如下 4 类：

- 可重定位文件（Relocatable File）：这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，**静态链接库也可以归为这一类**。比如 Linux 的 **`.o/.a`**  和 Windows 的 **`.obj`** 文件；
- 可执行文件 (Executable File)：这类文件包含了可以直接执行的程序，它的代表就是 ELF 可执行文件。它们一般都没有扩展名。比如 **`/bin/bash`** 文件，Windows 的 **`.exe`**；
- 共享目标文件 (Shared Object File)：这类文件包含了代码和数据，可以在以下两种情况下使用。**一种是链接器可以使用这类文件和其他的可重定位文件和共享目标文件进行链接，产生新的共享目标文件或可执行文件**。另一种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。比如 Linux 的 **`.so`**，如 **`/lib/glibc-2.5.so`**、Windows 的 DLL；
- 核心转储文件 (Core Dump File)：当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到这类转储文件中。Linux 下的 core dump。

我们可以在 Linux 下使用 file 命令来查看相应的文件格式，上面几种文件在 file 命令下会显示出相应的类型：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ file a.o
a.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
monica@monica-virtual-machine:~/linkers_loaders$ file /bin/bash
/bin/bash: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=7a6408ba82a2d86dd98f1f75ac8edcb695f6fd60, for GNU/Linux 3.2.0, stripped
monica@monica-virtual-machine:~/linkers_loaders$ file file1.so 
file1.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, BuildID[sha1]=535dabcb55ddf5ccf8f9a49df35559849d15ddb5, not stripped
```

这里对 **<font color="red">一种是链接器可以使用这类文件和其他的可重定位文件和共享目标文件进行链接，产生新的共享目标文件或可执行文件</font>** 这句话进行解释，链接器的核心任务是将一个或多个输入文件（可重定位文件 **`.o`**、静态库 **`.a`**、共享库 **`.so`**）合并，解析它们之间的符号引用以及重定位，并生成一个最终的输出文件。这个输出文件主要有两种类型：

**（1）生成可执行文件**

```shell{.line-numbers}
# 完整步骤分解
# 1. 编译 (Compilation): 从 main.c 生成可重定位目标文件 main.o
gcc -c main.c -o main.o
# 2. 链接 (Linking): 将 main.o 与共享库 libmath.so 链接，生成可执行文件 my_app
gcc main.o -o my_app -lmath 
# 快捷方式 (编译和链接一步完成)
gcc main.c -o my_app -lmath
```

在这个场景下，链接器 ld（由 gcc 调用）的输入是 **`main.o`** 和 **`libmath.so`**，输出是一个可执行文件 my_app。

**（2）生成共享目标文件**

```shell{.line-numbers}
# 假设我们正在开发一个名为 libmycomplex.so 的库
# 它由 part1.c 和 part2.c 组成，并且它自身还依赖于数学库

# 1. 编译: 分别生成两个可重定位目标文件
gcc -c -fPIC part1.c -o part1.o
gcc -c -fPIC part2.c -o part2.o

# 2. 链接: 将 part1.o, part2.o 与 libmath.so 链接，
#    生成一个新的共享目标文件 libmycomplex.so
gcc -shared -o libmycomplex.so part1.o part2.o -lmath
```

在这个场景下，链接器的输入是 **`part1.o`**、**`part2.o`** 和 **`libmath.so`**，输出是一个新的共享目标文件 **`libmycomplex.so`**，供更高层次的模块链接使用。

>**`-fPIC`** 选项作用于编译阶段，告诉编译器产生与位置无关代码；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置。另外，如果想创建一个动态链接库，可以使用 GCC 的 **`-shared`** 选项。输入文件可以是源文件、汇编文件或者目标文件。

## 2.目标文件是什么样的

目标文件中除了机器指令和数据外，还包括了链接时所需的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以"节"（Section）的形式存储（链接视图），有时候也叫"段"（Segment）（加载视图），默认情况下统一将它们称为"段"。

程序源代码编译后的机器指令经常被放在代码段（Code Section）里，代码段常见的名字有 **`.code`** 或 **`.text`**；全局变量和局部静态变量数据经常放在数据段（Data Section），数据段的一般名字都叫 **`.data`**。

<div align="center">
    <img src="目标文件_static//1.png" width="200"/>
</div>

从图中可以看到，ELF 文件的开头是一个"文件头"，**它描述了整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息**。文件头还包括一个段表（Section Table），段表其实是一个描述文件中各个段的数据。段表描述了文件中每个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息。

对照上图来看，一般 C 语言的编译后执行语句都编译成机器代码，保存在 **`.text`** 段；已初始化的全局变量和静态变量都保存在 **`.data`** 段；未初始化的全局变量和静态变量一般放在一个叫 **`.bss`** 的段里。我们知道未初始化的全局变量和静态变量默认值都是 0，本来它们也可以放在 **`.data`** 段的，但是因为它们都是 0，所以为它们在 **`.data`** 段中分配空间并且存放数据 0 是没有必要的。

程序运行的时候它们的确是要占内存空间的，并且可执行文件必须记录所有未初始化的全局变量和静态变量的大小总和，记为 **`.bss`** 段。**<font color="red">所以 **`.bss`** 段只是为未初始化的全局变量和静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间</font>**。

假设有如下函数：

```c{.line-numbers}
// SimpleSection.c
int printf(const char* format, ...);

extern int akk;
int global_init_var = 84;
int global_uninit_var;
static int global_static_var = 22;
static int global_unist_static_var;

void func() {
	static int foo = 2;
	printf("%d\n", foo);
}

int main(void) {
 	static int static_var1 = 85;
 	static int static_var2;
 	
 	printf("%d\n", static_var1);
 	return a;
}
```

我们使用 gcc 来编译这个文件 **`gcc -c SimpleSection.c`**（参数 **`-c`** 表示只编译不链接）。然后使用 **`objdump -h`** 来显示这个目标文件的内部结构如下所示，**`-h`** 选项（或 **`--section-headers`**）用于显示目标文件的节头（Section Headers）摘要信息，这些信息描述了二进制文件中各个节（Section）的基本属性。

其中 **`Size`** 表示这节的大小，VMA 表示虚拟内存地址（程序运行时该节的内存地址），LMA 表示加载内存地址（通常与 VMA 相同），File off 表示该节在文件中的偏移量，Align 表示对齐方式（2**4 表示 16 字节对齐）。

```c{.line-numbers}
SimpleSection.o：     文件格式 elf32-i386

节：
Idx Name                        Size      VMA       LMA       File off  Algn
  0 .group                      00000008  00000000  00000000  00000034  2**2
                                CONTENTS, READONLY, GROUP, LINK_ONCE_DISCARD
  1 .text                       00000075  00000000  00000000  0000003c  2**0
                                CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  2 .data                       00000010  00000000  00000000  000000b4  2**2
                                CONTENTS, ALLOC, LOAD, DATA
  3 .bss                        0000000c  00000000  00000000  000000c4  2**2
                                ALLOC
  4 .rodata                     00000004  00000000  00000000  000000c4  2**0
                                CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .text.__x86.get_pc_thunk.ax 00000004  00000000  00000000  000000c8  2**0
                                CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .comment                    0000002c  00000000  00000000  000000cc  2**0
                                CONTENTS, READONLY
  7 .note.GNU-stack             00000000  00000000  00000000  000000f8  2**0
                                CONTENTS, READONLY
  8 .eh_frame                   00000084  00000000  00000000  000000f8  2**2
                                CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

从上面的结果可以看出，LMA 和 VMA 的结果为 0，这是因为在 **`.o`** 文件中，也就是在最终链接和装载之前，没有固定的运行地址（VMA）和装载地址（LMA），objdump 就以 0 占位。**`SimpleSection.o`** 中除了最基本的代码段、数据段和 BSS 段以外，还有 3 个段，分别为只读数据段（**`.rodata`**）、释信息段 (**`.comment`**) 和堆栈提示段 (**`.note.GNU-stack`**)。

同时上述节（section）具有一组属性标志：

- **`CONTENTS`**：表示该节包含实际的数据内容，带有 **`CONTENTS`** 标志的节在目标文件中有实际的数据，而不仅仅是占位符或符号信息。
- **`ALLOC`**：表示该节需要在内存中分配空间。带有 **`ALLOC`** 标志的节在程序加载时会被映射到进程的虚拟地址空间中。
- **`LOAD`**：表示该节需要被加载到内存中。带有 **`LOAD`** 标志的节在程序加载时会被加载到内存中。
- **`RELOC`**：表示该节中的内容可能需要在链接阶段进行重定位。具体地址在链接阶段由链接器决定。
- **`READONLY`**：表示该节的内容在程序运行期间不可修改。

并且从上面可以看出，已初始化的全局和静态变量有 4 个整形变量，因此 **`.data`** 段的大小是 16 字节（0x10）。未初始化的全局和静态变量有 3 个整形变量，因此 **`.bss`** 段的大小是 12 字节（0xc），并且 **`.bss`** 段和后面 **`.rodata`** 段的起始地址相同，说明 **`.bss`** 段在 ELF 文件中不占据空间。

有一个专门的命令叫做 "size"，可以用来查看 ELF 文件中代码段、数据段和 BSS 段的长度：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ size SimpleSection.o
   text	   data	    bss	    dec	    hex	filename
    257	     16	     12	    285	    11d	SimpleSection.o
```

### 2.1 代码段

objdump 的 **`-s`** 参数可以将所有段的内容以十六进制的方式打印出来。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ objdump -s SimpleSection.o

SimpleSection.o：     文件格式 elf32-i386

Contents of section .group:
 0000 01000000 07000000                    ........        
Contents of section .text:
 0000 5589e553 83ec04e8 fcffffff 05010000  U..S............
 0010 008b9008 00000083 ec08528d 90000000  ..........R.....
 0020 005289c3 e8fcffff ff83c410 908b5dfc  .R............].
 0030 c9c38d4c 240483e4 f0ff71fc 5589e553  ...L$.....q.U..S
 0040 51e8fcff ffff0501 0000008b 900c0000  Q...............
 0050 0083ec08 528d9000 00000052 89c3e8fc  ....R......R....
 0060 ffffff83 c410b800 0000008d 65f8595b  ............e.Y[
 0070 5d8d61fc c3                          ].a..           
Contents of section .data:
 0000 54000000 16000000 02000000 55000000  T...........U...
Contents of section .rodata:
 0000 25640a00                             %d..            
Contents of section .text.__x86.get_pc_thunk.ax:
 0000 8b0424c3                             ..$.            
Contents of section .comment:
 0000 00474343 3a202855 62756e74 75203131  .GCC: (Ubuntu 11
 0010 2e342e30 2d317562 756e7475 317e3232  .4.0-1ubuntu1~22
 0020 2e303429 2031312e 342e3000           .04) 11.4.0.    
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 017c0801  .........zR..|..
 0010 1b0c0404 88010000 20000000 1c000000  ........ .......
 0020 00000000 32000000 00410e08 8502420d  ....2....A....B.
 0030 05448303 6ac5c30c 04040000 30000000  .D..j.......0...
 0040 40000000 32000000 43000000 00440c01  @...2...C....D..
 0050 00491005 02750042 0f037578 06100302  .I...u.B..ux....
 0060 757c6ec1 0c010041 c341c543 0c040400  u|n....A.A.C....
 0070 10000000 74000000 00000000 04000000  ....t...........
 0080 00000000                             .... 
```

**`-d`** 参数可以将所有包含指令的段反汇编。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ objdump -d SimpleSection.o
SimpleSection.o：     文件格式 elf32-i386

Disassembly of section .text:

00000000 <func>:
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	53                   	push   %ebx
   4:	83 ec 04             	sub    $0x4,%esp
   7:	e8 fc ff ff ff       	call   8 <func+0x8>
   c:	05 01 00 00 00       	add    $0x1,%eax
  11:	8b 90 08 00 00 00    	mov    0x8(%eax),%edx
  17:	83 ec 08             	sub    $0x8,%esp
  1a:	52                   	push   %edx
  1b:	8d 90 00 00 00 00    	lea    0x0(%eax),%edx
  21:	52                   	push   %edx
  22:	89 c3                	mov    %eax,%ebx
  24:	e8 fc ff ff ff       	call   25 <func+0x25>
  29:	83 c4 10             	add    $0x10,%esp
  2c:	90                   	nop
  2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  30:	c9                   	leave  
  31:	c3                   	ret    

00000032 <main>:
  32:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  36:	83 e4 f0             	and    $0xfffffff0,%esp
  39:	ff 71 fc             	push   -0x4(%ecx)
  3c:	55                   	push   %ebp
  3d:	89 e5                	mov    %esp,%ebp
  3f:	53                   	push   %ebx
  40:	51                   	push   %ecx
  41:	e8 fc ff ff ff       	call   42 <main+0x10>
  46:	05 01 00 00 00       	add    $0x1,%eax
  4b:	8b 90 0c 00 00 00    	mov    0xc(%eax),%edx
  51:	83 ec 08             	sub    $0x8,%esp
  54:	52                   	push   %edx
  55:	8d 90 00 00 00 00    	lea    0x0(%eax),%edx
  5b:	52                   	push   %edx
  5c:	89 c3                	mov    %eax,%ebx
  5e:	e8 fc ff ff ff       	call   5f <main+0x2d>
  63:	83 c4 10             	add    $0x10,%esp
  66:	b8 00 00 00 00       	mov    $0x0,%eax
  6b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  6e:	59                   	pop    %ecx
  6f:	5b                   	pop    %ebx
  70:	5d                   	pop    %ebp
  71:	8d 61 fc             	lea    -0x4(%ecx),%esp
  74:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

00000000 <__x86.get_pc_thunk.ax>:
   0:	8b 04 24             	mov    (%esp),%eax
   3:	c3                   	ret 
```

### 2.2 数据段

**`.data`** 段保存的是已经初始化了的全局变量和静态变量，SimpleSection.c 里面我们在调用 printf 的时候，用到了一个字符串常量 **`%d\n`**，它是一种只读数据，所以它被放到了 **`.rodata`** 段，我们可以从输出结果看到 **`.rodata`** 这个段的 4 个字节刚好是这个字符串常量的 ASCII 字节序，最后以 **`\0`** 结束。**`.rodata`** 段存放的是只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量。设置只读数据段，操作系统在加载的时候可以将 **`.rodata`** 段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。 

### 2.3 **`.bss`** 段

**`.bss`** 段存放的是未初始化的全局变量和静态变量，GCC 10 及以上默认启用 **`-fno-common`**，从 Clang 11 及以上默认启用 **`-fno-common`**。但是在其他编译器版本中（默认启用 **`-fcommon`** 选项），未初始化的全局变量默认是放在 COMMON 块中。默认启用 **`-fno-common`** 时，**`.bss`** 节的大小为 12 字节。

```c{.line-numbers}
  3 .bss                        0000000c  00000000  00000000  000000c4  2**2
                                ALLOC
```

COMMON 符号指的是一类特殊的全局符号，用于表示未初始化的全局变量（又称可共同定义的符号）。在早期的编程语言（如 FORTRAN）中，有一个概念叫做 COMMON 块，允许在多个源文件中声明同名的公共变量块，链接器在链接时为这些变量分配一个共同的内存区域。

这一特性后来被引入 C 语言的编译/链接模型中，使得 C 语言允许 tentative definition（暂定定义）：**<font color="red">即可以在不同的源文件中多次定义同名的未初始化全局变量而不报重定义错误，链接器会将它们合并为一个符号并只分配一块内存空间</font>**。GCC 和 Clang 在 C 语言中历史上默认开启 **`-fcommon`** 选项来启用这种语义。

需要强调的是，**COMMON 符号只存在于可重定位目标文件（.o 文件）中。在最终链接生成的可执行文件或共享库中，不会有节索引为 COMMON 的符号**。这是因为链接器在产生最终文件时，会为所有 COMMON 符号分配空间，将它们放入合适的段中（通常是 **`.bss/.data`** 段）。因此，在最终可执行文件的符号表中，这些符号将不再是 COMMON 类型，而是变成已分配到 **`.bss/.data`** 的全局符号。

使用 **`gcc -c SimpleSection.c -m32 -fcommon`** 开启 COMMON 选项时，**`.bss`** 节的大小变为 8 字节。可以看到，global_uninit_var 变量被放在 COMMON 块中。

```c{.line-numbers}
  3 .bss          00000008  00000000  00000000  000000c4  2**2
                  ALLOC
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s SimpleSection.o

Symbol table '.symtab' contains 18 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
    12: 00000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var
```

>注意，对于声明 **`static int global_static_var = 0`**，变量 **`global_static_var`** 依然被视为未被初始化，被放在 **`.bss`** 段中。

### 2.4 自定义段

正常情况下，GCC 编译出来的目标文件中，代码会被放到 **`.text`** 段，全局变量和静态变量会被放到 **`.data`** 和 **`.bss`** 段，正如我们前面所分析的。但是有时候你可能希望变量或某些部分代码能够放到你所指定的段中去，以实现某些特定的功能。

```c{.line-numbers}
__attribute__((section("FOO"))) int global = 42;
__attribute__((section("BAR"))) void foo() {
}
```

我们在全局变量或函数之前加上 **`__attribute__((section("name")))`** 属性就可以把相应的变量或函数放到以 name 作为段名的段中。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ objdump -h SimpleSection.o

SimpleSection.o：     文件格式 elf32-i386

  4 FOO           00000004  00000000  00000000  000000c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 BAR           00000010  00000000  00000000  000000c4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
```

## 3.ELF 文件结构描述

### 3.1 文件头

ELF 目标文件格式的最前部是 ELF 文件头（ELF Header），它包含了描述整个文件的基本属性，比如 ELF 文件版本、目标机器型号、程序入口地址等。 紧接着是 ELF 文件各个段。其中 ELF 文件中与段有关的重要结构就是段表（Section Header Table），该表描述了 ELF 文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -h SimpleSection.o
ELF 头：
  Magic：   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              REL (可重定位文件)
  系统架构:                          Intel 80386
  版本:                              0x1
  入口点地址：                        0x0
  程序头起点：                        0 (bytes into file)
  Start of section headers:          1236 (bytes into file)
  标志：                              0x0
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           40 (bytes)
  Number of section headers:         18
  Section header string table index: 17
```

在上面的结果中，**start of section headers** 表示段表在文件中的起始地址，**size of this header** 表示本文件 ELF 头的大小，**size of section headers** 表示段表中每一个段的大小，**number of section headers** 表示段表中段的个数，**section header string table index** 表示字符串表在段表中的索引，**size of program headers** 表示程序头表中每一个条目的大小，**number of program headers** 表示程序头表中条目的数量。**<font color="red">在重定位文件中没有程序头表</font>**。

从上面输出的结果可以看到，ELF 的文件头中定义了 ELF 魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI 版本、ELF 重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。这些数值中有关描述 ELF 目标平台的部分，与我们常见的 32 位 Intel 的硬件平台基本上一样。

ELF 文件头结构及相关常数被定义在 **`/usr/include/elf.h`** 里，因为 ELF 文件在各种平台下都通用，ELF 文件有 32 位版本和 64 位版本。它的文件头结构也有这两种版本，分别叫做 **`Elf32_Ehdr`** 和 **`Elf64_Ehdr`**。32 位版本与 64 位版本的 ELF 文件的文件头内容是一样的，只不过有些成员的大小不一样。

```c{.line-numbers}
#define EI_NIDENT       16
 
typedef struct {
    // Magic 魔数、ELF 类别、数据存储方式、版本、ABI 版本
    unsigned char   e_ident[EI_NIDENT]; 
    // ELF 文件类型
    Elf32_Half      e_type;
    // ELF 文件的 CPU 平台属性，相关常量以 EM_ 开头
    Elf32_Half      e_machine;
    // ELF 版本号，一般为常数 1
    Elf32_Word      e_version;
    // 入口地址，规定 ELF 程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令，
    // 可重定位文件一般没有入口地址，则这个值为 0
    Elf32_Addr      e_entry;
    // 程序头表在文件中的偏移
    Elf32_Off       e_phoff;
    // 段表在文件中的偏移
    Elf32_Off       e_shoff;
    Elf32_Word      e_flags;
    // ELF 文件头本身的大小，一般为 52（0x34）字节
    Elf32_Half      e_ehsize;
    // 程序头表描述符的大小
    Elf32_Half      e_phentsize;
    // 程序头表中描述符的数量
    Elf32_Half      e_phnum;
    // 段表描述符的大小
    Elf32_Half      e_shentsize;
    // 段表描述符的数量，这个值等于 ELF 文件中拥有的段的数量
    Elf32_Half      e_shnum;
    // 段表字符串表所在的段在段表中的下标
    Elf32_Half      e_shstrndx;
} Elf32_Ehdr;

typedef struct {
    unsigned char   e_ident[EI_NIDENT]; 
    Elf64_Half      e_type;
    Elf64_Half      e_machine;
    Elf64_Word      e_version;
    Elf64_Addr      e_entry;
    Elf64_Off       e_phoff;
    Elf64_Off       e_shoff;
    Elf64_Word      e_flags;
    Elf64_Half      e_ehsize;
    Elf64_Half      e_phentsize;
    Elf64_Half      e_phnum;
    Elf64_Half      e_shentsize;
    Elf64_Half      e_shnum;
    Elf64_Half      e_shstrndx;
} Elf64_Ehdr;
```

**（1）ELF 魔数**

我们可以从前面 readelf 的输出看到，最前面的 Magic 的 16 个字节刚好对应 **`Elf32_Ehdr`** 的 **`e_ident`** 这个成员。 

最开始的 4 个字节是所有 ELF 文件都必须相同的标识码，分别为 **`0x7F、0x45、0x4c、0x46`**，第一个字节对应 ASCII 字符里面的 DEL 控制符，后面 3 个字节刚好是 ELF 这 3 个字母的 ASCII 码。**这 4 个字节又被称为 ELF 文件的魔数**，几乎所有的可执行文件格式的最开始的几个字节都是魔数。**<font color="red">这种魔数用来确认文件的类型，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载</font>**。

接下来的一个字节是用来标识 ELF 的文件类的，**`0x01`** 表示是 32 位的，**`0x02`** 表示是 64 位的；第 6 个字节是字节序，规定该 ELF 文件是大端的还是小端的（**`0x01`** 表示小端序，**`0x02`** 表示大端序）。第 7 个字节规定 ELF 文件的主版本号，一般是 1，因为 ELF 标准自 1.2 版以后就再也没有更新了。后面的 9 个字节 ELF 标准没有定义，一般填 0。

**（2）文件类型**

**`e_type`** 成员表示 ELF 文件类型，即前面提到过的 3 种 ELF 文件类型，每个文件类型对应一个常量。系统通过这个常量来判断 ELF 的真正文件类型，而不是通过文件的扩展名。相关常量以 **`ET_`** 开头。

- **`ET_REL`**: 值为 1，表示可重定位文件，一般为 .o 文件；
- **`ET_EXEC`**: 值为 2，表示可执行文件；
- **`ET_DYN`**: 值为 3，共享目标文件，一般为 .so 文件；

**（3）机器类型**

ELF 文件格式被设计成可以在多个平台下使用。**这并不表示同一个 ELF 文件可以在不同的平台下使用（就像 java 的字节码文件那样），而是表示不同平台下的 ELF 文件都遵循同一套 ELF 标准**。**`e_machine`** 成员就表示该 ELF 文件的平台属性，相关的常量以 **`EM_`** 开头，比如 **`EM_386`** 的值为 3，表示 intel x86。

### 3.2 段表

**段表（Section Header Table）** 用来保存 ELF 文件中段的基本属性的结构。段表描述了 ELF 的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。也就是说，ELF 文件的段结构就是由段表决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。段表在 ELF 文件中的位置由 ELF 文件头的 **`e_shoff`** 成员决定，比如 **`SimpleSection.o`** 中，段表位于偏移 0x118。

我们可以使用 readelf 工具来查看 ELF 文件的段，它显示出来的结果才是真正的段表结构。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -S SimpleSection.o
There are 18 section headers, starting at offset 0x4d4:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .group            GROUP           00000000 000034 000008 04     15  14  4
  [ 2] .text             PROGBITS        00000000 00003c 000075 00  AX  0   0  1
  [ 3] .rel.text         REL             00000000 0003c4 000050 08   I 15   2  4
  [ 4] .data             PROGBITS        00000000 0000b4 00000c 00  WA  0   0  4
  [ 5] .bss              NOBITS          00000000 0000c0 000010 00  WA  0   0  4
  [ 6] FOO               PROGBITS        00000000 0000c0 000004 00  WA  0   0  4
  [ 7] BAR               PROGBITS        00000000 0000c4 000010 00  AX  0   0  1
  [ 8] .relBAR           REL             00000000 000414 000010 08   I 15   7  4
  [ 9] .rodata           PROGBITS        00000000 0000d4 000004 00   A  0   0  1
  [10] .text.__x86.[...] PROGBITS        00000000 0000d8 000004 00 AXG  0   0  1
  [11] .comment          PROGBITS        00000000 0000dc 00002c 01  MS  0   0  1
  [12] .note.GNU-stack   PROGBITS        00000000 000108 000000 00      0   0  1
  [13] .eh_frame         PROGBITS        00000000 000108 0000a4 00   A  0   0  4
  [14] .rel.eh_frame     REL             00000000 000424 000020 08   I 15  13  4
  [15] .symtab           SYMTAB          00000000 0001ac 000150 10     16  12  4
  [16] .strtab           STRTAB          00000000 0002fc 0000c7 00      0   0  1
  [17] .shstrtab         STRTAB          00000000 000444 00008e 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
```

readelf 输出的结果就是 ELF 文件段表的内容，段表的结构比较简单，**<font color="red">它是一个以 **`Elf32_Shdr`** 结构体为元素的数组。数组元素的个数等于段的个数，每个 **`Elf32_Shdr`** 结构体对应一个段</font>**。**`Elf32_Shdr`** 又被称为段描述符（Section Descriptor）。对于 SimpleSection.o 来说，段表是有 17 个元素的数组。ELF 段表的这个数组的第一个元素是无效的段描述符，它的类型为 NULL，除此之外每个段描述符都对应一个段。也就是说 SimpleSection.o 共有 16 个有效的段。

**`Elf32_Shdr`** 的结构如下所示：

```c{.line-numbers}
typedef struct {
    // 段名是个字符串，它位于一个叫做 .shstrtab 的字符串表，sh_name 是段名字符串在 .shstrtab 中的偏移
    uint32_t   sh_name;
    // 段类型
    uint32_t   sh_type;
    // 段的标志位
    uint32_t   sh_flags;
    // 段虚拟地址，如果该段可以被加载，则 sh_addr 为该段加载后在进程地址空间中的虚拟地址；否则 sh_addr 为 0
    Elf32_Addr sh_addr;
    // 段偏移，如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义。比如 sh_offset 对于 BSS 段来说就没有意义
    Elf32_Off  sh_offset;
    // 段长度
    uint32_t   sh_size;
    // 段链接信息
    uint32_t   sh_link;
    uint32_t   sh_info;
    // 段地址对齐
    uint32_t   sh_addralign;
    // 项的长度，有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占的大小都是一样的。对于这种段，sh_entsize 表示每个项的大小。如果为 0，则表示该段不包含固定大小的项。
    uint32_t   sh_entsize;
} Elf32_Shdr;
```

>**`sh_addralign`** 有些段对地址对齐有要求，比如我们假设有个段刚开始的位置包含一个 double 变量，因为 Intel x86 系统要求浮点数的存储地址必须是其本身的整数倍。也就是说保存 double 变量的地址必须是 8 字节的整数倍。这样对于一个段来说，它的 **`sh_addr`** 必须是 8 的整数倍。
>由于地址对齐的数量都是 2 的指数倍，**`sh_addralign`** 表示是地址对齐数量中的指数，即 **`sh_addralign=3`** 表示对齐 2 的 3 次方倍，即 8 倍，依此类推。所以一个段的地址 **`sh_addr`** 必须满足下面的条件，即 **`sh_addr % (2 ** sh_addralign) = 0`**。** 表示指数运算。如果 **`sh_addralign`** 为 0 或 1，则表示该段没有对齐要求。

在 ELF 目标文件（.o 文件）中，**`Elf32_Shdr`** 结构的 **`sh_addr`** 字段值为 0。目标文件（.o 文件）属于可重定位文件（**`ET_REL`** 类型），其核心功能是为链接器提供代码和数据片段，而非直接执行。

**`sh_addr`** 字段表示段（Section）被加载到内存后的虚拟地址，但目标文件本身尚未完成链接过程，各段的位置需由链接器动态分配。因此，在未链接前，所有段的 **`sh_addr`** 默认设置为 0。链接器在合并多个目标文件时，会根据段类型、对齐规则和内存布局策略，为每个段分配实际的运行时地址。

<div align="center">
    <img src="目标文件_static//2.png" width="350"/>
</div>

#### 3.2.1 段类型

正如前面所说的，段的名字只是在链接和编译过程中有意义，但它不能真正地表示段的类型。我们也可以将一个数据段命名为 **`.text`**，对于编译器和链接器来说，主要决定段的属性的是段的类型（**`sh_type`**）和段的标志位（**`sh_flags`**）。 段的类型相关常量以 **`SHT_`** 开头。

- **`SHT_NULL`**:无效段；
- **`SHT_PROGBITS`**:程序段。代码段和数据段都是这种类型的，这些节的内容是实际的程序数据；
- **`SHT_SYMTAB`**:表示该段的内容为符号表；
- **`SHT_STRTAB`**:表示该段的内容为字符串表；
- **`SHT_RELA`**:重定位表。该段包含了重定位信息；
- **`SHT_HASH`**:符号表的哈希表；
- **`SHT_DYNAMIC`**:动态链接信息；
- **`SHT_NOTE`**:提示性信息；
- **`SHT_NOBITS`**:表示该段在文件中没内容，比如 **`.bss`** 段；
- **`SHT_REL`**:该段包含了重定位信息；
- **`SHT_SHLIB`**:保留；
- **`SHT_DNYSYM`**:动态链接的符号表；

#### 3.2.2 段的标志位

段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写、是否可执行等。相关常量以 **`SHF_`** 开头。

- **`SHF_WRITE`**:表示该段在进程空间中可写；
- **`SHF_ALLOC`**:表示该段在进程空间中须要分配空间。**<font color="red">有些包含指示或控制信息的段不须要在进程空间中被分配空间，它们一般不会有这个标志</font>**。像代码段、数据段和 **`.bss`** 段都会有这个标志位；
- **`SHF_EXECINSTR`**:表示该段在进程空间中可以被执行，一般指代码段；

#### 3.2.3 段的链接信息

如果段的类型是与链接相关的（不论是动态链接或静态链接），比如重定位表、符号表等，那么 **`sh_link`** 和 **`sh_info`** 这两个成员所包含的意义如下所示。对于其他类型的段，这两个成员没有意义。

- **`SHT_DYNAMIC`**: **`sh_link`** 为该段所使用的字符串表在段表中的下标，**`sh_info`** 为 0；
- **`SHT_HASH`**：**`sh_link`** 为该段所使用的符号表在段表中的下标，**`sh_info`** 为 0；
- **`SHT_REL/SHT_RELA`**：**`sh_link`** 为该段所使用的相应符号表在段表中的下标，**`sh_info`** 为该重定位表所作用的段在段表中的下标；
- **`SHT_SYMTAB/SHT_DYNSYM`**：**`sh_link`** 和 **`sh_info`** 均为操作系统相关的；
- **`other`**：**`sh_link`** 为 SHN_UNDEF，**`sh_info`** 为 0；

### 3.3 重定位表

在 SimpleSection.o 中有一个叫做 **`.rel.text`** 的段，它的类型（**`sh_type`**）为 **`SHT_REL`**，也就是说它是一个重定位表。链接器要在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位的信息都记录在 ELF 文件的重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。比如 SimpleSection.o 中的 **`.rel.text`** 就是针对 **`.text`** 段的重定位表，因为 **`.text`** 段中至少有一个绝对地址的引用，那就是对 printf 函数的调用。