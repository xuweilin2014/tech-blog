## 八、不同类型地址引用方式

对于现代的机器来说，产生的地址无关的代码并不麻烦。我们先来分析模块中各种类型的地址引用方式，这里我们把共享对象模块中的地址引用按照是否为跨模块分成两类：模块内部引用和模块外部引用；按照不同的引用方式又可以分为指令引用和数据访问。这样我们就得到了下面的 4 种情况：

- 第一种是模块内部的函数调用、跳转等；
- 第二种是模块内部的数据访问，比如模块中定义的全局变量、静态变量；
- 第三种是模块外部的函数调用、跳转等；
- 第四种是模块外部的数据访问，比如其他模块中定义的全局变量；

在解析上面 4 种情况之前，需要先解析和深入 C 语言中的 **`STB_LOCAL`**、**`STB_GLOBAL`**、**`STB_WEAK`** 这三种绑定属性以及 **`STV_DEFAULT`**、**`STV_HIDDEN`**、**`STV_PROTECTED`** 这三种可见性属性。

### 1.绑定属性

符号绑定属性是 ELF 文件中的一个基本特性，**<font color="red">它决定了链接器在静态链接阶段如何处理和解析符号</font>**。这些属性定义了符号的范围和优先级，尤其是在多个目标文件被合并时，**<font color="red">它们决定了哪个符号定义将被选中以满足引用</font>**。

#### 1.1 **`STB_LOCAL`** 属性

**`STB_LOCAL`** 绑定属性表示符号是本地的，其作用域仅限于定义它的目标文件内部。这意味着，即使在不同的目标文件中存在同名的 **`STB_LOCAL`** 符号，它们也不会相互干扰。对于 C 语言而言，在文件作用域内使用 static 关键字声明的函数或全局变量通常会被编译器赋予 **`STB_LOCAL`** 绑定 。

例如，一个 C 文件中的 **`static int counter;`** 或 **`static void helper_function();`** 都会生成 **`STB_LOCAL`** 符号。这种本地化特性确保了模块内部的封装性，防止了命名冲突，并允许编译器进行优化，**因为编译器/链接器知道这些符号不会在模块外部被引用或重写**。

在共享库中，使用文件作用域 static 关键字声明的函数和全局变量（即具有 **`STB_LOCAL`** 绑定）通常不需要 **`PLT/GOT`** 机制进行内部访问。相反，它们使用 PC 相对寻址（在 x86-64 上称为 RIP 相对寻址）进行访问。编译器计算静态符号相对于当前指令指针（PC/RIP）的固定偏移量。这允许直接跳转到静态函数或直接加载静态变量的值，无论共享库在内存中加载到何处。

#### 1.2 **`STB_GLOBAL`** 属性

**`STB_GLOBAL`** 绑定属性表示符号是全局的，它在所有被链接的目标文件之间都是可见的。一个目标文件中对 **`STB_GLOBAL`** 符号的定义可以满足另一个目标文件中对该符号的未定义引用。**<font color="red">在 C 语言中，在文件作用域内声明的非 static 函数和全局变量默认具有 **`STB_GLOBAL`** 绑定</font>**。

#### 1.3 **`STB_WEAK`** 属性

**`STB_WEAK`** 绑定属性的符号与 **`STB_GLOBAL`** 符号类似，也对所有被连接的目标文件可见，但其定义具有较低的优先级。这意味着，如果存在一个同名的 **`STB_GLOBAL`** 符号定义，链接器将优先选择 **`STB_GLOBAL`** 定义而忽略 **`STB_WEAK`** 定义。如果只有多个 **`STB_WEAK`** 定义而没有 **`STB_GLOBAL`** 定义，链接器的行为通常是选择第一个遇到的弱定义。

**`STB_WEAK`** 符号在 C 语言中可以通过 GCC 的 **`__attribute__((weak))`** 属性或 **`#pragma weak`** 指令来声明 。弱符号的一个主要用途是提供可被覆盖的默认实现。

### 2.ELF 符号的可见性

符号可见性属性，主要定义了符号一旦成为可执行文件或共享对象的一部分后，在运行时如何被访问。它是一种运行时访问控制机制，用于精细地管理软件组件的外部接口和运行时可访问性。

#### 2.1 **`STV_DEFAULT`** 可见性

The visibility of symbols with the **`STV_DEFAULT`** attribute is as specified by the symbol's binding type. That is, global and weak symbols are visible outside of their defining component (executable file or shared object). Local symbols are hidden, as described below. Global and weak symbols are also preemptable, that is, they may by interposed by definitions of the same name in another component.

**`STV_DEFAULT`** 属性表示符号的运行时可见性由其绑定类型决定。具体来说，具有 **`STB_GLOBAL`** 或 **`STB_WEAK`** 绑定的符号，如果其可见性为 **`STV_DEFAULT`**，**则在运行时对其他组件（可执行文件或共享对象）是可见的，并可能被抢占（即被同名的其他定义覆盖）**。相反，**`STB_LOCAL`** 符号，无论其 **`STV_DEFAULT`** 设置如何，本质上都是隐藏的，在定义它们的目标文件外部不可见。

这是大多数符号的默认可见性设置，除非通过编译器标志（例如 **`-fvisibility=hidden`**）或特定属性（例如 **`__attribute__((visibility("hidden")))`**）明确更改。**`STV_DEFAULT`** 代表了"正常"的操作状态，允许标准的动态链接行为和符号抢占的可能性。

#### 2.2 **`STV_HIDDEN`** 可见性

A symbol defined in the current component is hidden if its name is not visible to other components. Such a symbol is necessarily protected. This attribute is used to control the external interface of a component. Note that an object named by such a symbol may still be referenced from another component if its address is passed outside.

**`STV_HIDDEN`** 符号明确标记为在运行时对其他组件不可见。**<font color="red">其名称被有意地从动态符号表中排除，有效地使其成为定义组件内部的私有符号</font>**。此属性主要用于精确控制和限制共享库的外部应用程序编程接口（API）。

其他模块无法直接引用、链接或动态加载隐藏符号，这强制了严格的内部封装。开发者可以使用 GCC 特有的 **`__attribute__((visibility("hidden")))`** 属性来明确标记单个函数或全局变量为隐藏。或者，使用 **`-fvisibility=hidden`** 标志编译整个模块将默认隐藏所有符号，此时需要对任何旨在成为公共 API 的符号进行显式的 **`__attribute__((visibility("default")))`** 注释。

A hidden symbol contained in a relocatable object is either removed or converted to **`STB_LOCAL`** binding by the link-editor when the relocatable object is included in an executable file or shared object.这句话其实还不严谨，可以看后面的解析。

当使用链接器（ld）将一个或多个 **`.o`** 文件链接成一个最终产物（共享库 **`.so`**）时，链接器会扫描所有 **`.o`** 文件中的符号表，对于那个被标记为 **`STV_HIDDEN`** 的 foo 符号将其绑定属性从 **`STB_GLOBAL`** 转换为 **`STB_LOCAL`**。**`STB_LOCAL`** 属性的符号是纯粹的内部符号，它们的作用域仅限于当前模块，并且永远不会被放入到用于动态链接的 **`.dynsym`** 符号表中，因此由于链接器在链接时就已经知道了 foo 的最终地址，对它的调用可以被优化为直接的、高效的内部调用，而不需要通过 PLT/GOT 机制。

假设有下面的代码：

```c{.line-numbers}
// file2.c
#include <stdio.h>

__attribute__((visibility("hidden")))
long aa = 2;
int initialized_var = 3;
static int cc = 44;

int foo() {
    return initialized_var;
}

int bar() {
    foo();
}
```

将上述 **`file2.c`** 文件编译成 **`file2.o`** 文件，可以看到此时 file2.o 的文件中，变量 aa 的可见性是 **`STV_HIDDEN`**。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc file2.c -c -o file2.o -m32
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file2.o | grep aa
     4: 00000000     4 OBJECT  GLOBAL HIDDEN     4 aa
```

继续将 **`file2.c`** 文件编译成 **`.so`** 共享库文件，此时变量 aa 的可见性是 **`STV_DEFAULT`**，正好印证了我们所说的，当使用链接器（ld）将一个或多个 **`.o`** 文件链接成一个最终产物（共享库 **`.so`**）时，对于那个被标记为 **`STV_HIDDEN`** 的符号，会将其绑定属性转换为 **`STB_LOCAL`**，转变为一个 static 类型的变量，并且从用于动态链接的 **`.dynsym`** 符号表中删除。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc file2.c -o file2.so -fPIC -shared -m32
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file2.so | grep aa
   20: 00004014     4 OBJECT  LOCAL  DEFAULT   19 aa
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file2.so | grep cc
    10: 0000401c     4 OBJECT  LOCAL  DEFAULT   19 cc
monica@monica-virtual-machine:~/linkers_loaders$ readelf -sD file2.so

Symbol table for image contains 8 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __cxa_finalize
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]
     3: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]
     4: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 0000115d    23 FUNC    GLOBAL DEFAULT   10 foo
     6: 00001174    30 FUNC    GLOBAL DEFAULT   10 bar
     7: 00004018     4 OBJECT  GLOBAL DEFAULT   19 initialized_var
```

将 **`file1.c`** 和 **`file2.so`** 一起编译成可执行程序 file，发现绑定属性为 **`STB_LOCAL`** 的变量 aa（可见性为 **`STV_HIDDEN`**，链接器将其转换为 **`STB_LOCAL`**）和 cc（static 类型的变量）都不在最终生成的可执行程序的符号表中。aa/cc 是 file2.so 的 LOCAL 符号，它属于 file2.so 的内部实现细节，并没有被导出。当链接器构建 file 可执行文件时，它只关心 file 所需的外部符号，而 aa/cc 并不在其中，因此链接器完全没有理由将 aa/cc 的符号信息包含到 file 的符号表中。

```c{.line-numbers}
// file1.c 代码
#include <stdio.h>

int initialized_var;
int bb = 5;

extern int foo();

int main() {
    foo();
    printf("func1: my_var = %d\n", initialized_var);
}

monica@monica-virtual-machine:~/linkers_loaders$ gcc file1.c ./file2.so -o file -m32
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file | grep aa
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file | grep cc
```

当使用 **`gcc file1.c file2.o -o file -m32`** 命令编译 **`file1.c`** 和 **`file2.o`** 文件，会报 multiple definition of 'initialized_var' 错误，**<font color="red">这是因为此时链接器对 `file1.c` 和 `file2.o` 执行的是静态链接操作</font>**，链接器会把 **`file1.o`** 和 **`file2.o`** 中的代码段、数据段等所有部分物理上合并在一起，形成一个单一的、完整的可执行文件 file。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc file1.c file2.o -o file -m32
/usr/bin/ld: file2.o:(.data+0x4): multiple definition of `initialized_var'; /tmp/ccIwDGag.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status
```

假设将 file1.c 中的代码修改如下，可以看到，最终静态链接生成的 file 文件中正常包含了 aa 和 cc 变量。因为执行静态链接时，是将所有文件原封不动地进行合并，所以可以在 file 中找到 aa 和 cc 变量。

```c{.line-numbers}
// file1.c
#include <stdio.h>

__attribute__((weak))
int initialized_var;
int bb = 5;

extern int foo();

int main() {
    foo();
    printf("func1: my_var = %d\n", initialized_var);
}

monica@monica-virtual-machine:~/linkers_loaders$ gcc file1.c file2.o -o file -m32
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file | grep cc
    13: 00004014     4 OBJECT  LOCAL  DEFAULT   23 cc
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file | grep aa
    31: 0000400c     4 OBJECT  GLOBAL HIDDEN    23 aa
```

**`GLOBAL+HIDDEN`** normally happens in unlinked .o files (incl. static libs) for hidden functions (while unit-local static functions are **`LOCAL+DEFAULT`** there already). Then during linking, **`GLOBAL+HIDDEN`** converts to **`LOCAL+DEFAULT`**, always for normal functions when creating shared libraries.

However, for non-library executables, these internals are not fully converted, remaining **`GLOBAL+HIDDEN`** for a reason that might be pure convenience. As it is not a library that is linked to anywhere, it doesn't do any harm. 因为这个可执行文件已经是程序的“终点”了，不会再作为库被别人链接。所以，即使它内部的某些符号没有从 **`GLOBAL+HIDDEN`** 彻底转为 **`LOCAL+DEFAULT`**，也没有任何实际影响。外部世界根本没有机会来访问这些符号。链接器可能为了节省一点点处理时间或简化逻辑，就“偷懒”不去做这个最后的转换了。

假设有下面的代码，将 file2.c 直接编译成 file2 可执行程序之后，发现 aa 变量还是 **`GLOBAL+HIDDEN`**，没有被转变成 **`LOCAL+DEFAULT`**，验证了这个说法。

```c{.line-numbers}
// file2.c
#include <stdio.h>

__attribute__((visibility("hidden")))
long aa = 2;
int initialized_var = 3;
static int cc = 44;

int foo() {
    return initialized_var;
}

int bar() {
    foo();
}

int main() {
    bar();
}

monica@monica-virtual-machine:~/linkers_loaders$ gcc file2.c -o file2 -m32
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s file2 | grep aa
    29: 00004008     4 OBJECT  GLOBAL HIDDEN    23 aa
```

#### 2.3 **`STV_PROTECTED`** 可见性

A symbol defined in the current component is protected if it is visible in other components but not preemptable, meaning that any reference to such a symbol from within the defining component must be resolved to the definition in that component, even if there is a definition in another component that would interpose by the default rules. A symbol with **`STB_LOCAL`** binding will not have **`STV_PROTECTED`** visibility.

**`STV_PROTECTED`** 符号对其他组件是可见的（即其名称被导出），但当从其定义组件内部引用时，它不能被来自其他组件的同名定义抢占。此属性保证了共享对象内部对该符号的任何内部引用都将始终解析为该组件内部的定义，即使外部库试图进行抢占（覆盖）。

**<font color="red">此属性确保了库对其自身受保护函数或变量的内部调用将始终使用其自身的定义，无论是否通过 **`LD_PRELOAD`** 加载了同名函数或存在于另一个动态链接的共享对象中</font>**。与 **`STV_HIDDEN`** 类似，此属性可以应用于 C/C++ 源代码中的单个函数或全局变量 。

### 3.绑定性与可见性之间的相互作用

None of the visibility attributes affects the resolution of symbols within an executable or shared object during link-editing. Such resolution is controlled by the binding type. Once the link-editor has chosen its resolution, these attributes impose two requirements. 也就是说在链接期间，任何可见性属性都不会影响可执行文件或共享对象内部的符号解析，符号解析是由绑定类型（强/弱）控制的。一旦链接器完成了它的解析选择，这些可见性属性才会施加额外的要求。

在符号解析（Symbol Resolution）阶段，链接器查看所有 .o 文件，为每个符号引用找到一个唯一的定义。这个过程主要由符号的绑定类型（Binding Type）——即 STB_GLOBAL（强符号）和 STB_WEAK（弱符号）——来决定。例如，强定义会覆盖弱定义。可见性属性（protected, hidden 等）在这个阶段不起作用。

在符号解析完成，确定了用哪个定义之后，链接器才开始检查和强制执行可见性属性。

可见性属性并非替代符号绑定，而是作为符号行为的关键细化，主要影响 **`STB_GLOBAL`** 和 **`STB_WEAK`** 符号。绑定决定了符号 **<font color="red">在静态链接期间如何解析（即在合并目标文件时哪个定义胜出）</font>**，而可见性则管理 **<font color="red">它们一旦成为动态链接的可执行文件或共享对象的一部分后的运行时可访问性和抢占行为</font>**。**`STV_DEFAULT`** 属性明确地说明了这种依赖关系，因为其最终可见性直接来源于符号的基础绑定类型。

#### 3.1 传播规则

If any reference to or definition of a name is a symbol with a non-default visibility attribute, the visibility attribute must be propagated to the resolving symbol in the linked object. If different visibility attributes are specified for distinct references to or definitions of a symbol, the most constraining visibility attribute must be propagated to the resolving symbol in the linked object. The attributes, ordered from least to most constraining, are: **`STV_PROTECTED`**, **`STV_HIDDEN`** and **`STV_INTERNAL`**.

如果对一个名字的任何引用或定义，是一个带有非默认可见性属性的符号，那么这个可见性属性必须被传播给链接后对象中的最终解析符号。当链接器遇到一个符号的多个引用或定义，并且每个都可能带有不同的可见性属性时，会应用特定的传播规则：**<font color="red">最严格的可见性属性将被继承并应用于链接对象中最终解析的符号</font>**。约束的层次结构，从最不严格到最严格，定义为：**`STV_PROTECTED`** < **`STV_HIDDEN`** < **`STV_INTERNAL`**。

假设有 aa.c 和 bb.c 两个文件如下所示，my_func 在这 2 个文件中的可见性分别是 **`STV_PROTECTED`** 和 **`STV_DEFAULT`**，最后可以看到符号表中的 **`my_func`** 函数的可见性为 **`STV_PROTECTED`**，也就是 my_func 函数所有引用和定义中可见性最低的那一个。

```c{.line-numbers}
// aa.c
#include <stdio.h>
// 定义 my_func，并明确标记为 protected
__attribute__((visibility("protected")))
void my_func() {
    printf("hello world\n");
}

void helper() {
    my_func();
}

// bb.c
// 只是引用 my_func，但声明为 default
__attribute__((visibility("default"))) 
extern void my_func();

void func_b() {
    my_func(); // 编译器可能基于 hidden 属性进行优化
}

monica@monica-virtual-machine:~/linkers_loaders$ gcc aa.c bb.c -o aa -fPIC -shared -m32
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s aa

Symbol table '.dynsym' contains 9 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     8: 0000115d    43 FUNC    GLOBAL PROTECTED   12 my_func

Symbol table '.symtab' contains 32 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
    25: 0000115d    43 FUNC    GLOBAL PROTECTED   12 my_func
```

假设 aa.c 中 my_func 的可见性变为 **`__attribute__((visibility("hidden")))`**，最后可以看到 my_func 的绑定属性变为 **`STB_LOCAL`**。这就是前面说的，在链接并生成 .so 文件时，链接器会将 **`GLOBAL+HIDDEN`** 彻底转为 **`LOCAL+DEFAULT`**。

```c{.line-numbers}
 monica@ monica-virtual-machine:~/linkers_loaders$ gcc aa.c bb.c -o aa -fPIC -shared -m32
 monica@ monica-virtual-machine:~/linkers_loaders$ readelf -s aa | grep my_func
    16: 0000115d    43 FUNC    LOCAL  DEFAULT   12 my_func
```

#### 3.2 限制

ELF 规范中一个值得注意且逻辑一致的限制是：具有 **`STB_LOCAL`** 绑定的符号不能被赋予 **`STV_PROTECTED`** 可见性。这是因为 **`STB_LOCAL`** 符号本质上是私有的，在定义它们的目标文件外部不可见。而“保护”可见性的概念，意味着外部可见性但内部不可抢占，对于一个已经完全封装的符号来说是多余和矛盾的。

**`STB_LOCAL`** 从根本上意味着完全的内部封装，即符号的作用域严格受限，并且不会在外部可见。相反，**`STV_PROTECTED`** 则预设了外部可见性，同时强制执行内部不可抢占性。对于单个符号而言，这两个概念本质上是相互排斥的。ELF 规范强制执行这种逻辑一致性，防止可能导致不可预测的链接器行为或运行时错误的矛盾符号状态。

#### 3.3 内部非静态符号

一个常见的困惑是，即使是共享库内部对同一共享库内的 **`STB_GLOBAL`** 或 **`STB_WEAK`** 函数的调用，默认情况下也可能使用 **`PLT/GOT`** 机制 。这种看似低效的间接寻址之所以存在，主要是因为在 Linux 系统上，除非明确指定，所有函数都被赋予 **`STV_DEFAULT`** 可见性。这种默认可见性隐式地允许符号抢占在运行时发生。

如果另一个共享库（例如，通过 **`LD_PRELOAD`** 环境变量加载的库）提供了同名函数，动态链接器可能会"抢占"原始函数，这意味着它会将调用重定向到外部的、抢占性的定义。**`PLT/GOT`** 机制旨在通过提供一个动态链接器可以轻松更新以指向抢占符号的单点间接寻址来促进这种抢占。 

为了避免这种开销并防止对仅供共享库内部使用的函数进行抢占，开发者可以显式地将其可见性设置为 **`STV_HIDDEN`**，使用 **`__attribute__((visibility("hidden")))`** 属性。或者，使用 **`-fvisibility=hidden`** 标志编译整个模块将默认隐藏所有符号。当符号被标记为隐藏时，它们成为共享库的私有符号，不再受外部抢占的影响，从而允许编译器生成直接的 PC 相对调用，类似于处理 static 函数的方式。

符号抢占是在动态链接环境中发生的一种现象，当在加载到单个进程的不同动态对象（例如，主可执行文件和各种共享库）中存在多个同名符号定义时。**<font color="red">在默认的符号搜索模型下，对这种符号的引用将解析为动态链接器搜索路径中找到的第一个定义</font>**。这个第一个符号随后被称为"抢占"（或覆盖）任何其他同名定义。

#### 3.4 定义必须在组件内部

First, all of the non-default visibility attributes, when applied to a symbol reference, imply that a definition to satisfy that reference must be provided within the current executable or shared object. If this type of symbol reference has no definition within the component being linked, then the reference must have STB_WEAK binding and is resolved to zero.

