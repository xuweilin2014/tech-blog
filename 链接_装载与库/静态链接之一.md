# 静态链接

## 1.空间和地址分配

### 1.1 相似段合并

对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。对于多个输入目标文件，链接器将相同性质的段合并到一起，比如将所有输入文件的 **`.text`** 合并到输出文件的 **`.text`** 段，接着是 **`.data`** 段、**`.bss`** 段等。**`.bss`** **<font color="red">段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间</font>**。所以链接器在合并各个段的同时，也将 **`.bss`** 合并，并且分配虚拟空间。

现在链接器一般都采用一种叫 **两步链接（Two-pass Linking）** 的方法。也就是说整个链接过程分两步。

- **空间与地址分配**：扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
- **符号解析与重定位**：使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位，调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。

我们使用下面 a.c 和 b.c 文件来分析静态链接过程：

```c{.line-numbers}
// a.c
extern int shared;
int main() {
    int a = 100;
    swap(&a, &shared);
}

// b.c
int shared = 1;
void swap(int* a, int* b) {
    *a ^= *b ^= *a ^= *b;
}
```

我们使用 ld 链接器将 a.o 和 b.o 链接起来，**`ld a.o b.o -e main -o ab`**，其中 **`-e main`** 表示将 main 函数作为程序入口，ld 链接器将默认程序的入口设置为 **`_start`**。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -S a.o
There are 14 section headers, starting at offset 0x298:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .group            GROUP           00000000 000034 000008 04     11   5  4
  [ 2] .text             PROGBITS        00000000 00003c 00004a 00  AX  0   0  1
  [ 3] .rel.text         REL             00000000 0001ec 000020 08   I 11   2  4
  [ 4] .data             PROGBITS        00000000 000086 000000 00  WA  0   0  1
  [ 5] .bss              NOBITS          00000000 000086 000000 00  WA  0   0  1
  [ 6] .text.__x86.[...] PROGBITS        00000000 000086 000004 00 AXG  0   0  1
  [ 7] .comment          PROGBITS        00000000 00008a 00002c 01  MS  0   0  1
  [ 8] .note.GNU-stack   PROGBITS        00000000 0000b6 000000 00      0   0  1
  [ 9] .eh_frame         PROGBITS        00000000 0000b8 000060 00   A  0   0  4
  [10] .rel.eh_frame     REL             00000000 00020c 000010 08   I 11   9  4
  [11] .symtab           SYMTAB          00000000 000118 000090 10     12   4  4
  [12] .strtab           STRTAB          00000000 0001a8 000042 00      0   0  1
  [13] .shstrtab         STRTAB          00000000 00021c 00007a 00      0   0  1

monica@monica-virtual-machine:~/linkers_loaders$ readelf -S b.o
There are 14 section headers, starting at offset 0x25c:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .group            GROUP           00000000 000034 000008 04     11   6  4
  [ 2] .text             PROGBITS        00000000 00003c 000043 00  AX  0   0  1
  [ 3] .rel.text         REL             00000000 0001c0 000010 08   I 11   2  4
  [ 4] .data             PROGBITS        00000000 000080 000004 00  WA  0   0  4
  [ 5] .bss              NOBITS          00000000 000084 000000 00  WA  0   0  1
  [ 6] .text.__x86.[...] PROGBITS        00000000 000084 000004 00 AXG  0   0  1
  [ 7] .comment          PROGBITS        00000000 000088 00002c 01  MS  0   0  1
  [ 8] .note.GNU-stack   PROGBITS        00000000 0000b4 000000 00      0   0  1
  [ 9] .eh_frame         PROGBITS        00000000 0000b4 00004c 00   A  0   0  4
  [10] .rel.eh_frame     REL             00000000 0001d0 000010 08   I 11   9  4
  [11] .symtab           SYMTAB          00000000 000100 000080 10     12   4  4
  [12] .strtab           STRTAB          00000000 000180 00003d 00      0   0  1
  [13] .shstrtab         STRTAB          00000000 0001e0 00007a 00      0   0  1

monica@monica-virtual-machine:~/linkers_loaders$ readelf -S ab
There are 9 section headers, starting at offset 0x31a0:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        08049000 001000 000091 00  AX  0   0  1
  [ 2] .eh_frame         PROGBITS        0804a000 002000 000080 00   A  0   0  4
  [ 3] .got.plt          PROGBITS        0804c000 003000 00000c 04  WA  0   0  4
  [ 4] .data             PROGBITS        0804c00c 00300c 000004 00  WA  0   0  4
  [ 5] .comment          PROGBITS        00000000 003010 00002b 01  MS  0   0  1
  [ 6] .symtab           SYMTAB          00000000 00303c 0000c0 10      7   5  4
  [ 7] .strtab           STRTAB          00000000 0030fc 00005e 00      0   0  1
  [ 8] .shstrtab         STRTAB          00000000 00315a 000043 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
```

#### 1.1.1 节组

从上面 **`a.o`**、**`b.o`** 和 ab 三个文件的段表可以看出，a.o 文件的 **`.text`** 段大小为 0x4a，b.o 文件的 **`.text`** 段大小为 0x43，加起来并不等于 ab 中的 **`.text`** 段的大小 0x91。这是因为在 a.o 和 b.o 中都有 4 字节的 **`.text.__x86.get_pc_thunk.ax`** 桩代码，链接器在链接时从 **`a.o`** 和 **`b.o`** 中挑 1 份（只有 1 份）并入到 ab 程序的 .text 中。在 a.o 和 b.o 中，**`__x86.get_pc_thunk.ax`** 桩代码都属于一种特殊的节组 **`GRP_COMDAT`**。

根据文档，Some sections occur in interrelated groups. For example, an out-of-line definition of an inline function might require, in addition to the section containing its executable instructions, a read-only data section containing literals referenced, one or more debugging information sections and other informational sections. Furthermore, there may be internal references among these sections that would not make sense if one of the sections were removed or replaced by a duplicate from another object. Therefore, such groups must be included or omitted from the linked object as a unit. A section cannot be a member of more than one group. 

这段话描述了这么一个场景，假设一个函数 **`foo()`**。它的机器码在 **`.text`** 节，它用到的一个字符串常量在 **`.rodata`** 节，它的调试信息在 **`.debug_info`** 节，这三个节是紧密关联的，作为一个原子单元来处理。因此，当链接器决定丢弃或替换时，必须把它们作为一个整体处理。这正是 **`SHT_GROUP`** 的目的，把相关节列在一个组节里，必要时整体保留或整体丢弃。

A section which is part of a group, and is to be retained or discarded with the group as a whole, is identified by a new section header attribute **`SHF_GROUP`**. **<font color="red">This section is a member (perhaps the only one) of a group of sections, and the linker should retain or discard all or none of the members</font>**.

A section cannot be a member of more than one group. 节不能同时属于多个组，如果某个字符串常量被多处共享，它通常不会被放进"每个函数的私有组"；想要把某函数所需常量跟它绑定，编译器会把该常量放进该函数专用的小节并把这个小节加上 **`SHF_GROUP`**，再由 **`SHT_GROUP`** 把这些成员节串起来。

>**`SHF_GROUP`** 是节标志，是 **`sh_flags`** 标志位中的一位，常在 **`readelf -S`** 的 **`Flg`** 列显示为 G。**`SHT_GROUP`** 是一种专门的节类型，类似于 **`SHT_SYMTAB`** 表示该段的内容为符号表，**`SHT_GROUP`** 节的节数据是 **`Elf32_Word`** 项的数组。第一项是一个标志字。其余项是一系列节头索引。

This is a COMDAT group. It may duplicate another COMDAT group in another object file, where duplication is defined as having the same group signature. In such cases, only one of the duplicate groups may be retained by the linker, and the members of the remaining groups must be discarded. 也就是说 COMDAT 是一种特殊的节组，用于支持多个目标文件中的相同符号（例如内联函数）。COMDAT 组允许同一符号的多个定义，链接器会根据其符号签名来识别并保留唯一的副本。在链接时，如果链接器发现相同的符号签名，它会保留其中一个节组，其余的会被丢弃。这种机制保证了在链接时，如果多个源文件中都有对同一个内联函数或模板的定义，最终链接出来的程序只包含一个定义。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -g a.o
COMDAT group section [    1] `.group' [__x86.get_pc_thunk.ax] contains 1 sections:
   [Index]    Name
   [    6]   .text.__x86.get_pc_thunk.ax

monica@monica-virtual-machine:~/linkers_loaders$ readelf -g b.o
COMDAT group section [    1] `.group' [__x86.get_pc_thunk.ax] contains 1 sections:
   [Index]    Name
   [    6]   .text.__x86.get_pc_thunk.ax
```

为了便于理解 **`GRP_COMDAT`**，我们使用 C++ 模板函数作为例子，创建如下 3 个文件：

```c{.line-numbers}
// template.h
#pragma once
#include <iostream>
template<typename T>
void print_value(T value) {
    const char* message = "The value is: "; // 一个相关的只读数据
    std::cout << message << value << std::endl;
}

// a.cpp
#include "template.h"
void func_a() {
    print_value(100); // 实例化 print_value<int>
}

// b.cpp
#include "template.h"
void func_b() {
    print_value(200); // 再次实例化 print_value<int>
}

// main.cpp
void func_a();
void func_b();

int main() {
    func_a();
    func_b();
    return 0;
}
```

编译为目标文件。

```c{.line-numbers}
g++ -c a.cpp -o a.o -m32
g++ -c b.cpp -o b.o -m32
g++ -c main.cpp -o main.o -m32
```

如下是 **`a.o`** 和 **`main.o`** 中的节组信息，在 **`a.o`** 中，**<font color="red">编译器将实例化后的模版函数 **`print_value(int)`** 放入到 COMDAT 组</font>**。因为如果 **`print_value`** 定义在头文件中，那么其他编译单元（如 **`b.cpp`**）也可能会实例化它，从而导致链接时出现"多重定义"错误。COMDAT 机制使得链接器在遇到多个同签名的 COMDAT 组时，只会保留一个，其他的全部丢弃。

另外在 **`print_value(int)`** 的 COMDAT 组中，不仅包含了此模板函数的代码，还包含了其重定位信息。例如，**`print_value`** 内部调用了 **`std::cout`**，这个调用地址在编译时是不确定的，需要链接器来填充。将重定位节也放入组内，保证了处理的原子性。如果链接器决定丢弃 a.o 中的这个 **`print_value`** 实现（因为它可能选择了 b.o 中的版本），它会把对应的代码节和重定位节一起丢弃。

同时，在 a.o 中编译器生成了 **`__x86.get_pc_thunk.ax`** 和 **`__x86.get_pc_thunk.bx`** 两个辅助函数，这两个辅助函数在其他的地址无关文件中也可能用到，所以这里编译器也将其放到 COMDAT 组中进行去重。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -g a.o
COMDAT group section [    1] `.group' [_Z11print_valueIiEvT_] contains 2 sections:
   [Index]    Name
   [    9]   .text._Z11print_valueIiEvT_
   [   10]   .rel.text._Z11print_valueIiEvT_

COMDAT group section [    2] `.group' [__x86.get_pc_thunk.ax] contains 1 sections:
   [Index]    Name
   [   13]   .text.__x86.get_pc_thunk.ax

COMDAT group section [    3] `.group' [__x86.get_pc_thunk.bx] contains 1 sections:
   [Index]    Name
   [   14]   .text.__x86.get_pc_thunk.bx

monica@monica-virtual-machine:~/linkers_loaders$ readelf -g main.o
COMDAT group section [    1] `.group' [__x86.get_pc_thunk.bx] contains 1 sections:
   [Index]    Name
   [    6]   .text.__x86.get_pc_thunk.bx
```

#### 1.1.2 段合并

从下面的段表可以看出，**`.comment`**、**`.symtab`**、**`.strtab`**、**`.shstrtab`** 这 4 个段的 Addr 值为 0，这是因为这些节只在链接和调试时有用，当操作系统加载器将程序从磁盘文件加载到内存中准备运行时，它会完全忽略这些节，不为它们分配任何内存空间。因此既然这些节不被加载到内存中，它们自然也就没有内存地址，所以 Addr 字段被设置为 0。

并且由于 **`.text`** 段的内存权限是可读可执行，**`.eh_frame`** 段的内存权限是只读，**`.got.plt`** 和 **`.data`** 的权限是可读可写，因此链接器按照权限分组，将所有具有相同内存权限需求的节聚合在一起。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -S ab
There are 9 section headers, starting at offset 0x31a0:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        08049000 001000 000091 00  AX  0   0  1
  [ 2] .eh_frame         PROGBITS        0804a000 002000 000080 00   A  0   0  4
  [ 3] .got.plt          PROGBITS        0804c000 003000 00000c 04  WA  0   0  4
  [ 4] .data             PROGBITS        0804c00c 00300c 000004 00  WA  0   0  4
  [ 5] .comment          PROGBITS        00000000 003010 00002b 01  MS  0   0  1
  [ 6] .symtab           SYMTAB          00000000 00303c 0000c0 10      7   5  4
  [ 7] .strtab           STRTAB          00000000 0030fc 00005e 00      0   0  1
  [ 8] .shstrtab         STRTAB          00000000 00315a 000043 00      0   0  1

monica@monica-virtual-machine:~/linkers_loaders$ readelf -l ab

Elf 文件类型为 EXEC (可执行文件)
Entry point 0x8049000
There are 5 program headers, starting at offset 52

程序头：
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x08048000 0x08048000 0x000d4 0x000d4 R   0x1000
  LOAD           0x001000 0x08049000 0x08049000 0x00091 0x00091 R E 0x1000
  LOAD           0x002000 0x0804a000 0x0804a000 0x00080 0x00080 R   0x1000
  LOAD           0x003000 0x0804c000 0x0804c000 0x00010 0x00010 RW  0x1000
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10

 Section to Segment mapping:
  段节...
   00     
   01     .text 
   02     .eh_frame 
   03     .got.plt .data 

monica@monica-virtual-machine:~/linkers_loaders$ readelf -h ab
ELF 头：
  Magic：   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          Intel 80386
  版本:                              0x1
  入口点地址：                        0x8049000
  程序头起点：                        52 (bytes into file)
  Start of section headers:          12704 (bytes into file)
  标志：                              0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         5
  Size of section headers:           40 (bytes)
  Number of section headers:         9
  Section header string table index: 8
```

另外，**`.text`** 段没有从 **`0x08048000`** 开始，是因为从 **`0x08048000`** 开始的第一个内存页（第 1 个 **`PT_LOAD`** 段），被用来存放 ELF 头和程序头表。ELF 头大小为 52 字节，而程序头表的总大小为 160 字节，总大小为 212 字节，刚好等于第一个 **`PT_LOAD`** 段的大小 0x000d4（212 字节）。

#### 1.1.3 符号地址确定

我们还是以 **`a.o`** 和 **`b.o`** 作为例子，来分析这两个步骤中链接器的工作过程。在第一步的扫描和空间分配阶段，链接器按照前面介绍的空间分配方法进行分配，这时候输入文件中的各个段在链接后的文件 ab 中的虚拟地址也就已经确定了，比如 **`.text`** 段起始地址为 **`0x08049000`**，**`.data`** 段的起始地址为 **`0x0804c00c`**。

当前面一步完成之后，链接器开始计算各个符号的虚拟地址。**<font color="red">因为各个符号在段内的相对位置是固定的，所以这时候其实 main、shared 和 swap 的地址也已经是确定的了，只不过链接器需要给每个符号加上一个偏移量，使它们能够调整到正确的虚拟地址</font>**。

<div align="center">
    <img src="静态链接_static//1.png" width="300"/>
</div>

比如我假设 a.o 中的 main 函数相对于 **`a.o`** 的 **`.text`** 段的偏移是 X，但是经过链接合并以后，a.o 的 **`.text`** 段位于虚拟地址 **`0x08049000`**，那么 main 的地址应该是 **`0x08049000+X`**。从上面的输出可以看到，main 函数位于 **`a.o`** 的 **`.text`** 段的最开始，也就是偏移为 0，即在最终的输出文件 ab 中的地址应该是 **`0x08049000+0`**。然后接着是 **`__x86.get_pc_thunk.ax`** 段，由于 **`a.o`** 中 **`.text`** 段的大小为 0x4a，因此 **`__x86.get_pc_thunk.ax`** 段在 ab 文件中的地址为 **`0x0804904a`**。swap 函数位于 **`b.o`** 的 **`.text`** 段的最开始，偏移量也为 0，而 b.o 中的 **`.text`** 段在 **`__x86.get_pc_thunk.ax`** 之后，因此 swap 函数的地址为 **`0x0804904a+4=0x0804904e`**。

<div align="center">
    <img src="静态链接_static//2.png" width="300"/>
</div>

shared 变量在 **`b.o`** 的 **`.data`** 段的最开始，也就是偏移为 0，并且 **`b.o`** 的 **`.data`** 段位于 ab 文件中的 **`0x0804c00c`** 地址处（a.o 文件中 **`.data`** 段的大小为 0）。因此 shared 变量在 ab 文件中的地址为 **`0x0804c00c+0=0x0804c00c`**。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s a.o | grep main
     4: 00000000    74 FUNC    GLOBAL DEFAULT    2 main
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab | grep main
     9: 08049000    74 FUNC    GLOBAL DEFAULT    1 main

monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab | grep ax
     6: 0804904a     0 FUNC    GLOBAL HIDDEN     1 __x86.get_pc_thunk.ax

monica@monica-virtual-machine:~/linkers_loaders$ readelf -s b.o | grep swap
     5: 00000000    67 FUNC    GLOBAL DEFAULT    2 swap
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab | grep swap
     5: 0804904e    67 FUNC    GLOBAL DEFAULT    1 swap

monica@monica-virtual-machine:~/linkers_loaders$ readelf -s b.o | grep shared
     4: 00000000     4 OBJECT  GLOBAL DEFAULT    4 shared
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab | grep shared
     7: 0804c00c     4 OBJECT  GLOBAL DEFAULT    4 shared
```

## 2.符号解析与重定位

### 2.1 重定位——代码无关类型

接下来我们查看在 **`a.c`** 源程序中使用了 shared 变量和 swap 函数。接下来使用 **`objdump -d`** 查看 a.o 代码反汇编的结果：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c a.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC a.o
   a:	55                   	pushl   %ebp
   b:	89 e5                	movl    %esp, %ebp
   d:	53                   	pushl	%ebx
   e:	51                   	pushl	%ecx
   f:	83 ec 10             	subl	$16, %esp
  12:	e8 fc ff ff ff       	call	__x86.get_pc_thunk.ax           13: R_386_PC32	__x86.get_pc_thunk.ax
  17:	05 01 00 00 00       	addl	$_GLOBAL_OFFSET_TABLE_, %eax    18: R_386_GOTPC	_GLOBAL_OFFSET_TABLE_
  1c:	c7 45 f4 64 00 00 00 	movl	$100, -12(%ebp)
  23:	83 ec 08             	subl	$8, %esp
  26:	8b 90 00 00 00 00    	movl	shared@GOT(%eax), %edx          28: R_386_GOT32X shared
  2c:	52                   	pushl	%edx
  2d:	8d 55 f4             	leal	-12(%ebp), %edx
  30:	52                   	pushl	%edx
  31:	89 c3                	movl	%eax, %ebx
  33:	e8 fc ff ff ff       	call	swap@PLT                        34: R_386_PLT32	swap
```

在上面的编译指令中，默认开启了地址无关代码，另外对于 x86-32 位机器来说，函数调用时，参数从右往左依次压入栈中，调用完毕，由调用者负责将这些压入的参数清理掉，返回值置于 **`%eax`** 中。首先是常规的 **`push %ebp/mov %esp,%ebp`** 建帧，保存 **`%ebx`**，也把 **`%ecx`** 入栈备用。**`sub $0x10,%esp`** 给本地变量腾出 16 字节。接下来依次介绍上述汇编代码以及各个重定位类型。

其他可能会用到的信息如下：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c b.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ ld a.o b.o -o ab -e main -m elf_i386 -fno-stack-protector -shared
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC ab 
ab：     文件格式 elf32-i386
Disassembly of section .plt:

00001000 <swap@plt-0x10>:
    1000:	ff b3 04 00 00 00    	push   0x4(%ebx)
    1006:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
    100c:	00 00                	add    %al,(%eax)
	...

00001010 <swap@plt>:
    1010:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
    1016:	68 00 00 00 00       	push   $0x0
    101b:	e9 e0 ff ff ff       	jmp    1000 <swap@plt-0x10>

Disassembly of section .text:

00001020 <main>:
    1020:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    1024:	83 e4 f0             	and    $0xfffffff0,%esp
    1027:	ff 71 fc             	push   -0x4(%ecx)
    102a:	55                   	push   %ebp
    102b:	89 e5                	mov    %esp,%ebp
    102d:	53                   	push   %ebx
    102e:	51                   	push   %ecx
    102f:	83 ec 10             	sub    $0x10,%esp
    1032:	e8 33 00 00 00       	call   106a <__x86.get_pc_thunk.ax>
    1037:	05 c9 2f 00 00       	add    $0x2fc9,%eax
    103c:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
    1043:	83 ec 08             	sub    $0x8,%esp
    1046:	8b 90 fc ff ff ff    	mov    -0x4(%eax),%edx
    104c:	52                   	push   %edx
    104d:	8d 55 f4             	lea    -0xc(%ebp),%edx
    1050:	52                   	push   %edx
    1051:	89 c3                	mov    %eax,%ebx
    1053:	e8 b8 ff ff ff       	call   1010 <swap@plt>
    1058:	83 c4 10             	add    $0x10,%esp
    105b:	b8 00 00 00 00       	mov    $0x0,%eax
    1060:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1063:	59                   	pop    %ecx
    1064:	5b                   	pop    %ebx
    1065:	5d                   	pop    %ebp
    1066:	8d 61 fc             	lea    -0x4(%ecx),%esp
    1069:	c3                   	ret    

0000106a <__x86.get_pc_thunk.ax>:
    106a:	8b 04 24             	mov    (%esp),%eax
    106d:	c3                   	ret 

monica@monica-virtual-machine:~/linkers_loaders$ readelf -S ab
There are 18 section headers, starting at offset 0x31ac:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 3] .dynsym           DYNSYM          00000164 000164 000040 10   A  4   1  4
  [ 4] .dynstr           STRTAB          000001a4 0001a4 000025 00   A  0   0  1
  [ 5] .rel.dyn          REL             000001cc 0001cc 000008 08   A  3   0  4
  [ 6] .rel.plt          REL             000001d4 0001d4 000008 08  AI  3  12  4
  [ 7] .plt              PROGBITS        00001000 001000 000020 04  AX  0   0 16
  [ 8] .text             PROGBITS        00001020 001020 000091 00  AX  0   0  1
  [ 9] .eh_frame         PROGBITS        00002000 002000 0000a4 00   A  0   0  4
  [10] .dynamic          DYNAMIC         00003f5c 002f5c 0000a0 08  WA  4   0  4
  [11] .got              PROGBITS        00003ffc 002ffc 000004 04  WA  0   0  4
  [12] .got.plt          PROGBITS        00004000 003000 000010 04  WA  0   0  4
  [13] .data             PROGBITS        00004010 003010 000004 00  WA  0   0  4
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
monica@monica-virtual-machine:~/linkers_loaders$ readelf -r ab

重定位节 '.rel.dyn' at offset 0x1cc contains 1 entry:
 偏移量     信息    类型              符号值      符号名称
00003ffc  00000306 R_386_GLOB_DAT    00004010   shared

重定位节 '.rel.plt' at offset 0x1d4 contains 1 entry:
 偏移量     信息    类型              符号值      符号名称
0000400c  00000107 R_386_JUMP_SLOT   0000106e   swap
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab

Symbol table '.dynsym' contains 4 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000106e    67 FUNC    GLOBAL DEFAULT    8 swap
     2: 00001020    74 FUNC    GLOBAL DEFAULT    8 main
     3: 00004010     4 OBJECT  GLOBAL DEFAULT   13 shared

Symbol table '.symtab' contains 10 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c
     2: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c
     3: 00000000     0 FILE    LOCAL  DEFAULT  ABS 
     4: 00003f5c     0 OBJECT  LOCAL  DEFAULT   10 _DYNAMIC
     5: 0000106a     0 FUNC    LOCAL  DEFAULT    8 __x86.get_pc_thunk.ax
     6: 00004000     0 OBJECT  LOCAL  DEFAULT   12 _GLOBAL_OFFSET_TABLE_
     7: 0000106e    67 FUNC    GLOBAL DEFAULT    8 swap
     8: 00004010     4 OBJECT  GLOBAL DEFAULT   13 shared
     9: 00001020    74 FUNC    GLOBAL DEFAULT    8 main
```

#### 2.1.1 R_386_PC32

接下来是 **`call  __x86.get_pc_thunk.ax`** 指令，将下一条指令的地址保存到 **`%eax`** 寄存器中，本条指令的重定位类型是 **`R_386_PC32`**，这种重定位方式指令修改正方式每个被修正的位置的长度都为 32 位，即 4 个字节，比如 **`call rel32`** 的 4 字节立即数。

```c{.line-numbers}
R_386_PC32 重定位修正方法为 = S + A - P
A = 保存在被修正位置的值
P = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到
S = 符号的实际地址，即由 r_info 的高 24 位指定的符号的实际地址
```

在 **`S + A - P`** 中，A 是 addend（加数）。在 i386 上这种重定位通常是 REL 形式，**<font color="red">A 不在重定位表里，而是隐含在被修改的位置，也就是指令里的那个立即数/位移本身</font>**。**`call  __x86.get_pc_thunk.ax`** 汇编语句的二进制代码为 **`e8 fc ff ff ff`**，因此 A 的值为 -4。S 表示的就是符号 **`__x86.get_pc_thunk.ax`** 的实际地址，也就是这个函数在最终链接完成后的文件 ab 中的虚拟内存地址，即 0x106a。**<font color="red">P 指的就是被重定位的字段本身的地址，也就是需要被链接器覆写的地方的起始地址，注意 P 不是 call 指令的起始地址，而是其操作数的起始地址</font>**，因此 P 的值为 0x1033。

因此，最后这个重定位入口修正后的地址为 **`0x106a - 4 - 0x1033 = 0x33`**，最后链接器将 0x33 以小端序的方式覆写掉原来 **`fc ff ff ff`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`e8 33 00 00 00`**。

x86 架构 CPU 在执行 call rel32 指令的执行逻辑是 **`目标地址 = PC 寄存器值（下一条指令的地址） + 32位相对偏移量`**，当前 **`call  __x86.get_pc_thunk.ax`** 指令的下一条指令的地址为 0x1037，因此加上相对偏移量 0x33 之后就是 **`__x86.get_pc_thunk.ax`** 的起始地址 0x106a。

总结来说，**`R_386_PC32`** 是一种针对 32 位 x86 架构的重定位类型，编译器在生成目标文件时，如果遇到一个对外部或尚未确定地址的函数的调用时，在该指令的操作数位置（紧跟 0xe8 的 4 个字节），编译器会写入一个临时的、通常表示相对偏移的初始值，这个值被称为加数（Addend, A）。同时在重定位节（**`.rel.text`**）中创建一个重定位条目，包含重定位类型和偏移。在链接阶段，链接器（ld）负责将多个目标文件和库合并，并确定所有符号的最终虚拟地址，然后根据重定位类型计算出实际的相对偏移量，然后，它将这个计算结果 **覆写** 到机器码中，替换掉原来由编译器写入的临时加数值。

#### 2.1.2 R_386_GOTPC

然后是 **`addl	$_GLOBAL_OFFSET_TABLE_, %eax`**，将 %eax（当前执行的指令地址）和立即数 **`$_GLOBAL_OFFSET_TABLE_`** 相加得到 GOT 表的基地址。本条指令的重定位类型为 **`R_386_GOTPC`**，改写位置为 **`addl imm32, %eax`** 的 4 字节立即数。

```c{.line-numbers}
R_386_GOTPC 重定位修正方法为 = GOT + A - P
A   = 保存在被修正位置的值
P   = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到
GOT = 该目标文件的 .got/.got.plt 表的地址（运行时绝对地址）
```

在 **`GOT + A - P`** 中，A 是 addend（加数），**`addl  $_GLOBAL_OFFSET_TABLE_, %eax`** 汇编语句的二进制代码为 **`05 01 00 00 00`**，因此 A 的值为 1。GOT 这里表示的是 **`.got.plt`** 的运行时绝对地址，也就是在最终链接完成后的文件 ab 中的虚拟内存地址，即 0x4000。P 指的就是被重定位的字段本身的地址，也就是需要被链接器覆写的地方的起始地址，这里 P 的值为 0x1038。

因此，最后这个重定位入口修正后的地址为 **`0x4000 + 1 - 0x1038 = 0x2fc9`**，最后链接器将 0x2fc9 以小端序的方式覆写掉原来 **`01 00 00 00`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`05 c9 2f 00 00`**。

```c{.line-numbers}
// R_386_GOTPC 重定位类型最终计算出 .got/.got.plt 起始地址距离当前正在执行指令地址的距离/偏移量
// 这个距离/偏移量就是 $_GLOBAL_OFFSET_TABLE_ 立即数的值（由链接器计算写回）
GOT + A - P = GOT + 1 - P = GOT - (P - 1)
```

x86 架构 CPU 在执行 **`addl	$_GLOBAL_OFFSET_TABLE_, %eax`** 指令时，将偏移量（0x2fc9）加上当前指令的地址（寄存器 **`%eax`** 的值 0x1037）等于 **`.got.plt`** 起始地址 **`0x4000`**。因此，立即数 **`$_GLOBAL_OFFSET_TABLE_`** 的值就等于 **`0x4000`**，其实也可以从 ab 符号表中直接看出 **`_GLOBAL_OFFSET_TABLE_`** 的值为 **`0x4000`**。

接着的汇编指令 **`movl $100, -12(%ebp)`** 和 **`subl $8, %esp`** 分别把 100 保存到栈上，同时为后续参数压栈和对齐做准备。

#### 2.1.3 R_386_GOT32X/R_386_GOT32

然后是 **`movl  shared@GOT(%eax), %edx`** 指令，本条指令的重定位类型是 **`R_386_GOT32X`**，**<font color="red">其改写的位置为内存寻址里的 disp32，也就是 **`shared@GOT`** 那 4 字节</font>**。

>**`R_386_GOT32X/R_386_GOT32`** Both relocations have the same effect and the calculations are the same, but R_386_GOT32X relocations allow the linker to optimize the instructions used for the calculation, using immediate operands instead of memory operands under certain conditions.

```c{.line-numbers}
// R_386_GOT32X/R_386_GOT32 重定位类型最终计算出符号在 GOT 中槽位相对于 .got/.got.plt 起始地址的距离/偏移量
R_386_GOT32X/R_386_GOT32 重定位修正方法为 = G + A
A = 保存在被修正位置的值
G = 符号的 GOT 槽相对 GOT 基址的偏移，可以通过 r_offset 得到
```

在 **`G + A`** 中，A 是 addend（加数），**`movl  shared@GOT(%eax), %edx`** 汇编语句的二进制代码为 **`8b 90 00 00 00 00`**，因此 A 的值为 0。这里 G 表示 shared 符号在 GOT 中的槽位相对于 GOT 基址（确切地说是 **`.got.plt`** 的基地址）的偏移，shared 符号在 GOT 中的槽位地址就是需要重定位的存储单元，可以从 ab 程序的重定位表 shared 符号的 **`r_offset`** 值直接获取到 0x3ffc，因此 G 值为 **`0x3ffc - 0x4000 = -4 = 0xfffc`**。

>对于可执行文件（PIE）或共享目标文件(.so) 来说，**`r_offset`** 表示需要重定位作用的存储单元的虚拟地址（**<font color="blue">也就是 GOT 槽位的虚拟地址</font>**），但是正如前面所说，链接器在创建 PIE 或者共享目标文件时，因为编译器不知道代码最终会被加载到内存的哪个随机地址，所以通常假设该模块的加载基地址为 0，**<font color="red">因此 **`r_offset`** 可以直接认为也是需要定位的存储单元在模块中的偏移量</font>**。

最后这个重定位入口修正后的地址为 **`0xfffc + 0 = 0xfffc`**，最后链接器将 0xfffc 以小端序的方式覆写掉原来 **`00 00 00 00`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`8b 90 fc ff ff ff`**。因此 **`shared@GOT`** 表示 GOT 中保存 **`shared`** 这个变量相应的项/槽位与 GOT 基地址（**`$_GLOBAL_OFFSET_TABLE_`**）之间的偏移量/距离。

因此 **`movl  shared@GOT(%eax), %edx`** 指令将 GOT 槽位中 shared 变量的实际地址保存到 %edx 寄存器中，接下来的指令 **`pushl %edx`** 将其压入栈中，然后将变量 100 的地址也压入栈中。**`mov %eax, %ebx`** 把前面算出的 GOT 基址放到 %ebx（i386 PIC 约定 %ebx 保存 GOT 基址，后续 PLT 调用要用）。官方 psABI 规范如下：

>A basic difference between the i386 ABI and the x86-64 ABI is the way the GOT table is found. The i386 ABI, like (most) other processor specific ABIs, **uses a dedicated register (%ebx) to address the base of the GOT table**. The function prologue of every function needs to set up this register to the correct value.The x86-64 processor family introduces a new IP-relative addressing mode which is used in this ABI instead of using a dedicated register.

#### 2.1.4 R_386_PLT32

最后是 **`call	swap@PLT`** 指令，调用 swap 函数。本条指令的重定位类型为 **`R_386_PLT32`**，**<font color="red">其改写的位置为 `call rel32` 的 4 字节立即数</font>**。

```c{.line-numbers}
R_386_PLT32 重定位的修正方法为 L + A - P
A  = 保存在被修正位置的值
P  = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到
L  = 该函数符号的 PLT 表项地址，不是函数本体的地址
```



#### 2.1.5 R_386_GOTOFF

首先，我们构造如下 bb.c 文件代码：

```c{.line-numbers}
// bb.c
// 1.定义一个在本模块（文件）内的全局变量。static 关键字确保了这个变量是模块私有的（内部符号）
static int internal = 100;

// 2.定义一个外部可见的函数。
int func() {
    // 3.核心操作：获取内部全局变量的地址，并将其存储在一个指针中。为了让编译器实际执行这个操作而不是优化掉，我们把它转换成一个整数并返回。
    int* ptr = &internal;
    return (int)ptr;
}

int main() {
    func();
    return 0;
}
```

接下来使用 **`objdump -d`** 查看 bb.o 代码反汇编的结果：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c bb.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ gcc -S bb.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC bb.o

bb.o：     文件格式 elf32-i386
Disassembly of section .text:

00000000 <func>:
   0:    55                       pushl  %ebp
   1:    89 e5                    movl	 %esp, %ebp
   3:    83 ec 10                 subl	 $16, %esp
   6:    e8 fc ff ff ff           call   __x86.get_pc_thunk.ax           7: R_386_PC32       __x86.get_pc_thunk.ax
   b:    05 01 00 00 00           addl   $_GLOBAL_OFFSET_TABLE_, %eax    c: R_386_GOTPC      _GLOBAL_OFFSET_TABLE_
  10:    8d 80 00 00 00 00        leal   internal@GOTOFF(%eax), %eax     12: R_386_GOTOFF   .data
  16:    89 45 fc                 movl	 %eax, -4(%ebp)
  19:    8b 45 fc                 movl	-4(%ebp), %eax
  1c:    c9                       leave  
  1d:    c3                       ret  
```

其他相关信息如下所示：

```c{.line-numbers}
 monica@ monica-virtual-machine:~/linkers_loaders$ ld bb.o -o bb -e main -m elf_i386 -fno-stack-protector -shared
ld: bb.o: warning: relocation against `func' in read-only section `.text'
ld: warning: creating DT_TEXTREL in a shared object
 monica@ monica-virtual-machine:~/linkers_loaders$ objdump -drwC bb
bb：     文件格式 elf32-i386
Disassembly of section .text:

00001000 <func>:
    1000:	55                   	push   %ebp
    1001:	89 e5                	mov    %esp,%ebp
    1003:	83 ec 10             	sub    $0x10,%esp
    1006:	e8 2c 00 00 00       	call   1037 <__x86.get_pc_thunk.ax>
    100b:	05 f5 2f 00 00       	add    $0x2ff5,%eax
    1010:	8d 80 0c 00 00 00    	lea    0xc(%eax),%eax
    1016:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1019:	8b 45 fc             	mov    -0x4(%ebp),%eax
    101c:	c9                   	leave  
    101d:	c3                   	ret     

00001037 <__x86.get_pc_thunk.ax>:
    1037:	8b 04 24             	mov    (%esp),%eax
    103a:	c3                   	ret    
 monica@ monica-virtual-machine:~/linkers_loaders$ readelf -s bb

Symbol table '.dynsym' contains 3 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000101e    25 FUNC    GLOBAL DEFAULT    6 main
     2: 00001000    30 FUNC    GLOBAL DEFAULT    6 func

Symbol table '.symtab' contains 9 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS bb.c
     2: 0000400c     4 OBJECT  LOCAL  DEFAULT   10 internal
     3: 00000000     0 FILE    LOCAL  DEFAULT  ABS 
     4: 00003f70     0 OBJECT  LOCAL  DEFAULT    8 _DYNAMIC
     5: 00001037     0 FUNC    LOCAL  DEFAULT    6 __x86.get_pc_thunk.ax
     6: 00004000     0 OBJECT  LOCAL  DEFAULT    9 _GLOBAL_OFFSET_TABLE_
     7: 0000101e    25 FUNC    GLOBAL DEFAULT    6 main
     8: 00001000    30 FUNC    GLOBAL DEFAULT    6 func
```

可以看到 **`leal  internal@GOTOFF(%eax), %eax`** 指令的重定位类型为 **`R_386_GOTOFF`**，此重定位类型指示链接器计算一个符号（这里是 internal）的绝对地址与 GOT 表起始地址之间的距离/偏移量。**`R_386_GOTOFF`** 的改写位置为内存寻址里的 disp32 位移。

```c{.line-numbers}
R_386_GOTOFF 重定位修正方法为 = S + A - GOT
A   = 保存在被修正位置的值
S   = 符号的实际地址，即由 r_info 的高 24 位指定的符号的实际地址
GOT = 该目标文件的 .got/.got.plt 表的地址（运行时绝对地址）
```

在 **`S + A - GOT`** 中，A 是 addend（加数），**`leal  internal@GOTOFF(%eax), %eax`** 汇编语句的二进制代码为 **`8d 80 00 00 00 00`**，因此 A 的值为 0。这里 GOT 表示 **`_GLOBAL_OFFSET_TABLE_`** 的值，也就是 0x4000。S 表示的就是符号 internal 的实际地址 0x400c。因此 **`S + A - GOT = 0xc`**，最后链接器将 0xc 以小端序的方式覆写掉原来 **`00 00 00 00`** 的值，最终在链接后的 bb 文件中可执行的机器码会变为 **`8d 80 0c 00 00 00`**。

最后 **`leal  internal@GOTOFF(%eax), %eax`** 指令就将 internal 变量的实际地址 0x400c 保存到 %eax 寄存器中。**`R_386_GOTOFF`** 主要作用是让程序用 GOT 作为锚点拿到本 DSO 内符号的绝对地址，而不需要再经由 GOT 读取一次内存。

```c{.line-numbers}
int internal = 100;

int func() {
    int* ptr = &internal;
    return (int)ptr;
}

int main() {
    func();
    return 0;
}

monica@monica-virtual-machine:~/linkers_loaders$ gcc -c bb.c -m32 -fno-stack-protector -fPIC
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC bb.o

bb.o：     文件格式 elf32-i386
Disassembly of section .text:

00000000 <func>:
   0:    55                       pushl  %ebp
   1:    89 e5                    movl	 %esp, %ebp
   3:    83 ec 10                 subl	 $16, %esp
   6:    e8 fc ff ff ff           call	 __x86.get_pc_thunk.ax          7: R_386_PC32      __x86.get_pc_thunk.ax
   b:    05 01 00 00 00           addl	 $_GLOBAL_OFFSET_TABLE_, %eax   c: R_386_GOTPC     _GLOBAL_OFFSET_TABLE_
  10:    8b 80 00 00 00 00        movl	 internal@GOT(%eax), %eax       12: R_386_GOT32X   internal
  16:    89 45 fc                 movl	 %eax, -4(%ebp)
  19:    8b 45 fc                 movl	 -4(%ebp), %eax
  1c:    c9                       leave  
  1d:    c3                       ret    
```

举例，加上我们将 **`bb.c`** 修改如下，并且在编译时加上 **`-fPIC`** 选项，可以看出现在使用 **`movl internal@GOT(%eax), %eax`** 指令来获取 internal 变量的地址到 %eax 寄存器中，且重定位类型变为 **`R_386_GOT32X`**。这两条指令之间的差别如下：

```c{.line-numbers}
// 运行时：EAX = EBX + (S + A - GOT) = S + A  -> 得到 internal 的绝对地址
leal  internal@GOTOFF(%ebx), %eax
// 运行时：访问 GOT 中的 internal 符号槽，获取到 internal 变量的地址，需要访问一次内存
mov   internal@GOT(%ebx), %eax
```

**<font color="red">总结来说，`symbol@GOTOFF(%ebx)` 相对 GOT 给出变量本身地址，而 `symbol@GOT(%ebx)` 给出的是符号在 GOT 槽中的地址</font>**。当符号不可被其它模块抢占覆盖（non-preemptible）时，没必要通过读取 GOT 取地址，可以直接用 **`symbol@GOTOFF(%ebx)`** 一次性算出地址。当符号可能可抢占（preemptible）（例如把这段代码编进共享库/DSO 且符号是默认可见性），编译器就会生成 **`symbol@GOT(%ebx)`** 一类访问，对应 **`R_386_GOT32/GOT32X`**，让运行时链接器能通过改写 GOT 槽实现符号重定位。