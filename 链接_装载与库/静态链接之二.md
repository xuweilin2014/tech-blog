# 静态链接

## 3.重定位类型

### 3.1 重定位类型——代码无关类型

接下来我们查看在 **`a.c`** 源程序中使用了 shared 变量和 swap 函数。接下来使用 **`objdump -d`** 查看 a.o 代码反汇编的结果：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c a.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC a.o
   a:	55                   	pushl   %ebp
   b:	89 e5                	movl    %esp, %ebp
   d:	53                   	pushl	%ebx
   e:	51                   	pushl	%ecx
   f:	83 ec 10             	subl	$16, %esp
  12:	e8 fc ff ff ff       	call	__x86.get_pc_thunk.ax           13: R_386_PC32	__x86.get_pc_thunk.ax
  17:	05 01 00 00 00       	addl	$_GLOBAL_OFFSET_TABLE_, %eax    18: R_386_GOTPC	_GLOBAL_OFFSET_TABLE_
  1c:	c7 45 f4 64 00 00 00 	movl	$100, -12(%ebp)
  23:	83 ec 08             	subl	$8, %esp
  26:	8b 90 00 00 00 00    	movl	shared@GOT(%eax), %edx          28: R_386_GOT32X shared
  2c:	52                   	pushl	%edx
  2d:	8d 55 f4             	leal	-12(%ebp), %edx
  30:	52                   	pushl	%edx
  31:	89 c3                	movl	%eax, %ebx
  33:	e8 fc ff ff ff       	call	swap@PLT                        34: R_386_PLT32	swap
```

在上面的编译指令中，默认开启了地址无关代码，另外对于 x86-32 位机器来说，函数调用时，参数从右往左依次压入栈中，调用完毕，由调用者负责将这些压入的参数清理掉，返回值置于 **`%eax`** 中。首先是常规的 **`push %ebp/mov %esp,%ebp`** 建帧，保存 **`%ebx`**，也把 **`%ecx`** 入栈备用。**`sub $0x10,%esp`** 给本地变量腾出 16 字节。接下来依次介绍上述汇编代码以及各个重定位类型。

其他可能会用到的信息如下：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c b.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ ld a.o b.o -o ab -e main -m elf_i386 -fno-stack-protector -shared
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC ab 
ab：     文件格式 elf32-i386
Disassembly of section .plt:

00001000 <swap@plt-0x10>:
    1000:	ff b3 04 00 00 00    	push   0x4(%ebx)
    1006:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
    100c:	00 00                	add    %al,(%eax)
	...

00001010 <swap@plt>:
    1010:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
    1016:	68 00 00 00 00       	push   $0x0
    101b:	e9 e0 ff ff ff       	jmp    1000 <swap@plt-0x10>

Disassembly of section .text:

00001020 <main>:
    1020:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    1024:	83 e4 f0             	and    $0xfffffff0,%esp
    1027:	ff 71 fc             	push   -0x4(%ecx)
    102a:	55                   	push   %ebp
    102b:	89 e5                	mov    %esp,%ebp
    102d:	53                   	push   %ebx
    102e:	51                   	push   %ecx
    102f:	83 ec 10             	sub    $0x10,%esp
    1032:	e8 33 00 00 00       	call   106a <__x86.get_pc_thunk.ax>
    1037:	05 c9 2f 00 00       	add    $0x2fc9,%eax
    103c:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
    1043:	83 ec 08             	sub    $0x8,%esp
    1046:	8b 90 fc ff ff ff    	mov    -0x4(%eax),%edx
    104c:	52                   	push   %edx
    104d:	8d 55 f4             	lea    -0xc(%ebp),%edx
    1050:	52                   	push   %edx
    1051:	89 c3                	mov    %eax,%ebx
    1053:	e8 b8 ff ff ff       	call   1010 <swap@plt>
    1058:	83 c4 10             	add    $0x10,%esp
    105b:	b8 00 00 00 00       	mov    $0x0,%eax
    1060:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1063:	59                   	pop    %ecx
    1064:	5b                   	pop    %ebx
    1065:	5d                   	pop    %ebp
    1066:	8d 61 fc             	lea    -0x4(%ecx),%esp
    1069:	c3                   	ret    

0000106a <__x86.get_pc_thunk.ax>:
    106a:	8b 04 24             	mov    (%esp),%eax
    106d:	c3                   	ret 

monica@monica-virtual-machine:~/linkers_loaders$ readelf -S ab
There are 18 section headers, starting at offset 0x31ac:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 3] .dynsym           DYNSYM          00000164 000164 000040 10   A  4   1  4
  [ 4] .dynstr           STRTAB          000001a4 0001a4 000025 00   A  0   0  1
  [ 5] .rel.dyn          REL             000001cc 0001cc 000008 08   A  3   0  4
  [ 6] .rel.plt          REL             000001d4 0001d4 000008 08  AI  3  12  4
  [ 7] .plt              PROGBITS        00001000 001000 000020 04  AX  0   0 16
  [ 8] .text             PROGBITS        00001020 001020 000091 00  AX  0   0  1
  [ 9] .eh_frame         PROGBITS        00002000 002000 0000a4 00   A  0   0  4
  [10] .dynamic          DYNAMIC         00003f5c 002f5c 0000a0 08  WA  4   0  4
  [11] .got              PROGBITS        00003ffc 002ffc 000004 04  WA  0   0  4
  [12] .got.plt          PROGBITS        00004000 003000 000010 04  WA  0   0  4
  [13] .data             PROGBITS        00004010 003010 000004 00  WA  0   0  4
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
monica@monica-virtual-machine:~/linkers_loaders$ readelf -r ab

重定位节 '.rel.dyn' at offset 0x1cc contains 1 entry:
 偏移量     信息    类型              符号值      符号名称
00003ffc  00000306 R_386_GLOB_DAT    00004010   shared

重定位节 '.rel.plt' at offset 0x1d4 contains 1 entry:
 偏移量     信息    类型              符号值      符号名称
0000400c  00000107 R_386_JUMP_SLOT   0000106e   swap
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab

Symbol table '.dynsym' contains 4 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000106e    67 FUNC    GLOBAL DEFAULT    8 swap
     2: 00001020    74 FUNC    GLOBAL DEFAULT    8 main
     3: 00004010     4 OBJECT  GLOBAL DEFAULT   13 shared

Symbol table '.symtab' contains 10 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c
     2: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c
     3: 00000000     0 FILE    LOCAL  DEFAULT  ABS 
     4: 00003f5c     0 OBJECT  LOCAL  DEFAULT   10 _DYNAMIC
     5: 0000106a     0 FUNC    LOCAL  DEFAULT    8 __x86.get_pc_thunk.ax
     6: 00004000     0 OBJECT  LOCAL  DEFAULT   12 _GLOBAL_OFFSET_TABLE_
     7: 0000106e    67 FUNC    GLOBAL DEFAULT    8 swap
     8: 00004010     4 OBJECT  GLOBAL DEFAULT   13 shared
     9: 00001020    74 FUNC    GLOBAL DEFAULT    8 main
```

#### 3.1.1 R_386_PC32

接下来是 **`call  __x86.get_pc_thunk.ax`** 指令，将下一条指令的地址保存到 **`%eax`** 寄存器中，本条指令的重定位类型是 **`R_386_PC32`**，这种重定位方式指令修改正方式每个被修正的位置的长度都为 32 位，即 4 个字节，比如 **`call rel32`** 的 4 字节立即数。

```c{.line-numbers}
R_386_PC32 重定位修正方法为 = S + A - P
A = 保存在被修正位置的值
P = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到
S = 符号的实际地址，即由 r_info 的高 24 位指定的符号的实际地址
```

在 **`S + A - P`** 中，A 是 addend（加数）。在 i386 上这种重定位通常是 REL 形式，**<font color="red">A 不在重定位表里，而是隐含在被修改的位置，也就是指令里的那个立即数/位移本身</font>**。**`call  __x86.get_pc_thunk.ax`** 汇编语句的二进制代码为 **`e8 fc ff ff ff`**，因此 A 的值为 -4。S 表示的就是符号 **`__x86.get_pc_thunk.ax`** 的实际地址，也就是这个函数在最终链接完成后的文件 ab 中的虚拟内存地址，即 0x106a。**<font color="red">P 指的就是被重定位的字段本身的地址，也就是需要被链接器覆写的地方的起始地址，注意 P 不是 call 指令的起始地址，而是其操作数的起始地址</font>**，因此 P 的值为 0x1033。

因此，最后这个重定位入口修正后的地址为 **`0x106a - 4 - 0x1033 = 0x33`**，最后链接器将 0x33 以小端序的方式覆写掉原来 **`fc ff ff ff`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`e8 33 00 00 00`**。

x86 架构 CPU 在执行 call rel32 指令的执行逻辑是 **`目标地址 = PC 寄存器值（下一条指令的地址） + 32位相对偏移量`**，当前 **`call  __x86.get_pc_thunk.ax`** 指令的下一条指令的地址为 0x1037，因此加上相对偏移量 0x33 之后就是 **`__x86.get_pc_thunk.ax`** 的起始地址 0x106a。

总结来说，**`R_386_PC32`** 是一种针对 32 位 x86 架构的重定位类型，编译器在生成目标文件时，如果遇到一个对外部或尚未确定地址的函数的调用时，在该指令的操作数位置（紧跟 0xe8 的 4 个字节），编译器会写入一个临时的、通常表示相对偏移的初始值，这个值被称为加数（Addend, A）。同时在重定位节（**`.rel.text`**）中创建一个重定位条目，包含重定位类型和偏移。在链接阶段，链接器（ld）负责将多个目标文件和库合并，并确定所有符号的最终虚拟地址，然后根据重定位类型计算出实际的相对偏移量，然后，它将这个计算结果 **覆写** 到机器码中，替换掉原来由编译器写入的临时加数值。

#### 3.1.2 R_386_GOTPC

然后是 **`addl	$_GLOBAL_OFFSET_TABLE_, %eax`**，将 %eax（当前执行的指令地址）和立即数 **`$_GLOBAL_OFFSET_TABLE_`** 相加得到 GOT 表的基地址。本条指令的重定位类型为 **`R_386_GOTPC`**，改写位置为 **`addl imm32, %eax`** 的 4 字节立即数。

```c{.line-numbers}
R_386_GOTPC 重定位修正方法为 = GOT + A - P
A   = 保存在被修正位置的值
P   = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到
GOT = 该目标文件的 .got/.got.plt 表的地址（运行时绝对地址）
```

在 **`GOT + A - P`** 中，A 是 addend（加数），**`addl  $_GLOBAL_OFFSET_TABLE_, %eax`** 汇编语句的二进制代码为 **`05 01 00 00 00`**，因此 A 的值为 1。GOT 这里表示的是 **`.got.plt`** 的运行时绝对地址，也就是在最终链接完成后的文件 ab 中的虚拟内存地址，即 0x4000。P 指的就是被重定位的字段本身的地址，也就是需要被链接器覆写的地方的起始地址，这里 P 的值为 0x1038。

因此，最后这个重定位入口修正后的地址为 **`0x4000 + 1 - 0x1038 = 0x2fc9`**，最后链接器将 0x2fc9 以小端序的方式覆写掉原来 **`01 00 00 00`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`05 c9 2f 00 00`**。

```c{.line-numbers}
// R_386_GOTPC 重定位类型最终计算出 .got/.got.plt 起始地址距离当前正在执行指令地址的距离/偏移量
// 这个距离/偏移量就是 $_GLOBAL_OFFSET_TABLE_ 立即数的值（由链接器计算写回）
GOT + A - P = GOT + 1 - P = GOT - (P - 1)
```

x86 架构 CPU 在执行 **`addl	$_GLOBAL_OFFSET_TABLE_, %eax`** 指令时，将偏移量（0x2fc9）加上当前指令的地址（寄存器 **`%eax`** 的值 0x1037）等于 **`.got.plt`** 起始地址 **`0x4000`**。因此，立即数 **`$_GLOBAL_OFFSET_TABLE_`** 的值就等于 **`0x4000`**，其实也可以从 ab 符号表中直接看出 **`_GLOBAL_OFFSET_TABLE_`** 的值为 **`0x4000`**。

接着的汇编指令 **`movl $100, -12(%ebp)`** 和 **`subl $8, %esp`** 分别把 100 保存到栈上，同时为后续参数压栈和对齐做准备。

#### 3.1.3 R_386_GOT32X/R_386_GOT32

然后是 **`movl  shared@GOT(%eax), %edx`** 指令，本条指令的重定位类型是 **`R_386_GOT32X`**，**<font color="red">其改写的位置为内存寻址里的 disp32，也就是 **`shared@GOT`** 那 4 字节</font>**。

>**`R_386_GOT32X/R_386_GOT32`** Both relocations have the same effect and the calculations are the same, but R_386_GOT32X relocations allow the linker to optimize the instructions used for the calculation, using immediate operands instead of memory operands under certain conditions.

```c{.line-numbers}
// R_386_GOT32X/R_386_GOT32 重定位类型最终计算出符号在 GOT 中槽位相对于 .got/.got.plt 起始地址的距离/偏移量
R_386_GOT32X/R_386_GOT32 重定位修正方法为 = G + A
A = 保存在被修正位置的值
G = 符号的 GOT 槽相对 GOT 基址的偏移，可以通过 r_offset 得到
```

在 **`G + A`** 中，A 是 addend（加数），**`movl  shared@GOT(%eax), %edx`** 汇编语句的二进制代码为 **`8b 90 00 00 00 00`**，因此 A 的值为 0。这里 G 表示 shared 符号在 GOT 中的槽位相对于 GOT 基址（确切地说是 **`.got.plt`** 的基地址）的偏移，shared 符号在 GOT 中的槽位地址就是需要重定位的存储单元，可以从 ab 程序的重定位表 shared 符号的 **`r_offset`** 值直接获取到 0x3ffc，因此 G 值为 **`0x3ffc - 0x4000 = -4 = 0xfffc`**。

>对于可执行文件（PIE）或共享目标文件(.so) 来说，**`r_offset`** 表示需要重定位作用的存储单元的虚拟地址（**<font color="blue">也就是 GOT 槽位的虚拟地址</font>**），但是正如前面所说，链接器在创建 PIE 或者共享目标文件时，因为编译器不知道代码最终会被加载到内存的哪个随机地址，所以通常假设该模块的加载基地址为 0，**<font color="red">因此 **`r_offset`** 可以直接认为也是需要定位的存储单元在模块中的偏移量</font>**。

最后这个重定位入口修正后的地址为 **`0xfffc + 0 = 0xfffc`**，最后链接器将 0xfffc 以小端序的方式覆写掉原来 **`00 00 00 00`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`8b 90 fc ff ff ff`**。因此 **`shared@GOT`** 表示 GOT 中保存 **`shared`** 这个变量相应的项/槽位与 GOT 基地址（**`$_GLOBAL_OFFSET_TABLE_`**）之间的偏移量/距离。

因此 **`movl  shared@GOT(%eax), %edx`** 指令将 GOT 槽位中 shared 变量的实际地址保存到 %edx 寄存器中，接下来的指令 **`pushl %edx`** 将其压入栈中，然后将变量 100 的地址也压入栈中。**`mov %eax, %ebx`** 把前面算出的 GOT 基址放到 %ebx（i386 PIC 约定 %ebx 保存 GOT 基址，后续 PLT 调用要用）。官方 psABI 规范如下：

>A basic difference between the i386 ABI and the x86-64 ABI is the way the GOT table is found. The i386 ABI, like (most) other processor specific ABIs, **uses a dedicated register (%ebx) to address the base of the GOT table**. The function prologue of every function needs to set up this register to the correct value.The x86-64 processor family introduces a new IP-relative addressing mode which is used in this ABI instead of using a dedicated register.

#### 3.1.4 R_386_PLT32

最后是 **`call	swap@PLT`** 指令，调用 swap 函数。本条指令的重定位类型为 **`R_386_PLT32`**，**<font color="red">其改写的位置为 `call rel32` 的 4 字节立即数</font>**。

```c{.line-numbers}
// R_386_PLT32 重定位类型计算的就是 call 命令的下一条指令距离函数符号在 PLT 表项的偏移量/距离
R_386_PLT32 重定位的修正方法为 L + A - P
A  = 保存在被修正位置的值
P  = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到
L  = 该函数符号的 PLT 表项地址，不是函数本体的地址
```

在 **`L + A - P`** 中，A 是 addend（加数），**`call	swap@PLT`** 汇编语句的二进制代码为 **`e8 fc ff ff ff`**，因此 A 的值为 -4。P 指的就是被重定位的字段本身的地址，也就是需要被链接器覆写的地方的起始地址 0x1054。L 表示 swap 在 PLT 中的槽位地址，由于 **`.plt`** 节的总大小为 0x20，而在 i386 上每个 PLT 槽大小为 0x10 字节，因此 ab 程序中 **`.plt`** 共 2 个槽，plt0（解析器跳板，保留项）在 0x1000；swap 函数项在 0x1010，因此 L 的值为 0x1010。

```c{.line-numbers}
[ 7] .plt              PROGBITS        00001000 001000 000020 04  AX  0   0 16
```

因此，最后这个重定位入口修正后的地址为 **`0x1010 - 4 - 0x1054 = 0xffff ffb8 = -72`**，最后链接器将 **`0xffff ffb8`** 以小端序的方式覆写掉原来 **`fc ff ff ff`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`e8 b8 ff ff ff`**。

**<font color="red">x86 架构 CPU 在执行 call rel32 指令的执行逻辑是</font>** **`目标地址 = PC 寄存器值（下一条指令的地址） + 32位相对偏移量`**，当前 **`call swap@PLT`** 指令的下一条指令的地址为 0x1058，因此加上相对偏移量 -72 之后就是 swap 函数在 PLT 中的表项起始地址 0x1010。因此 CPU 最后会跳转到 swap 函数在 PLT 中的表项，首次调用会经由 PLT/GOT 触发懒绑定；动态链接器把 GOT 槽修成 swap 的真实地址，后续再跳就直达函数体。

#### 3.1.5 R_386_GOTOFF

首先，我们构造如下 bb.c 文件代码：

```c{.line-numbers}
// bb.c
// 1.定义一个在本模块（文件）内的全局变量。static 关键字确保了这个变量是模块私有的（内部符号）
static int internal = 100;

// 2.定义一个外部可见的函数。
int func() {
    // 3.核心操作：获取内部全局变量的地址，并将其存储在一个指针中。为了让编译器实际执行这个操作而不是优化掉，我们把它转换成一个整数并返回。
    int* ptr = &internal;
    return (int)ptr;
}

int main() {
    func();
    return 0;
}
```

接下来使用 **`objdump -d`** 查看 bb.o 代码反汇编的结果：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c bb.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ gcc -S bb.c -m32 -fno-stack-protector
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC bb.o

bb.o：     文件格式 elf32-i386
Disassembly of section .text:

00000000 <func>:
   0:    55                       pushl  %ebp
   1:    89 e5                    movl	 %esp, %ebp
   3:    83 ec 10                 subl	 $16, %esp
   6:    e8 fc ff ff ff           call   __x86.get_pc_thunk.ax           7: R_386_PC32       __x86.get_pc_thunk.ax
   b:    05 01 00 00 00           addl   $_GLOBAL_OFFSET_TABLE_, %eax    c: R_386_GOTPC      _GLOBAL_OFFSET_TABLE_
  10:    8d 80 00 00 00 00        leal   internal@GOTOFF(%eax), %eax     12: R_386_GOTOFF   .data
  16:    89 45 fc                 movl	 %eax, -4(%ebp)
  19:    8b 45 fc                 movl	-4(%ebp), %eax
  1c:    c9                       leave  
  1d:    c3                       ret  
```

其他相关信息如下所示：

```c{.line-numbers}
 monica@ monica-virtual-machine:~/linkers_loaders$ ld bb.o -o bb -e main -m elf_i386 -fno-stack-protector -shared
ld: bb.o: warning: relocation against `func' in read-only section `.text'
ld: warning: creating DT_TEXTREL in a shared object
 monica@ monica-virtual-machine:~/linkers_loaders$ objdump -drwC bb
bb：     文件格式 elf32-i386
Disassembly of section .text:

00001000 <func>:
    1000:	55                   	push   %ebp
    1001:	89 e5                	mov    %esp,%ebp
    1003:	83 ec 10             	sub    $0x10,%esp
    1006:	e8 2c 00 00 00       	call   1037 <__x86.get_pc_thunk.ax>
    100b:	05 f5 2f 00 00       	add    $0x2ff5,%eax
    1010:	8d 80 0c 00 00 00    	lea    0xc(%eax),%eax
    1016:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1019:	8b 45 fc             	mov    -0x4(%ebp),%eax
    101c:	c9                   	leave  
    101d:	c3                   	ret     

00001037 <__x86.get_pc_thunk.ax>:
    1037:	8b 04 24             	mov    (%esp),%eax
    103a:	c3                   	ret    
 monica@ monica-virtual-machine:~/linkers_loaders$ readelf -s bb

Symbol table '.dynsym' contains 3 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000101e    25 FUNC    GLOBAL DEFAULT    6 main
     2: 00001000    30 FUNC    GLOBAL DEFAULT    6 func

Symbol table '.symtab' contains 9 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS bb.c
     2: 0000400c     4 OBJECT  LOCAL  DEFAULT   10 internal
     3: 00000000     0 FILE    LOCAL  DEFAULT  ABS 
     4: 00003f70     0 OBJECT  LOCAL  DEFAULT    8 _DYNAMIC
     5: 00001037     0 FUNC    LOCAL  DEFAULT    6 __x86.get_pc_thunk.ax
     6: 00004000     0 OBJECT  LOCAL  DEFAULT    9 _GLOBAL_OFFSET_TABLE_
     7: 0000101e    25 FUNC    GLOBAL DEFAULT    6 main
     8: 00001000    30 FUNC    GLOBAL DEFAULT    6 func
```

可以看到 **`leal  internal@GOTOFF(%eax), %eax`** 指令的重定位类型为 **`R_386_GOTOFF`**，此重定位类型指示链接器计算一个符号（这里是 internal）的绝对地址与 GOT 表起始地址之间的距离/偏移量。**`R_386_GOTOFF`** 的改写位置为内存寻址里的 disp32 位移。

```c{.line-numbers}
R_386_GOTOFF 重定位修正方法为 = S + A - GOT
A   = 保存在被修正位置的值
S   = 符号的实际地址，即由 r_info 的高 24 位指定的符号的实际地址
GOT = 该目标文件的 .got/.got.plt 表的地址（运行时绝对地址）
```

在 **`S + A - GOT`** 中，A 是 addend（加数），**`leal  internal@GOTOFF(%eax), %eax`** 汇编语句的二进制代码为 **`8d 80 00 00 00 00`**，因此 A 的值为 0。这里 GOT 表示 **`_GLOBAL_OFFSET_TABLE_`** 的值，也就是 0x4000。S 表示的就是符号 internal 的实际地址 0x400c。因此 **`S + A - GOT = 0xc`**，最后链接器将 0xc 以小端序的方式覆写掉原来 **`00 00 00 00`** 的值，最终在链接后的 bb 文件中可执行的机器码会变为 **`8d 80 0c 00 00 00`**。

最后 **`leal  internal@GOTOFF(%eax), %eax`** 指令就将 internal 变量的实际地址 0x400c 保存到 %eax 寄存器中。**`R_386_GOTOFF`** 主要作用是让程序用 GOT 作为锚点拿到本 DSO 内符号的绝对地址，而不需要再经由 GOT 读取一次内存。

```c{.line-numbers}
int internal = 100;

int func() {
    int* ptr = &internal;
    return (int)ptr;
}

int main() {
    func();
    return 0;
}

monica@monica-virtual-machine:~/linkers_loaders$ gcc -c bb.c -m32 -fno-stack-protector -fPIC
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC bb.o

bb.o：     文件格式 elf32-i386
Disassembly of section .text:

00000000 <func>:
   0:    55                       pushl  %ebp
   1:    89 e5                    movl	 %esp, %ebp
   3:    83 ec 10                 subl	 $16, %esp
   6:    e8 fc ff ff ff           call	 __x86.get_pc_thunk.ax          7: R_386_PC32      __x86.get_pc_thunk.ax
   b:    05 01 00 00 00           addl	 $_GLOBAL_OFFSET_TABLE_, %eax   c: R_386_GOTPC     _GLOBAL_OFFSET_TABLE_
  10:    8b 80 00 00 00 00        movl	 internal@GOT(%eax), %eax       12: R_386_GOT32X   internal
  16:    89 45 fc                 movl	 %eax, -4(%ebp)
  19:    8b 45 fc                 movl	 -4(%ebp), %eax
  1c:    c9                       leave  
  1d:    c3                       ret    d
```

举例，加上我们将 **`bb.c`** 修改如下，并且在编译时加上 **`-fPIC`** 选项，可以看出现在使用 **`movl internal@GOT(%eax), %eax`** 指令来获取 internal 变量的地址到 %eax 寄存器中，且重定位类型变为 **`R_386_GOT32X`**。这两条指令之间的差别如下：

```c{.line-numbers}
// 运行时：EAX = EBX + (S + A - GOT) = S + A  -> 得到 internal 的绝对地址
leal  internal@GOTOFF(%ebx), %eax
// 运行时：访问 GOT 中的 internal 符号槽，获取到 internal 变量的地址，需要访问一次内存
mov   internal@GOT(%ebx), %eax
```

**<font color="red">总结来说，`symbol@GOTOFF(%ebx)` 相对 GOT 给出变量本身地址，而 `symbol@GOT(%ebx)` 给出的是符号在 GOT 槽中的地址</font>**。当符号不可被其它模块抢占覆盖（non-preemptible）时，没必要通过读取 GOT 取地址，可以直接用 **`symbol@GOTOFF(%ebx)`** 一次性算出地址。当符号可能可抢占（preemptible）（例如把这段代码编进共享库/DSO 且符号是默认可见性），编译器就会生成 **`symbol@GOT(%ebx)`** 一类访问，对应 **`R_386_GOT32/GOT32X`**，让运行时链接器能通过改写 GOT 槽实现符号重定位。

### 3.2 重定位类型——非代码无关类

接下来对于同样的 a.c 和 b.c 文件，在编译时使用 **`-fno-pic`** 选项，要求编译器不要生成位置无关代码，访问全局变量和函数时尽量使用绝对地址。然后使用 **`objdump -d`** 查看 a.o 代码反汇编的结果：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c a.c -m32 -fno-stack-protector -fno-PIC
monica@monica-virtual-machine:~/linkers_loaders$ objdump -drwC a.o
a.o：     文件格式 elf32-i386
Disassembly of section .text:

00000000 <main>:
   0:	8d 4c 24 04          	leal    4(%esp), %ecx
   4:	83 e4 f0             	andl    $-16, %esp
   7:	ff 71 fc             	pushl	-4(%ecx)
   a:	55                   	pushl	%ebp
   b:	89 e5                	movl	%esp, %ebp
   d:	51                   	pushl	%ecx
   e:	83 ec 14             	subl	$20, %esp
  11:	c7 45 f4 64 00 00 00 	movl	$100, -12(%ebp)
  18:	83 ec 08             	subl	$8, %esp
  1b:	68 00 00 00 00       	pushl	$shared	            1c: R_386_32	shared
  20:	8d 45 f4             	leal	-12(%ebp), %eax
  23:	50                   	pushl	%eax
  24:	e8 fc ff ff ff       	call	swap	            25: R_386_PC32	swap
  29:	83 c4 10             	addl	$16, %esp
  2c:	b8 00 00 00 00       	movl	$0, %eax
  31:	8b 4d fc             	movl	-4(%ebp), %ecx
  34:	c9                   	leave  
  35:	8d 61 fc             	leal	-4(%ecx), %esp
  38:	c3                   	ret  
```

使用同样的命令编译 b.c 文件，然后使用链接器链接 a.o 和 b.o 文件：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c b.c -m32 -fno-stack-protector -fno-PIC
monica@monica-virtual-machine:~/linkers_loaders$ ld a.o b.o -o ab -e main -m elf_i386 
monica@monica-virtual-machine:~/linkers_loaders$ objdump -dwrC ab

ab：     文件格式 elf32-i386
Disassembly of section .text:

08049000 <main>:
 8049000:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8049004:	83 e4 f0             	and    $0xfffffff0,%esp
 8049007:	ff 71 fc             	push   -0x4(%ecx)
 804900a:	55                   	push   %ebp
 804900b:	89 e5                	mov    %esp,%ebp
 804900d:	51                   	push   %ecx
 804900e:	83 ec 14             	sub    $0x14,%esp
 8049011:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
 8049018:	83 ec 08             	sub    $0x8,%esp
 804901b:	68 00 c0 04 08       	push   $0x804c000
 8049020:	8d 45 f4             	lea    -0xc(%ebp),%eax
 8049023:	50                   	push   %eax
 8049024:	e8 10 00 00 00       	call   8049039 <swap>
 8049029:	83 c4 10             	add    $0x10,%esp
 804902c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049031:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 8049034:	c9                   	leave  
 8049035:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8049038:	c3                   	ret  
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s ab

Symbol table '.symtab' contains 9 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c
     2: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c
     3: 08049039    57 FUNC    GLOBAL DEFAULT    1 swap
     4: 0804c000     4 OBJECT  GLOBAL DEFAULT    3 shared
     5: 0804c004     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start
     6: 08049000    57 FUNC    GLOBAL DEFAULT    1 main
     7: 0804c004     0 NOTYPE  GLOBAL DEFAULT    3 _edata
     8: 0804c004     0 NOTYPE  GLOBAL DEFAULT    3 _end

monica@monica-virtual-machine:~/linkers_loaders$ file ab
ab: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
```

>-fno-stack-protector、-fno-pie 是 GCC 编译器的选项，不能用于传递给链接器 ld，如果直接传给链接器，ld 不认识这些 **`-fno-...`** 编译选项，会把它们解析成自己的短选项 -f，把 no-stack-protector 当作 --auxiliary 的参数，于是报：-f may not be used without -shared。

#### 3.2.1 R_386_32

**`pushl  $shared`** 命令的重定位类型为 **`R_386_32`**，**`R_386_32`** **<font color="red">重定位类型用于直接定位符号的绝对地址</font>**。例如，在指令 **`movl $global_var, %eax`** 中，**`global_var`** 的地址需要被直接写入机器码。

```c{.line-numbers}
// R_386_32 重定位类型用于直接定位符号的绝对地址
R_386_32 重定位的修正方法为 S + A
A  = 保存在被修正位置的值
S  = 符号的实际地址，即由 r_info 的高 24 位指定的符号的实际地址
```

在 **`S + A`** 中，A 是 addend（加数），**`pushl  $shared`** 汇编语句的二进制代码为 **`68 00 00 00 00`**，因此 A 的值为 0，S 指的就是符号的实际地址 0x0804c000。因此 **`S + A = 0x0804c000`**，最后链接器将 0x0804c000 以小端序的方式覆写掉原来 **`00 00 00 00`** 的值，最终在链接后的 ab 文件中可执行的机器码会变为 **`68 00 c0 04 08`**。因此 **`pushl  $shared`** 指令就将 shared 变量的实际地址 0x0804c000 保存到栈中。

## 4.静态库链接

在一般的情况下，一种语言的开发环境往往会附带有语言库。这些库就是对操作系统的 API 的包装，比如我们经常见的 C 语言版 Hello World 程序，它使用 C 语言标准库的 printf 函数来输出一个字符串，printf 函数对字符串进行一些必要的处理以后，最后会调用操作系统提供的 API。

其实一个静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。比如我们在 Linux 中最常用的 C 语言静态库 libc 位于 **`/usr/lib32/libc.a`**，它属于 glibc 项目的一部分；像 Windows 这样的平台上，最常使用的 C 语言库是由集成开发环境所附带的运行库，这些库一般由编译器厂商提供，比如 Visual C++ 附带了多个版本的 C/C++ 运行库。

我们知道在一个 C 语言的运行库中，包含了很多跟系统功能相关的代码，比如输入输出、文件操作、时间日期、内存管理等。glibc 本身是用 C 语言开发的，它由成百上千个 C 语言源代码文件组成，也就是说，编译完成以后有相同数量的目标文件，比如输入输出有 **`printf.o`**、**`scanf.o`**；文件操作有 **`fread.o`**、**`fwrite.o`**；时间日期有 **`date.o`**、**`time.o`**；内存管理有 **`malloc.o`** 等。把这些零散的目标文件直接提供给使用者，很大程度上会造成文件传输、管理和组织方面的不便，于是通常人们使用 ar 压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了 **`libc.a`** 这个静态库文件。我们也可以使用 ar 工具来查看这个文件包含了哪些目标文件：

```c{.line-numbers}
monica@monica-virtual-machine:/usr/lib32$ ar -t libc.a 
init-first.o
libc-start.o
sysdep.o
version.o
check_fds.o
libc-tls.o
dso_handle.o
errno.o
errno-loc.o
iconv_open.o
iconv.o
iconv_close.o
gconv_open.o
...
```

我们可以使用 objdump 来查看 **`libc.a`** 中的符号，**`objdump -t`** 选项显示目标文件或可执行文件的符号表信息。其输出内容反映了文件中定义的全局变量、函数以及引用的外部符号等关键信息。使用 **`objdump -t`** 查找 printf 符号发现如下结果：

```c{.line-numbers}
monica@monica-virtual-machine:/usr/lib32$ objdump -t libc.a | grep printf
printf.o：     文件格式 elf32-i386
00000000 g     F .text	0000002d __printf
00000000         *UND*	00000000 .hidden __vfprintf_internal
00000000 g     F .text	0000002d _IO_printf
00000000 g     F .text	0000002d printf
```

可以看到 printf 函数被定义在了 **`printf.o`** 这个目标文件中。这里我们似乎可以认为 Hello World 程序编译出来的目标文件只要和 **`libc.a`** 里面的 **`printf.o`** 链接在一起，最后就可以形成一个可用的可执行文件了。这个解释似乎很完美，实际上已经很接近最后的答案了。

那么我们就按照这个方案去尝试一下，假设 Hello World 程序的源代码为 **`hello.c`**，使用如下方法编译：

```c{.line-numbers}
gcc -c -fno-builtin hello.c
```

我们得到了目标文件为 **`hello.o`**。为什么这里要使用 **`-fno-builtin`** 参数是因为默认情况下，GCC 会自作聪明地将 Hello World 程序中只使用了一个字符串参数的 printf 替换成 puts 函数，以提高运行速度，我们要使用 **`-fno-builtin`** 关闭这个内置函数优化选项。

如果开启了 **`-fno-builtin`** 选项，不以 **`__builtin_`** 开头的库函数，编译器不会再将其当作内建函数（builtin）来识别与优化；这些调用被当作普通外部符号处理，从而避免利用它们的"已知语义"做替换、内联或额外诊断。

GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to alloca may become single instructions which adjust the stack directly, and calls to memcpy may become inline copy loops. 这是 GCC 的默认优化行为，对于 alloca 函数，GCC 知道这个函数的作用是在栈上分配内存，所以它直接生成一条修改栈指针（**`sub esp, N`**）的汇编指令，这比完整的函数调用快得多。

The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. 最终生成的代码通常更小也更快，但是有 2 个副作用，**<font color="red">第一个就是无法对这些函数设置断点</font>**，函数调用可能被展开/替换成指令序列或别的形式，因而不再出现对该符号的 call 指令，因此在 memcpy/strlen 等名字上设断点就不会触发；**<font color="red">第二个就是无法实现函数替换</font>**，假设用户想用一个自己写的、功能更特殊的 memcpy 函数来替换系统标准库里的版本会失败，这是因为没有真实的函数调用（没有 call 指令），用换库（含 **`LD_PRELOAD`**）来"劫持/替换"行为就失效，因为链接器根本看不到那次调用。

In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with -Wformat for bad calls to printf when printf is built in and strlen is known not to modify global memory. 这是内置函数机制的另一个高级优点，**<font color="red">编译器不仅仅是替换代码，它还理解这些函数的语义</font>**。比如编译器知道 printf 函数的参数和调用格式，如果用户编写了 **`printf("%s", 123);`** 语句，编译器就能在编译时发现类型不匹配并发出警告；对于 strlen 函数，GCC 编译器知道 strlen 只是读取内存，绝不会修改任何变量，因此这个特性让编译器可以进行更大胆的优化，比如指令重排。

With the -fno-builtin-function option only the built-in function function is disabled. function must not begin with '__builtin_'. If a function is named that is not built-in in this version of GCC, this option is ignored. 当使用 **`-fno-builtin-function`** 命令时，只禁用选项中指定的那一个函数的优化，比如 **`-fno-builtin-memcpy`** 只会让 GCC 编译器不去优化 memcpy 函数，而其他函数的内置优化仍然有效。另外，在使用 **`-fno-builtin-function`** 命令时，如果写错了函数名，或者指定了一个非内置函数，编译器不会报错，只会默默地忽略这个选项。

总结来说，**`-fno-builtin`** 强制 GCC 编译器将每一次对标准库函数的调用（如 **`printf`**, **`memcpy`**, **`strlen`** 等）都视为一次普通的、外部的函数调用，并生成相应的函数调用指令（例如，**`call printf`**），而不是使用编译器自己实现的、可能更高效的内联代码或其他特殊指令。

我们使用 ld 将 **`printf.o`** 和 **`hello.o`** 链接到一起：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ ld hello.o printf.o
ld: i386 architecture of input file `printf.o' is incompatible with i386:x86-64 output
ld: 警告: 无法找到项目符号 _start; 缺省为 0000000000401000
ld: printf.o: in function `__printf':
(.text+0xa): undefined reference to `_GLOBAL_OFFSET_TABLE_'
ld: (.text+0x1e): undefined reference to `stdout'
ld: (.text+0x25): undefined reference to `__vfprintf_internal'
ld: a.out: hidden symbol `__vfprintf_internal' isn't defined
ld: 最后的链结失败: bad value

monica@monica-virtual-machine:~/linkers_loaders$ readelf -s printf.o 

Symbol table '.symtab' contains 10 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 SECTION LOCAL  DEFAULT    2 .text
     2: 00000000     0 SECTION LOCAL  DEFAULT    6 .text.__x86.get_[...]
     3: 00000000    45 FUNC    GLOBAL DEFAULT    2 __printf
     4: 00000000     0 FUNC    GLOBAL HIDDEN     6 __x86.get_pc_thunk.ax
     5: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
     6: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND stdout
     7: 00000000     0 NOTYPE  GLOBAL HIDDEN   UND __vfprintf_internal
     8: 00000000    45 FUNC    GLOBAL DEFAULT    2 _IO_printf
     9: 00000000    45 FUNC    GLOBAL DEFAULT    2 printf

monica@monica-virtual-machine:~/linkers_loaders$ readelf -s stdio.o | grep stdout
     3: 00000004     4 OBJECT  GLOBAL DEFAULT    4 stdout
     4: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND _IO_2_1_stdout_
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s vfprintf-internal.o | grep internal
    75: 00003110  8296 FUNC    GLOBAL HIDDEN     4 __vfprintf_internal
```

链接却失败了，原因是缺少两个外部符号的定义，**`printf.o`** 里面有两个 UND 的符号 **`stdout`** 和 **`__vfprintf_internal`**，也就是有两个未定义的符号。正是这两个未定义的符号导致了看似完美的解释，很明显 **`printf.o`** 依赖于其他的目标文件。

用同样的方法，我们可以找到 stdout 这个符号所在的目标文件，它位于 **`stdio.o`**；而 **`__vfprintf_internal`** 位于 **`vfprintf-internal.o`**。很不幸的是这两个文件还依赖于其他的目标文件，因为它们也有未定义的符号。这些变量和函数分布在 glibc 的各个目标文件之中，如果我们能够将它们收集齐，那么理论上就可以将它们链接在一起，最后跟 hello.o 链接成一个可执行文件。**<font color="red">幸好 ld 链接器会处理这一切烦琐的事务，自动寻找所需要的符号及它们所在的目标文件，将这些目标文件从 `libc.a` 中解压出来，最终将它们链接在一起成为一个可执行文件</font>**。

那么我们可不可以就这样认为：将 **`hello.o`** 和 **`libc.a`** 链接起来就可以得到可执行文件呢？理论上这样就可以了。但是实际上现在 Linux 系统上的库比较复杂，当我们编译和链接一个普通 C 程序的时候，不仅需要 C 语言库 libc，而且还有其他一些辅助性质的目标文件和库。我们可以使用下面的 GCC 命令编译 hello.c，**`-verbose`** 表示将整个编译链接过程的中间步骤打印出来。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -static --verbose -fno-builtin hello.c
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04) 
COLLECT_GCC_OPTIONS='-static' '-v' '-fno-builtin' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
 /usr/lib/gcc/x86_64-linux-gnu/11/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpdir a- -dumpbase hello.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fno-builtin -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/cc9qFyJa.s
GNU C17 (Ubuntu 11.4.0-1ubuntu1~22.04) version 11.4.0 (x86_64-linux-gnu)
	compiled by GNU C version 11.4.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/11/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/11/../../../../x86_64-linux-gnu/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/11/include
 /usr/local/include
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
GNU C17 (Ubuntu 11.4.0-1ubuntu1~22.04) version 11.4.0 (x86_64-linux-gnu)
	compiled by GNU C version 11.4.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: 50eaa2331df977b8016186198deb2d18
COLLECT_GCC_OPTIONS='-static' '-v' '-fno-builtin' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
 as -v --64 -o /tmp/ccSdCJ9N.o /tmp/cc9qFyJa.s
GNU汇编版本 2.38 (x86_64-linux-gnu) 使用BFD版本 (GNU Binutils for Ubuntu) 2.38
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-static' '-v' '-fno-builtin' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
 /usr/lib/gcc/x86_64-linux-gnu/11/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/11/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper -plugin-opt=-fresolution=/tmp/ccEI4MG5.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --build-id -m elf_x86_64 --hash-style=gnu --as-needed -static -z relro /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginT.o -L/usr/lib/gcc/x86_64-linux-gnu/11 -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. /tmp/ccSdCJ9N.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/11/crtend.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crtn.o
COLLECT_GCC_OPTIONS='-static' '-v' '-fno-builtin' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
```

上面首先第一步是调用 cc1 程序，这个程序实际上就是 GCC 的 C 语言编译器，它将 hello.c 编译成一个临时的汇编文件 /tmp/cc9qFyJa.s。

```c{.line-numbers}
 /usr/lib/gcc/x86_64-linux-gnu/11/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpdir a- -dumpbase hello.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fno-builtin -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/cc9qFyJa.s
```

然后调用 as 程序，as 程序是 GNU 的汇编器，它将 **`/tmp/cc9qFyJa.s`** 汇编成临时目标文件 **`/tmp/ccSdCJ9N.o`**，这个 **`/tmp/ccSdCJ9N.o`** 实际上就是前面的 **`hello.o`**。

```c{.line-numbers}
as -v --64 -o /tmp/ccSdCJ9N.o /tmp/cc9qFyJa.s
```

接着最后关键的步骤是最后一步，GCC 调用 collect2 程序来完成最后的链接：但是按照我们之前的理解，链接过程应该由 ld 链接器来完成，实际上 collect2 可以看作是 ld 链接器的一个包装，它会调用 ld 链接器来完成对目标文件的链接，然后再对链接结果进行一些处理，主要是收集程序与程序初始化相关的信息并且构造初始化的结构。在这里，可以简单地把 collect2 看作是 ld 链接器。

```c{.line-numbers}
 /usr/lib/gcc/x86_64-linux-gnu/11/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/11/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper -plugin-opt=-fresolution=/tmp/ccEI4MG5.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --build-id -m elf_x86_64 --hash-style=gnu --as-needed -static -z relro /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginT.o -L/usr/lib/gcc/x86_64-linux-gnu/11 -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. /tmp/ccSdCJ9N.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/11/crtend.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crtn.o
```

可以看到最后一步中，至少有下列几个库和目标文件被链接入了最终可执行文件：

```c{.line-numbers}
crt1.o
crti.o
crtend.o
crtn.o
crtbeginT.o
```

## 5.链接过程控制

### 5.1 链接控制脚本

绝大部分情况下，我们使用链接器提供的默认链接规则对目标文件进行链接。这在一般情况下是没有问题的，但对于一些特殊要求的程序，比如操作系统内核、BIOS（Basic Input Output System）或一些在没有操作系统的情况下运行的程序（如引导程序 Boot Loader 或者嵌入式系统的程序等），以及另外的一些必须要特殊的链接过程的程序，**它们往往有一些特殊的条件，例如要指定输出文件的各个段起始地址、段的名称、段存放的顺序等**。

由于链接过程有很多内容要确定：使用哪些目标文件？使用哪些库文件？是否在最后可执行文件中保留调试信息、输出文件格式（可执行文件还是动态链接库）？还要考虑是否要导出某些符号以供调试或跟程序本身或其他程序使用等。

>操作系统内核，从本质上来讲，它本身也是一个程序。比如 Windows 的内核 ntoskrnl.exe 就是一个我们平常看到的 PE 文件，它的物理位置在 **`WINDOWS\System32\ntoskrnl.exe`**。很多人误以为 Windows 操作系统的内核很庞大，由很多文件组成。这是一个误解，其实真正的 Windows 内核就是这个文件。

链接器一般都会提供多种控制整个链接过程的方法，以用来产生用户所须要的文件。一般链接器有如下三种方法：

- **<font color="red">使用命令行来给链接器指定参数</font>**，我们前面所使用的 ld 的 **`-o`**、**`-e`** 参数就属于这类；
- **<font color="red">将链接指令参数放在目标文件里面</font>**，编译器经常会通过这种方法向链接器传递指令。方法也比较常见，比如 VISUAL C++ 编译器会把链接参数放在 PE 目标文件的 drectve 段用来传递参数；
- **<font color="red">使用链接控制脚本</font>**，最为灵活、最为强大的链接控制方法。

前面我们在使用 ld 链接器的时候，没有指定链接控制脚本，实际上 ld 在用户没有指定链接脚本的时候会使用默认链接脚本。我们可以使用下面的命令行来查看 ld 默认的链接脚本：

```c{.line-numbers}
ld --verbose
```

不同的机器平台、输出文件格式都有相应的链接脚本。ld 会根据命令行要求使用相应的链接脚本文件来控制链接过程，当我们使用 ld 来链接生成一个可执行文件的时候，它就会使用 **`elf_i386.x`** 作为链接控制脚本；当我们使用 ld 来生成一个共享目标文件的时候，它就会使用 **`elf_i386.xs`** 作为链接控制脚本。当然，为了更为精确地控制链接过程，我们可以自己写一个脚本，然后指定该脚本为链接控制脚本。比如可以使用 -T 参数：

```c{.line-numbers}
ld -T link.script
```

### 5.2 最小的程序

为了演示链接的控制过程，我们接着要做一个最小的程序：这个程序的功能是在终端上输出 Hello world!，我们这里要演示的程序与之前所学的稍微有所不同：

- 首先，经典的 helloworld 程序使用了 printf 函数，该函数是系统 C 语言库的一部分。**<font color="red">为了使用该函数，我们必须在链接时将 C 语言库与程序的目标文件链接产生最终可执行文件</font>**。我们希望小程序能够脱离 C 语言运行库，使得它成为一个独立于任何库的纯正的程序。
- **<font color="red">其次，经典的 helloworld 由于使用了 C 语言库，所以必须有 main 函数</font>**。我们知道一般程序的入口在库的 **`_start`**，**由库负责初始化后调用 main 函数来执行程序的主体部分**。小程序使用 nomain 作为整个程序的入口。

接着，经典的 helloworld 会产生多个段：main 程序的指令部分会产生 **`.text`** 段，字符串常量 **`Hello world!\n`** 会被放在数据段或只读数据段，还有 C 库所包含的各种段。为了演示 ld 链接脚本的控制过程，我们将小程序的所有段都合并到一个叫 tinytext 的段，注意这个段是我们任意命名的，是由链接脚本来控制链接过程生成的。TinyHelloWorld.c 的源代码如下：

```c{.line-numbers}
char* str = "Tiny Hello World!\n";

void print() {
	asm("movl $18,%%edx \n\t"
        "movl %0, %%ecx \n\t"
        "movl $1,%%ebx \n\t"
        "movl $4, %%eax \n\t"
        "int $0x80\n\t"
        ::"r"(str):"edx","ecx","ebx");
}

void exit() {
    asm("movl $42,%ebx  \n\t"
        "movl $1,%eax   \n\t"
        "int $0x80      \n\t");
}

void nomain() {
    print();
    exit();
}
```

从源代码我们可以看到，程序入口为 **`nomain()`** 函数，然后该函数调用 **`print()`** 函数，打印 Hello World，接着调用 **`exit()`** 函数，结束进程。这里的 print 函数使用了 Linux 的 write 系统调用，**`exit()`** 函数使用了 exit 系统调用，这里使用了 GCC 内联汇编。

汇编程序模板由汇编指令组成。每个操作数由操作数约束字符串描述，后跟括号中的 C 表达式。**<font color="blue">冒号将汇编程序模板与第一个输出操作数分隔开，另一个冒号将最后一个输出操作数与第一个输入分开，如果有的话</font>**。逗号分隔每个组中的操作数。如果没有输出操作数但是有输入操作数，则必须在输出操作数所在的位置周围放置两个连续的冒号。举例说明：

```c{.line-numbers}
    int a=10, b;
    asm ("movl %1, %%eax; 
          movl %%eax, %0;"
          :"=r"(b)        /* output */
          :"r"(a)         /* input */
          :"%eax"         /* clobbered register */
        );       
```

这里我们做的是使用汇编指令使 'b' 的值等于 'a' 的值。以下是一些值得注意的点：

- b 是输出操作数，由 %0 引用，a 是输入操作数，由 %1 引用；
- r 是对操作数的约束。**目前 r 向 GCC 表示使用任何寄存器来存储操作数**。输出操作数约束应该有一个约束修饰符 =。而这个修饰符表示它是输出操作数并且是只写的；寄存器名称前面有两个 % 的前缀。这有助于 GCC 区分操作数和寄存器。操作数具有单个 % 作为前缀；
- 第三个冒号后的 clobbered register 列表中的寄存器 %eax 告诉 GCC，%eax 的值将在 asm 内修改，因此 GCC 不会使用该寄存器来存储任何其他值；

```c{.line-numbers}
    asm(  "movl $13,%%edx  \n\t"
          "movl %0,%%ecx   \n\t"
          "movl $0,%%ebx   \n\t"
          "movl $4,%%eax   \n\t"
          "int $0x80       \n\t"
          :: "r"(str) : "edx","ecx","ebx");
```

以上第一个内联汇编调用了 **`sys_write`** 函数，首先 int 0x80 触发系统调用，系统调用号 4 表示 **`sys_write`**，**`%eax`** 寄存器表示系统调用号，**`%ebx`** 表示文件描述符，stdin=0，stdout=1，这里是向屏幕输出字符，因此应该为 1，**`%ecx`** 寄存器表示要输出的字符串地址，即 str，**`%edx`** 表示字符串的长度，**`%0`** 表示输入操作数 str。

**`sys_write`** 函数的原型如下所示：

```c{.line-numbers}
#include <unistd.h>
ssize_t write(int fd, const void buf[.count], size_t count);
```

exit 函数使用 **`int 0x80`** 触发系统调用，系统调用号为 1，表示调用 **`sys_exit`** 函数，其中 **`%eax`** 表示调用号为 1，**`%ebx`** 表示返回状态码为 42。

```c{.line-numbers}
    asm(  "movl $42,%ebx  \n\t"
          "movl $1,%eax   \n\t"
          "int $0x80      \n\t" );
```

exit 函数的原型如下所示：

```c{.line-numbers}
#include <unistd.h>
void exit(int status);
```

>这里要调用 EXIT 结束程序是因为如果是普通程序，main 函数结束后控制权返回给系统库，由系统库负责调用 EXIT，退出进程。我们这里的 **`nomain`** 结束后系统控制权不会返回，可能会执行到 **`nomain()`** 后面不正常的指令，最后导致程序异常退出。

我们首先使用普通命令行的方式编译和链接 **`TinyHelloWorld.c`**：

```c{.line-numbers}
$ gcc -c -fno-builtin TinyHelloWorld.c -m32
$ ld -static -e nomain -o TinyHelloWorld TinyHelloWorld.o -m elf_i386
```

第一步是使用 GCC 将 **`TinyHelloWorld.c`** 编译成 **`TinyHelloWorld.o`**，接着使用 ld 将 **`TinyHelloWorld.o`** 链接成可执行文件 TinyHelloWorld。这里 GCC 和 ld 的参数含义如下：

- **`-fno-builtin`**：GCC 编译器提供了很多内置函数（Built-in Function），它会把一些常用的 C 库函数替换成编译器内部的内置函数，以达到优化的功能。比如 GCC 会将有字符串参数的 printf 函数替换成 puts，以节省解析的时间。**`exit()`** 函数也是 GCC 的内置函数之一，所以我们要使用 **`-fno-builtin`** 来关闭 GCC 内置函数功能；
- static：这个参数表示 ld 将使用静态链接的方式来链接程序，而不是使用默认的动态链接方式；
- **`-e nomain`**：这是指定程序的入口函数为 nomain，这个参数就是将 ELF 文件头 **`Elf32_Ehdr`** 的 **`e_entry`** 设置为 nomain 函数的地址；

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ gcc -c -fno-builtin tiny_hello_world.c -m32 -fno-pic
monica@monica-virtual-machine:~/linkers_loaders$ ld -static -e nomain tiny_hello_world.o -o tiny_hello_world -m elf_i386 -s
monica@monica-virtual-machine:~/linkers_loaders$ ./tiny_hello_world 
Tiny Hello World!
```

### 5.3 使用 ld 链接脚本

在使用 gcc 编译时，还需要使用 **`-fno-PIC`** 指令，否则会多出 **`.got.plt`** 段。还有 **`.shstrtab`**、**`.symtab`** 和 **`.strtab`** 这 3 个字符串表，在使用 ld 链接时，使用 -s 去除掉，就可以将其中的 **`.symtab`** 和 **`.strtab`** 去掉，这样就剩下如下 6 个段：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -S tiny_hello_world
There are 7 section headers, starting at offset 0x3064:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        08049000 001000 000044 00  AX  0   0  1
  [ 2] .rodata           PROGBITS        0804a000 002000 000013 00   A  0   0  1
  [ 3] .eh_frame         PROGBITS        0804a014 002014 00007c 00   A  0   0  4
  [ 4] .data             PROGBITS        0804c000 003000 000004 00  WA  0   0  4
  [ 5] .comment          PROGBITS        00000000 003004 00002b 01  MS  0   0  1
  [ 6] .shstrtab         STRTAB          00000000 00302f 000032 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
```

由于 **`.text`**、**`.rodata`**、**`.data`** 都是只读的，因为 .data 保存的是 str 全局变量，看上去它是可写的，但是我们并没有在程序中改写该变量，所以实际上它也是只读的，因此可以将它们都合并到一个 tinytext 段中。同时 **`.eh_frame`** 段就是记录函数调用栈的布局信息，用于异常处理（如 C++ 的 try/catch）或调试时的栈回溯，我们需要在链接脚本文件中加上 **`/DISCARD/ : { *(.eh_frame) }`** 将其去除掉。**`.comment`** 保存的是编译器和系统版本信息，这些信息也是只读的。由于 .comment 里面存储的数据并不关键，对于程序的运行没有作用，所以可以将其弃用。这样最终只剩下 **`.tinytext`** 和 **`.shstrtab`** 这 2 个表。

无论是输出文档还是输入文档，它们的主要数据就是文件中的各个段，我们把输入文档中的段称为输入段（Input Sections），输出文档中的段称为输出段（Output Sections）。简单来说，控制链接过程是控制输入段如何变成输出段，比如哪些输入段需要合并一个输出段，哪些输入段要丢弃；指定输出段的名字、加载地址、属性等等。

我们可以使用如下的链接脚本 tiny_hello_world.lds（**一般链接脚本名都以 lds 作为扩展名 ld script**） 来对程序的链接结果进行控制：

```c{.line-numbers}
ENTRY(nomain)

SECTIONS {
	. = 0x08049000 + SIZEOF_HEADERS;
	tinytext : {*(.text) *(.data) *(.rodata)}
	/DISCARD/ : {*(.comment)}
	/DISCARD/ : { *(.eh_frame) }
}
```

这是一个非常简单的链接脚本，第一行的 **`ENTRY(nomain)`** 指定了程序的入口为 **`nomain()`** 函数；后面的 SECTIONS 命令一般是链接脚本的主体，这个命令指定了各类输入段到输出段的变换，SECTIONS 后面紧跟着的一对大号字母面包含了 SECTIONS 变换规则，其中有三条语句，每条语句一行。第一条是赋值语句，后面两条是段转换规则，它们的含义如下：

- **`.= 0x08049000 + SIZEOF_HEADERS`** 第一条赋值语句的意思是将当前虚拟地址值设置成 **`0x08049000 + SIZEOF_HEADERS`**，**`SIZEOF_HEADERS`** 是 Size of ELF header 和 Size of program headers 之和。确切地说为 **`Size of ELF header + Number of program headers * Size of program headers`**，**`.`** 表示当前虚拟地址，**<font color="red">因为这条语句后紧跟着段 tinytext，所以 tinytext 段的起始虚拟地址即为 `0x08049000 + SIZEOF_HEADERS`</font>**。
- **`tinytext : {*(.text) *(.data) *(.rodata)}`** 第二条是一个段转换规则，它的意思即为所有输出文件中的名字为 **`.text`**、**`.data`** 或 **`.rodata`** 的段依次合并到输出文件的 **`tinytext`** 段。
- **`/DISCARD/ : {*(.comment)}`** 第三条规则为：将所有输入文件中的名字为 **`.comment`** 段丢弃，不保存到输出文件中。

重新链接时启用上述链接控制脚本，最后生成的执行程序中只有 **`tinytext`** 和 **`.shstrtab`**。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ ld -static -e nomain tiny_hello_world.o -o tiny_hello_world -m elf_i386 -s -T tiny_hello_world.lds
monica@monica-virtual-machine:~/linkers_loaders$ readelf -S tiny_hello_world
There are 3 section headers, starting at offset 0x104:

节头：
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] tinytext          PROGBITS        08048094 000094 00005b 00 WAX  0   0  4
  [ 2] .shstrtab         STRTAB          00000000 0000ef 000014 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
```

### 5.4 ld 链接脚本语法简介

链接脚本由一系列语句组成，**<font color="red">语句分两种，一种是命令语句，另外一种是赋值语句</font>**。我们前面的链接脚本里面的 **`ENTRY(nomain)`** 就是命令语句；而 **`. = 0x08480000 + SIZEOF_HEADERS`** 则是一个赋值语句。所以说链接脚本语言像 C 语言，主要有如下几点相似之处。

- 语句之间使用分号 **`;`** 作为分割符。原则上讲语句之间都要以分号作为分割符，但是对于命令语句来说也可以使用换行来结束该语句，对于赋值语句来说必须以分号结束；
- 表达式与运算符。脚本语言的语句中可以使用 C 语言类似的表达式和运算符符号，比如 **`+、-、*、/、+=、-=、*=`** 等，甚至包括位操作符 **`&、|、<<、>>`**，等这些位操作符；
- 注释和字符引用。使用 /* */ 作为注释。脚本文件中使用到的文件名，格式名或段名等凡是包含 **`;`** 或其他的分隔符的，都要使用双引号将该名字全称引用起来，如果文件名包含引号，则很不幸，无法处理；

命令语句一般的格式是由一个关键字和紧跟其后的参数数组组成。例如前面的 **`TinyHelloWorld.lds`** 就是由两个命令语句组成：一个 **`ENTRY`** 命令语句和一个 **`SECTIONS`** 语句，**`ENTRY`** 和 **`SECTIONS`** 为这两个语句的关键字。 其中 **`SECTIONS`** 语句比较复杂，它又包含了一个赋值语句及 **`SECTIONS`** 语句所持有的地址规则。

下面是一些常用的命令语句：

- **`ENTRY(symbol)`**：指定符号 symbol 的值为入口地址。**<font color="red">入口地址即程序执行的第一条用户空间命令的指令所在程序地址空间的位置</font>**，它被指定在 ELF 文件头 **`Elf32_Ehdr`** 的 **`e_entry`** 成员中。ld 有多种方法可以设置进入入口地址，它们之间的优先级按以下顺序排列（越前优先级越高）：ld 命令行的 **`-e`** 选项、链接脚本中的 **`ENTRY(symbol)`** 命令、如果定义了 **`_start`** 符号，使用 **`_start`** 符号、如果存在 **`.text`** 段，使用 **`.text`** 段的第一字节的地址。
- **`STARTUP(filename)`**：将文件 filename 作为链接过程中的第一个输入文件。
- **`SEARCH_DIR(path)`**：将路径 path 加入到 ld 链接器的库查找目录。ld 会根据指定的目录去查找相应的库。跟 -Lpath 命令有着相同的作用。
- **`INPUT(file, file, …)`**：将指定文件作为链接过程中的输入文件。
- **`INCLUDE filename`**：将指定文件包含进本链接脚本。类似于 C 语言中的 #include 预处理；
- **`PROVIDE(symbol)`**：**<font color="red">在链接脚本中定义某个符号。该符号可以在程序中被引用</font>**。其实前文提到的特殊符号都是由系统默认的链接脚本通过 PROVIDE 命令定义在脚本中的；

SECTIONS 命令格式为：

```c{.line-numbers}
SECTIONS
{
  ...
  secname : { contents }
  ...
}
```

secname 表示输出段的段名，secname 后面必须有一个空格符，这样使得输出段段名不会有歧义，**后面紧跟着的 contents 描述了一套规则和条件，它表示符合这种条件的输入段将合并到这个输出段中**。输出段名的命名方法必须符合输出文件格式的要求，比如，如果使用 ld 生成一个 **`a.out`** 格式的文件，那么输出段名就不能使用除 **`.text`**，**`.data`** 和 **`.bss`** 之外的任何名字，因为 **`a.out`** 格式规定段名只允许这三个名字。

有一个特殊的段名叫 **`/DISCARD/`**，如果使用这个名称作为输出段名，那么所有符合后面 contents 所规定的条件的段都会被丢弃，不输出到输出文件中。

接着，我们最应该关注的是 contents 这个规则。contents 中可以包含若干个条件，每个条件之间以空格隔开，如果输入段符合这些条件中的任意一个就表示这个输入段符合 contents 规则。条件的写法如下：

```c{.line-numbers}
filename(sections)
```

filename 表示输入文件名，sections 表示输入段名。让我们举几个条件的例子来看：

- **`file1.o(.data)`** 表示输入文件名为 **`file1.o`** 的文件中名为 **`.data`** 的段符合条件；
- **`file1.o(.data .rodata)`** 表示输入文件名为 **`file1.o`** 的文件中名为 **`.data`** 或 **`.rodata`** 的段符合条件；
- **`file1.o`** 如果直接指定文件名而省略后面的小括号和段名，则表示 **`file1.o`** 的所有段符合条件；
- **`*(.data)`** 所有输入文件中的名字符合 **`.data`** 的文件符合条件。 * 是通配符，类似于正则表达式中的 *；