# 目标文件

## 4.链接的接口——符号

**<font color="red">在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用</font>**。比如目标文件 B 要用到了目标文件 A 中的函数 foo，那么我们就称**目标文件 A 定义（Define）了函数 foo，称目标文件 B 引用（Reference）了目标文件 A 中的函数 foo**。 这两个概念也同样适用于变量。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

我们可以将符号看作是链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。我们将符号表中的

- 定义在本目标文件的全局符号，可以被其他目标文件引用。比如 **`SimpleSection.o`** 里面的 **`func1`**、**`main`** 和 **`global_init_var`**；
- 在本目标文件中引用的全局符号，却没有定义在本目标文件，这一类叫做外部符号（External Symbol）。比如 **`SimpleSection.o`** 里面的 **`printf`**；
- **段名，这种符号往往由编译器产生，它的值就是该段的起始地址**。比如 **`SimpleSection.o`** 里面的 **`.text`**、**`.data`** 等；
- 局部符号，这类符号只在编译单元内部可见。比如 SimpleSection.o 里面的 **`static_var`** 和 **`static_var2`**。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们；

对于我们来说，最值得关注的就是全局符号，即上面分类中的第一类和第二类。因为链接过程只关心全局符号的相互粘合，局部符号、段名、行号等对于其他目标文件来说是"不可见"的。

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ nm SimpleSection.o
00000000 T foo
00000004 d foo.2
00000000 T func
00000000 D global
00000000 D global_init_var
         U _GLOBAL_OFFSET_TABLE_
00000004 b global_static_var
00000000 B global_uninit_var
00000008 b global_unist_static_var
00000032 T main
         U printf
00000008 d static_var1.1
0000000c b static_var2.0
00000000 T __x86.get_pc_thunk.ax
```

这是我们使用 nm 命令查看 **`SimpleSection.o`** 目标文件中符号表的结果。其中 T 表示该符号位于代码段，通常是函数的定义。d/D 表示该符号位于已初始化的数据段（data section），通常是全局变量的定义。U 表示该符号在当前文件中被引用，但未在当前文件中定义，通常是外部函数或变量。b/B 表示该符号位于未初始化的数据段（bss section），通常是未初始化的全局或者静态变量。

>d/b 表示本地符号（Local Symbol）。**这些符号的作用域被限制在当前编译单元（也就是这个 **`.c`** 文件）之内**，对链接器来说是不可见的。这通常是由 static 关键字修饰的变量。
>D/B 表示全局符号（Global Symbol）。**这些符号对链接器是可见的**，可以被工程中的其他文件引用（extern）。这是默认的链接属性。

### 4.1 ELF 符号表结构

ELF 文件中的符号表往往是文件中的一个段，段名一般叫 **`.symtab`**。符号表的结构很简单，它是一个 **`Elf32_Sym`** 结构（32 位 ELF 文件）的数组。每个 **`Elf32_Sym`** 结构对应一个符号。这个数组的第一个元素，也就是下标 0 的元素为无效的未定义符号。使用 readelf 查看 SimpleSection.o 文件中的符号表如下所示：

```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ readelf -s SimpleSection.o

Symbol table '.symtab' contains 21 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS SimpleSection.c
     2: 00000000     0 SECTION LOCAL  DEFAULT    2 .text
     3: 00000000     0 SECTION LOCAL  DEFAULT    4 .data
     4: 00000000     0 SECTION LOCAL  DEFAULT    7 BAR
     5: 00000004     4 OBJECT  LOCAL  DEFAULT    5 global_static_var
     6: 00000008     4 OBJECT  LOCAL  DEFAULT    5 global_unist_sta[...]
     7: 00000000     0 SECTION LOCAL  DEFAULT    9 .rodata
     8: 00000004     4 OBJECT  LOCAL  DEFAULT    4 foo.2
     9: 00000008     4 OBJECT  LOCAL  DEFAULT    4 static_var1.1
    10: 0000000c     4 OBJECT  LOCAL  DEFAULT    5 static_var2.0
    11: 00000000     0 SECTION LOCAL  DEFAULT   10 .text.__x86.get_[...]
    12: 00000000     4 OBJECT  GLOBAL DEFAULT    6 global
    13: 00000000    16 FUNC    GLOBAL DEFAULT    7 foo
    14: 00000000     0 FUNC    GLOBAL HIDDEN    10 __x86.get_pc_thunk.ax
    15: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    16: 00000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_var
    17: 00000000     4 OBJECT  GLOBAL DEFAULT    5 global_uninit_var
    18: 00000000    50 FUNC    GLOBAL DEFAULT    2 func
    19: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
    20: 00000032    67 FUNC    GLOBAL DEFAULT    2 main
```

**`Elf32_Sym`** 的结构定义如下：

```c{.line-numbers}
typedef struct {
    Elf32_Word st_name;
    Elf32_Addr st_value;
    Elf32_Word st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf32_Half st_shndx;
} Elf32_Sym;
```

这几个成员的定义如下所示：

- **`st_name`**：符号名，这个成员包含了该符号名在字符串表中的下标；
- **`st_value`**：符号相对应的值。这个值跟符号有关，不同的符号，它所对应的值含义不同；
- **`st_size`**：符号大小。对于包含数据的符号，这个值是该数据类型的大小。比如一个 double 型的符号它占用 8 个字节。如果该值为 0，则表示该符号大小为 0 或未知；
- **`st_info`**：符号类型和绑定信息；
- **`st_other`**：该成员目前为 0，没用；
- **`st_shndx`**：符号所在的段；

**（1）符号类型和绑定信息**

该成员的低 4 位表示符号的类型（Symbol Type），高 28 位表示符号的绑定信息（Symbol Binding）。

符号的绑定信息如下所示：

- **`STB_LOCAL`**：局部符号，对于目标文件的外部不可见，对于 C 语言而言，在文件作用域内使用 static 关键字声明的函数或全局变量通常会被编译器赋予 **`STB_LOCAL`** 绑定；
- **`STB_GLOBAL`**：全局符号，外部可见；
- **`STB_WEAK`**：弱符号；

符号的类型如下所示：

- **`STT_NOTYPE`**：未知类型符号；
- **`STT_OBJECT`**：该符号是个数据对象，比如变量、数组等；
- **`STT_FUNC`**：该符号是个函数或其他可执行代码；
- **`STT_SECTION`**：**该符号表示一个段，这种符号必须是 **`STB_LOCAL`** 的**；
- **`STT_FILE`**：该符号表示文件名，**一般都是该目标文件所对应的源文件名，它一定是 **`STB_LOCAL`** 类型的**，并且它的 **`st_shndx`** 一定是 **`SHN_ABS`**；

**（2）符号所在的段**

**<font color="red">如果符号定义在本目标文件中</font>**，那么这个成员表示符号所在的段在段表中的下标；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，**`st_shndx`** 的值有些特殊：

- **`SHN_ABS`**：表示该符号包含了一个绝对的值。比如表示文件名的符号就属于这种类型的；
- **`SHN_COMMON`**：表示该符号是一个 COMMON 块类型的符号，一般来说，未初始化的全局符号定义就是这种类型的；
- **`SHN_UNDEF`**：表示该符号未定义。这个符号号表示该符号在本目标文件被引用到，但是定义在其他目标文件中；

**（3）符号值**

符号值（**`st_value`**）的值有如下几种情况：

- 在目标文件中，如果是符号的定义并且该符号不是 COMMON 块类型的，则 **`st_value`** 表示该符号在段中的偏移。**<font color="red">即符号所对应的函数或变量位于由 **`st_shndx`** 指定的段，偏移 **`st_value`** 的位置</font>**；
- 在目标文件中，如果符号是 COMMON 块类型的（即 **`st_shndx`** 为 **`SHN_COMMON`**），则 **`st_value`** 表示该符号的对齐属性；
- 在可执行文件中，**`st_value`** 表示符号的虚拟地址；

global_uninit_var 和 global_init_var 变量的 **`st_value`** 值为 0，表示在 **`.bss`** 和 **`.data`** 段中距离节起始位置的偏移量均为 0，也就是位于段最开始处。

### 4.2 特殊符号

当我们使用 ld 作为链接器来链接生产可执行文件时，它会为我们定义许多特殊的符号；这些符号并没有在你的程序中定义, 但是你可以直接声明并且引用它, 我们称之为特殊符号。链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，注意，只有使用 ld 链接生产最终可执行文件的时候这些符号才会存在。

- **`__executable_start`**：该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。
- **`_etext`** 或 **`etext`** 或 **`__etext`**，该符号为代码段结束地址，即代码段最末尾的地址。
- **`edata`** 或 **`_edata`**，该符号为数据段结束地址，即数据段最末尾的地址。
- **`_end`** 或 **`end`**，该符号为程序结束地址。

### 4.3 符号修饰和函数签名

C++ 中两个相同名字的函数 func(int) 和 func(double)，尽管函数名相同，但是参数列表不同，这就是函数重载。为了支持 C++ 这些复杂的特性（重载、继承、虚机制、名称空间），发明了符号修饰（Name Decoration）或符号改编（Name Mangling）的机制。比如下面的代码：

```cpp{.line-numbers}
// mangling_test.cpp

// 1. 全局函数重载
int func(int i) { return i; }
float func(float f) { return f; }

// 2. 类与嵌套类
class C {
public: // 设为 public 方便外部调用演示
    int func(int i) { return i; }
    class C2 {
    public:
        int func(int i) { return i; }
    };
};

// 3. 命名空间
namespace N {
    int func(int i) { return i; }
    class C {
    public:
        int func(int i) { return i; }
    };
}

// 4. 主函数调用以确保符号被生成
int main() {
    func(1);
    func(1.0f);
    C c_instance;
    c_instance.func(2);
    C::C2 c2_instance;
    c2_instance.func(3);
    N::func(4);
    N::C nc_instance;
    nc_instance.func(5);
    return 0;
}
```

这段代码中有 6 个同名函数叫 func，只不过它们的返回类型和参数及所在的名称空间不同。我们引入一个术语叫 函数签名（Function Signature），函数签名包含了一个函数的信息，包括函数名，它的参数类型，它所在的类和名称空间及其他信息。

在编译器及链接器处理符号时，它们使用某种 **名称修饰** 的方法，使得每个同函数名对应一个修饰后名称（Decorated Name）。编译器在将 C++ 源代码编译成目标文件时，会将函数和变量的名字进行修饰，形成符号名，也就是说，**<font color="red">C++ 的源代码编译后的目标文件中所使用的符号名是相应的函数和变量的修饰后名称</font>**，C++ 编译器和链接器都使用符号来识别和处理函数和变量。

我们使用 **`gcc manglecpp.cpp -c -o manglecpp.o`** 编译上述 cpp 文件，然后使用 nm 查看修饰后的符号名称，接下来使用 **`nm manglecpp.o | c++filt -t`** 命令查看修饰之前的符号名称。
 
```c{.line-numbers}
monica@monica-virtual-machine:~/linkers_loaders$ nm manglecpp.o
0000000000000034 T main
                 U __stack_chk_fail
0000000000000010 T _Z4funcf
0000000000000000 T _Z4funci
0000000000000000 W _ZN1C2C24funcEi
0000000000000000 W _ZN1C4funcEi
0000000000000000 W _ZN1N1C4funcEi
0000000000000024 T _ZN1N4funcEi
monica@monica-virtual-machine:~/linkers_loaders$ nm manglecpp.o | c++filt -t
0000000000000034 T main
                 U __stack_chk_fail
0000000000000010 T func(float)
0000000000000000 T func(int)
0000000000000000 W C::C2::func(int)
0000000000000000 W C::func(int)
0000000000000000 W N::C::func(int)
0000000000000024 T N::func(int)
```

#### 4.3.1 W 弱符号解析

这里注意，全局函数 **`func(float)`**、**`func(int)`** 以及 **`N::func(int)`** 的类型都是 T 类型，表示位于代码段的强符号，而 **`C::C2::func(int)`**、**`C::func(int)`**、**`N::C::func(int)`** 的类型都是 弱符号 W。

这是因为这 3 个函数都是类的成员函数，根据 C++ 规范，当在函数的声明说明符序列中使用 inline 说明符时，它将函数声明为内联函数。在类/结构体/联合体定义中完整定义的函数，无论是成员函数还是非成员 friend 函数，都隐式地是内联函数。程序中可以有内联函数或变量的多个定义，只要每个定义出现在不同的翻译单元中，并且所有定义都相同。

例如，内联函数或内联变量可以在头文件中定义，该头文件被包含在多个源文件中时，链接器会把这些副本合并为一个，而不是报重复定义错误。这就是对 ODR（One Definition Rule，单一定义规则）的放宽：非内联函数必须在整个程序里只有一个定义；而内联函数可以在多个翻译单元各有一份相同定义。综上，这是为了解决 C++ 的 **单一定义规则（One Definition Rule - ODR）** 头文件（头文件中有类内部实现的成员函数）被多个源文件包含场景下的一个难题。

#### 4.3.2 C++ 名称修饰方法

GCC 的基本 C++ 名称修饰方法如下：所有的符号都以 **`_Z`** 开头；对于嵌套的名字（在名称空间或在类里面的），后面紧跟 N，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以 E 结尾。比如 **`N::C::func`** 经过名称修饰以后就是 **`_ZN1N1C4funcE`**。对于一个函数来说，它的参数列表紧跟在 E 后面，对于 int 类型来说，就是字母 i。

