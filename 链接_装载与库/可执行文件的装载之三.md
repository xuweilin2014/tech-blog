# 可执行文件的装载之三

# 三、main 函数启动

<div align="center">
    <img src="可执行文件的装载_static/9.png" width="900"/>
</div>

## 1.如何进入 main 函数

我们将要构建一个最简单的 C 程序，即一个空的 main 函数，然后我们将查看它的反汇编代码，来探究程序是如何执行到 main 函数的。我们会看到，**程序最先运行的是一个被链接到每个程序中、名为 **`_start`** 的函数，它最终会引导你的程序去运行 main 函数**。

```c{.line-numbers}
// prog1.c
int main() {

}
```

如果你愿意，可以把这份代码保存为 **`prog1.c`**，然后跟着我们一起操作。首先，我会像这样来编译它。在我们尝试用 gdb 调试后续版本（prog2）之前，我们先来看看它的反汇编代码，并借此了解一下我们的程序是如何启动的。

```c{.line-numbers}
gcc -ggdb -o prog1 prog1.c
```

**<font color="red">当你运行一个程序时，无论是通过 shell（命令行）还是 GUI（图形界面），它们都会调用 **`execve()`**，这实际上是执行了 Linux 的 **`execve()`** 系统调用</font>**。简单来说，**`execve()`** 系统调用的作用是为新程序建立一个栈空间，并将 argc（参数数量）、argv（参数数组）和 envp（环境变量）压入这个栈中。文件描述符 0、1 和 2（即 stdin 标准输入、stdout 标准输出和 stderr 标准错误）则会保持 shell 原本为它们设置的状态。

>换句话说，当你执行一个新程序时，这个新程序并不会自己去创建一套全新的标准输入/输出通道，而是直接继承了启动它的那个程序（也就是父进程，通常是命令行 shell）的设置。

同时，加载器（loader）会为你完成大量的工作，比如设置代码和数据的重定位（relocations），以及调用你的预初始化函数（preinitializers）。当这一切都准备就绪后，控制权便通过调用 **`_start()`** 函数正式移交给了你的程序。下面就是从 **`objdump -d prog1`** 的输出中截取的、包含 **`_start`** 函数的部分。

```armasm{.line-numbers}
080482e0 <_start>:
80482e0: 31 ed          xor %ebp,%ebp
80482e2: 5e             pop %esi                                ;%esi -> argc
80482e3: 89 e1          mov %esp,%ecx                           ;%ecx -> argv                           
80482e5: 83 e4 f0       and $0xfffffff0,%esp                 
80482e8: 50             push %eax                               ;%eax -> unknown parameter
80482e9: 54             push %esp                               ;%esp -> aligned stack pointer, stack_end
80482ea: 52             push %edx                               ;%edx -> rtld_fini
80482eb: 68 00 84 04 08 push $0x8048400                         ;$0x8048400 -> fini
80482f0: 68 a0 83 04 08 push $0x80483a0                         ;$0x80483a0 -> init
80482f5: 51             push %ecx                               ;%ecx -> ubp_av/argv
80482f6: 56             push %esi                               ;%esi -> argc
80482f7: 68 94 83 04 08 push $0x8048394                         ;$0x8048394 -> main
80482fc: e8 c3 ff ff ff call 80482c4 <__libc_start_main@plt>
8048301: f4             hlt
```

任何值与自身进行异或（xor）运算，结果都为零。因此，**`xor %ebp, %ebp`** 这条指令的作用就是将 **`%ebp`** 寄存器（基址指针）清零。**<font color="red">这是 ABI（应用程序二进制接口）规范所建议的做法，用于标记整个函数调用栈最外层的"栈帧"（frame）</font>**。这么做的目的是 **`%ebp`** 是栈帧基址指针，它被用来形成一个"栈帧链"，让调试器（如 gdb）或异常处理器能够进行栈回溯（stack unwinding）。**<font color="red">通过将最外层（第一个）栈帧的"前一个"帧指针设置为 0 (NULL)，我们为这个链条提供了一个明确的终点</font>**。当调试器回溯到 **`%ebp`** 为 0 时，它就知道已经到达了调用栈的底部。这就是"标记最外层栈帧（mark the outermost frame）"的意思。

接下来，我们从栈顶弹出一个值。在程序入口处，栈上存放着 argc、argv 和 envp，所以这次 pop 操作会将 argc 存入 **`%esi`** 寄存器。我们只是暂时保存一下它，稍后会再把它压回栈中。

由于我们弹出了 argc，栈顶指针 **`%esp`** 现在正指向 argv。随后的 mov 指令会将 argv 的地址放入 **`%ecx`** 寄存器，而这个过程不会移动栈顶指针。然后，我们将栈顶指针与一个掩码（mask）进行 and（按位与）运算，这个操作会清除掉指针地址的最低四位。这个操作会使栈顶指针向更低的地址移动 0 到 15 个字节，具体移动多少取决于它原来的值。但无论如何，运算的结果都会使它在 16 字节的边界上对齐。进行对齐操作是为了让所有的栈变量都能很好地对齐，从而提升内存和缓存的访问效率。

>System V AMD64 调用约定要求栈必须按 16 字节对齐，也就是说，在调用 call 指令之前 (the end of the input argument area)，**`%rsp`** 指针必须是 16 的倍数（对应 16 进制是最后 1 位是 0）。

在某次具体的运行中，进入 **`_start`** 函数时 **`%esp`** 的值是 **`0xbffff770`**。当我们弹出 argc 后，**`%esp`** 变成了 **`0xbffff774`**。它的地址变大了（请记住，向栈中压入数据会使地址向低内存方向移动，而弹出数据则会使地址向高内存方向移动）。**而在执行完 and 指令后，栈顶指针又回到了 `0xbffff770`**。

## 2.准备调用 **`___libc_start_main`** 函数

接下来，我们开始为 **`__libc_start_main`** 函数准备参数，并将它们压入栈中。第一个被压入栈的值来自 **`%eax`** 寄存器，但它其实是一个无用的"垃圾值"。之所以要压入它，仅仅是因为总共需要传递 7 个有意义的参数，所以必须额外增加这第 8 个值来凑数，以确保栈能维持 16 字节对齐。这个值本身不会有任何实际用途。

**`__libc_start_main`** 这个函数是从 glibc（GNU C 库）中链接而来的。在 glibc 的源码树中，你可以在 **`csu/libc-start.c`** 这个文件里找到它的定义。**`__libc_start_main`** 函数的声明大致如下：

```c{.line-numbers}
int __libc_start_main(int (*main) (int, char**, char**), 
                      int argc, char** ubp_av, 
                      void (*init) (void),
                      void (*fini) (void),
                      void (*rtld_fini) (void),
                      void (*stack_end));
```

因此，我们可以预见到，在调用 **`__libc_start_main`** 函数之前，**`_start`** 函数会按照相反的顺序（即从右至左）将这些参数压入栈中。其所需的参数如下所示：

<div align="center">
    <img src="可执行文件的装载_static/10.png" width="700"/>
</div>

## 3.环境变量在哪？

你有没有注意到，我们并没有从栈上获取 **`envp`**——那个指向我们环境变量的指针？它也不是 **`__libc_start_main`** 函数的参数之一。但我们知道 main 函数的调用形式可以是 **`int main(int argc, char** argv, char** envp)`**，那么这到底是怎么回事呢？

```c{.line-numbers}
void __libc_init_first(int argc, char *arg0, ...) {
    char **argv = &arg0, **envp = &argv[argc + 1];
    __environ = envp;
    __libc_init (argc, argv, envp);
}
```

原来，**`__libc_start_main`** 会调用 **`__libc_init_first`** 函数。该函数会立即利用一个内部的诀窍，找到位于参数数组 (argv) 终止空指针之后的环境变量，然后设置一个名为 **`__environ`** 的全局变量。**<font color="red">在此之后，`__libc_start_main` 每当需要用到环境变量时——包括最后调用 `main` 函数的时候——就会使用这个全局变量</font>**。

在 envp 被找到之后，**`__libc_start_main`** 运用了同样的技巧，而且，惊喜来了！紧跟在 envp 数组的终止空指针之后，还存放着另一个向量——ELF 辅助向量（ELF auxiliary vector），加载器就是通过这个向量来向进程传递一些额外信息的。

要想查看这个向量里到底有什么，一个简单的方法是在运行程序前，先设置 **`LD_SHOW_AUXV=1`** 这个环境变量。下面就是对我们的 prog1 程序执行该操作的结果。**`AT_ENTRY`** 指明了 **`_start`** 函数的入口地址；还有我们的用户 ID（userid）、有效用户 ID（effective userid）以及用户组 ID（groupid）。我们还能看到处理器架构是 686（i686）。

**`AT_PHDR`** 指向 ELF 程序头（program header）的位置。这个程序头包含了程序所有段（segment）在内存中的位置、重定位条目（relocation entries）的信息，以及加载器（loader）运行所需要知道的任何其他信息。而 **`AT_PHENT`** 则指明了程序头中每个条目（entry）的大小（以字节为单位）。

```c{.line-numbers}
$ LD_SHOW_AUXV=1 ./prog1
AT_SYSINFO: 0xe62414
AT_SYSINFO_EHDR: 0xe62000
AT_HWCAP: fpu vme de pse tsc msr pae mce cx8 apic
mtrr pge mca cmov pat pse36 clflush dts
acpi mmx fxsr sse sse2 ss ht tm pbe
AT_PAGESZ: 4096
AT_CLKTCK: 100
AT_PHDR: 0x8048034
AT_PHENT: 32
AT_PHNUM: 8
AT_BASE: 0x686000
AT_FLAGS: 0x0
AT_ENTRY: 0x80482e0
AT_UID: 1002
AT_EUID: 1002
AT_GID: 1000
AT_EGID: 1000
AT_SECURE: 0
AT_RANDOM: 0xbff09acb
AT_EXECFN: ./prog1
AT_PLATFORM: i686
```

## 4.**`__libc_start_main`** 函数

下面的 **`__libc_start_main`** 函数是精简后的伪代码：

```c{.line-numbers}
/* Note: the fini parameter is ignored here for shared library.  It  
   is registered with __cxa_atexit.  This had the disadvantage that  
   finalizers were called in more than one place.  */  
STATIC int  
LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),  
         int argc, char *__unbounded *__unbounded ubp_av,  
#ifdef LIBC_START_MAIN_AUXVEC_ARG  
         ElfW(auxv_t) *__unbounded auxvec,  
#endif  
         __typeof (main) init,  
         void (*fini) (void),  
         void (*rtld_fini) (void), void *__unbounded stack_end)  
{  
  ...  
  /* Register the destructor of the dynamic linker if there is any.  */  
  if (__builtin_expect (rtld_fini != NULL, 1))  
    __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);  
  
  /* Call the initializer of the libc.  This is only needed here if we  
     are compiling for the static library in which case we haven't  
     run the constructors in `_dl_start_user'.  */  
  __libc_init_first (argc, argv, __environ);  
  
  /* Register the destructor of the program, if any.  */  
  if (fini)  
    __cxa_atexit ((void (*) (void *)) fini, NULL, NULL);  
  
  /* Call the initializer of the program, if any.  */  
  if (init)  
    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);  
  
  /* Nothing fancy, just call the function.  */  
  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);  
  
  exit (result);  
}  
```

**`crt1.o`** 中包含一个名为 **`_start`** 的入口点，这是操作系统内核执行完 **`execve`** 系统调用后跳转到的第一个用户空间地址。**`_start`** 的主要工作非常简单：

1. 从栈上准备好 argc、argv 等参数；
2. 将 main、init、fini 等函数的地址作为参数压栈；
3. 调用 **`__libc_start_main`**；

因此，**`__libc_start_main`** 函数是被 **`_start`** 调用的。

### 4.1 注册 rtld_fini 函数

#### 4.1.1 **`__cxa_atexit`** 函数

**`__cxa_atexit`** 是一个标准的、在 C++ ABI (Application Binary Interface) 中定义的函数，用于注册一个在程序退出时要调用的函数。**`atexit()`** 函数通常就是对 **`__cxa_atexit`** 的一个简单封装。

**`__cxa_atexit()`** registers a function to be called by exit or when a shared library is unloaded. The **`__cxa_atexit()`** function is used to implement **`atexit()`**, as described in ISO POSIX (2003). **<font color="red">Calling `atexit(func)` from the statically linked part of an application shall be equivalent to `__cxa_atexit(func, NULL, NULL)`</font>**。

C++ 标准规定，当程序退出时，全局对象的析构函数必须以其构造顺序的逆序被调用。为了实现这一点，大多数编译器和运行库都通过调用 C 标准库的 atexit 函数来注册这些析构函数。文档如下：

>The C++ Standard requires that destructors be called for global objects when a program exits in the opposite order of construction. Most implementations have handled this by calling the C library atexit routine to register the destructors. This is problematic because **the 1999 C Standard only requires that the implementation support 32 registered functions**, although most implementations support many more. More important, **it does not deal at all with the ability in most implementations to remove [Dynamic Shared Objects] from a running program image by calling dlclose prior to program termination**.
>The API specified below is intended to provide standard-conforming treatment during normal program exit, which includes executing atexit-registered functions in the correct sequence relative to constructor-registered destructors, and reasonable treatment during early DSO unload (e.g. dlclose).
>As described in the Itanium™ C++ ABI, __cxa_atexit() registers a destructor function to be called by exit() or when a shared library is unloaded. When a shared library is unloaded, **<font color="red">any destructor function associated with that shared library, identified by `dso_handle`, shall be called with the single argument arg, and then that function shall be removed, or marked as complete, from the list of functions to run at `exit()`</font>**. On a call to exit(), any remaining functions registered shall be called with the single argument arg. Destructor functions shall always be called in the reverse order to their registration (i.e. the most recently registered function shall be called first).

从文档可知，**`__cxa_atexit`** 要解决 **`atexit`** 函数的两个痛点，第一个是数量限制，C 标准对 **`atexit`** 的要求很低，只保证至少支持 32 个函数的注册。在一个大型的、包含众多库和全局对象的复杂 C++ 程序中，这个数量很容易被突破。

第二个是动态库卸载问题，这个是更严重、更根本的问题。**`atexit`** 注册的函数形成一个全局的"清理列表"，**<font color="red">整个列表只会在程序完全退出时才会被执行，它无法处理程序运行期间的动态事件</font>**。

假设你的程序是一个插件化的服务器，通过 **`dlopen()`** 加载了一个插件（一个 **`plugin.so`** 动态库）。这个插件里定义了一些全局对象。后来，你决定卸载这个插件，于是调用了 **`dlclose()`**。插件的析构函数已经被注册到了全局的 **`atexit`** 列表中，**`dlclose`** 会卸载插件的代码和数据，但析构函数的指针还留在 **`atexit`** 列表中。等到很久以后主程序退出时，**`exit()`** 函数会尝试去调用这个指针，而此时它指向的地址早已是无效内存，导致程序崩溃（段错误）。

因此可以使用 **`__cxa_atexit`**，其函数原型为：

```c{.line-numbers}
int __cxa_atexit(void (*func)(void *), void *arg, void *dso_handle);
```

- **`func`**：要注册的析构函数指针；
- **`arg`**：传递给析构函数的参数；
- **`dso_handle`**：由链接器为每个可执行/共享对象提供的句柄，用来标识"这个回调属于哪个 DSO"（是属于主程序、liba.so 还是 libb.so）。这样在 **`dlclose()`** 卸载某库时会调用 **`__cxa_finalize(dso)`**，运行时能只调用该 DSO 库登记的析构函数并将其从全局列表剔除；进程 **`exit()`** 时再对余下析构函数按 LIFO 顺序调用。

>**`__cxa_finalize`** 函数的原型为 **`void __cxa_finalize(void * d);`**
>When **`__cxa_finalize(d)`** is called, it shall walk the termination function list, **<font color="red">calling each in turn if d matches the handle of the termination function entry</font>**. If d is NULL, it shall call all the termination funtions. Multiple calls to **`__cxa_finalize`** shall not result in calling termination function entries multiple times; the implementation may either remove entries or mark them finished. The termination functions shall always be called in the reverse order of their registration (i.e. the most recently registered function shall be called first).

No user interface to **`__cxa_atexit`** is supported, so the user is not able to register an atexit function with a parameter or a home DSO. 出于可移植性与安全性考虑，不要在用户代码中直接调用 **`__cxa_atexit`**。普通开发者无法提供 **`dso_handle`** 这个参数，这是一个由 **工具链（编译器和链接器）** 在幕后管理的概念。

#### 4.1.2 **`__builtin_expect`** 函数

```c{.line-numbers}
  /* Register the destructor of the dynamic linker if there is any.  */  
  if (__builtin_expect (rtld_fini != NULL, 1))  
    __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);  
```

**`__libc_start_main`** 函数首先使用 GCC/Clang 的一个编译器内置函数 **`__builtin_expect(condition, expected_value)`**，给编译器提供分支预测的提示。**`__builtin_expect(rtld_fini != NULL, 1)`** 是在告诉编译器，**`rtld_fini != NULL`** 这个条件极有可能为真（因为绝大多数现代程序都是动态链接的）。这有助于编译器优化指令流水线，是一个微小的性能优化。

>**`__builtin_expect`** Indicates that an expression is likely to evaluate to a specified value. The compiler may use this knowledge to direct optimizations. If the expression does not actually evaluate at run time to the predicted value, performance may suffer. Therefore, this built-in function should be used with caution.

#### 4.1.3 注册 **`rtld_fini`** 函数

```c{.line-numbers}
  /* Register the destructor of the dynamic linker if there is any.  */  
  if (__builtin_expect (rtld_fini != NULL, 1))  
    __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);  
```

所以如果 **`rtld_fini`** 存在（即程序是动态链接的），就把它注册到"退出函数列表"中。**`exit()`** 函数在被调用时，会以"后进先出"（LIFO）的顺序调用这个列表里的所有函数。

### 4.2 注册 fini 函数

```c{.line-numbers}
    /* Register the destructor of the program, if any.  */  
    if (fini)  
        __cxa_atexit ((void (*) (void *)) fini, NULL, NULL);
```

这里将 fini 函数指针（指向 **`__lib_csu_fini`** 函数）同样使用 **`__cxa_atexit`** 注册到退出函数列表。当 main 程序退出，调用 exit() 函数，继而回调注册的退出函数列表，其中就有 **`__lib_csu_fini`** 函数，最终调用 **`__do_global_dtors_aux`** 函数，逐个调用析构函数 destructor。

### 4.3 调用 init 函数

```c{.line-numbers}
    /* Call the initializer of the program, if any.  */
    if (init)
        (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);
```

这是调用 main 之前的最后一步准备工作，实际调用的为 **`__lib_csu_init`** 函数，最终依次调用 **`__gmon_start_`**、**`frame_dummy`**、**`__do_global_ctors_aux`** 函数，并且 **`__do_global_ctors_aux`** 函数会执行所有全局构造函数（即所有用 **`__attribute__((constructor))`** 修饰的函数）。

### 4.4 调用 main 函数

```c{.line-numbers}
    /* Nothing fancy, just call the function.  */  
    result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);  
```

在完成了所有铺垫工作之后，**`__libc_start_main`** 会调用我们自己写的 main 函数，并将 argc 和 argv 等参数传递给它，main 函数的返回值被保存在 result 变量中。

### 4.5 调用 exit 函数

```c{.line-numbers}
    exit (result); 
```

这里调用 **`exit()`** 函数，执行的动作包括：调用退出处理函数、刷新 **`stdio`** 流缓冲区和关闭文件描述符、执行 **`_exit()`** 系统调用。在调用退出处理函数时，就会回调 **`__lib_csu_fini`**，最终调用 **`__do_global_dtors_aux`** 函数，逐个调用析构函数 destructor。

## 5.关于 init 参数的调用

**`__libc_start_main`** 函数接收的 init 函数指针参数，实际上指向了 **`__libc_csu_init`** 函数，这个函数也被链接到了我们的程序里。它是由一个 C 程序编译而成的，它的 C 语言代码与下面的示例类似（只是实际的源码中为了兼容性，包含了大量的 **`#ifdef`** 预处理指令）。

```c{.line-numbers}
void __libc_csu_init (int argc, char **argv, char **envp) {
    _init();
    const size_t size = __init_array_end - __init_array_start;
    for (size_t i = 0; i < size; i++)
        (*__init_array_start [i]) (argc, argv, envp);
}
```

这个函数对我们的程序而言至关重要，因为它就是我们可执行文件自身的构造函数。你可能会说："等等！我们写的又不是 C++！"。是的，你说的没错。但"构造函数"和"析构函数"这些概念并非 C++ 所独有，实际上，它们在 C++ 出现之前就已经存在了！我们的可执行文件，以及其他所有可执行文件，都会获得一个 C 语言层面的构造函数 **`__libc_csu_init`** 和一个 C 语言层面的析构函数 **`__libc_csu_fini`**。在这个构造函数内部，程序会去寻找全局的 C 语言层面的构造函数，并调用它找到的所有这类函数。

下面就是为 **`__libc_csu_init`** 函数生成的汇编代码。

```armasm{.line-numbers}
080483a0 <__libc_csu_init>:
80483a0: 55                     push %ebp
80483a1: 89 e5                  mov %esp,%ebp
80483a3: 57                     push %edi
80483a4: 56                     push %esi
80483a5: 53                     push %ebx
80483a6: e8 5a 00 00 00         call 8048405 <__i686.get_pc_thunk.bx>
80483ab: 81 c3 49 1c 00 00      add $0x1c49,%ebx
80483b1: 83 ec 1c               sub $0x1c,%esp
80483b4: e8 bb fe ff ff         call 8048274 <_init>
80483b9: 8d bb 20 ff ff ff      lea -0xe0(%ebx),%edi
80483bf: 8d 83 20 ff ff ff      lea -0xe0(%ebx),%eax
80483c5: 29 c7                  sub %eax,%edi
80483c7: c1 ff 02               sar $0x2,%edi
80483ca: 85 ff                  test %edi,%edi
80483cc: 74 24                  je 80483f2 <__libc_csu_init+0x52>
80483ce: 31 f6                  xor %esi,%esi
80483d0: 8b 45 10               mov 0x10(%ebp),%eax
80483d3: 89 44 24 08            mov %eax,0x8(%esp)
80483d7: 8b 45 0c               mov 0xc(%ebp),%eax
80483da: 89 44 24 04            mov %eax,0x4(%esp)
80483de: 8b 45 08               mov 0x8(%ebp),%eax
80483e1: 89 04 24               mov %eax,(%esp)
80483e4: ff 94 b3 20 ff ff ff   call *-0xe0(%ebx,%esi,4)
80483eb: 83 c6 01               add $0x1,%esi
80483ee: 39 fe                  cmp %edi,%esi
80483f0: 72 de                  jb 80483d0 <__libc_csu_init+0x30>
80483f2: 83 c4 1c               add $0x1c,%esp
80483f5: 5b                     pop %ebx
80483f6: 5e                     pop %esi
80483f7: 5f                     pop %edi
80483f8: 5d                     pop %ebp
80483f9: c3                     ret
```

在上面的 **`get_pc_thunk`** 这部分代码中，它主要用于实现地址无关代码（Position Independent Code, PIC）。系统正在为地址无关代码的正常运行进行设置，为了让地址无关代码能够工作，基址指针需要被设置为全局偏移表的地址。相关的代码大致如下：

```armasm{.line-numbers}
__get_pc_thunk_bx:
movel (%esp),%ebx
return

push %ebx
call __get_pc_thunk_bx
add $_GLOBAL_OFFSET_TABLE_,%ebx
```

对 **`__get_pc_thunk.bx`** 的调用，和所有 call 指令一样，**会把下一条指令的地址（即返回地址）压入栈中**，以便函数返回后，程序能从该地址继续执行。**<font color="red">而在这个特殊的场景下，我们真正的目的就是为了得到这个返回地址本身</font>**。

因此，在 **`__get_pc_thunk_bx`** 函数内部，我们所做的就是将栈上的返回地址拷贝到 **`%ebx`** 寄存器中。当该函数返回后，下一条指令会给 **`%ebx`** 里的地址加上 **`$_GLOBAL_OFFSET_TABLE_`** 这个值。这个值在链接时会被解析为 **<font color="red">当前地址与地址无关代码所使用的全局偏移表（GOT）之间的差值（即相对偏移量）</font>**。

这个全局偏移表（GOT）里存放着一系列指向我们想要访问的数据的指针，**代码本身只需要知道目标数据在表中的固定偏移量即可**。程序加载器（loader）会在运行时为我们填充（或修正）表中的这些真实地址。对于函数调用，也有一个类似的表（即过程链接表，PLT）。用汇编语言手写这种代码会非常繁琐，但你完全可以只编写 C 或 C++ 代码，然后给编译器传递一个 **`-pic`** 参数，它就会魔术般地自动帮你处理好这一切。因此，当你在反汇编代码中看到这样的指令序列时，就意味着其源代码在编译时使用了 **`-pic`** 标志。

## 6.调用 _init 函数

好的，我们来梳理一下目前的调用流程：加载器（loader）将控制权移交给了 **`_start`** 函数，**`_start`** 接着调用 **`__libc_start_main`**，后者又调用了 **`__libc_csu_init`**，现在，**`__libc_csu_init`** 即将调用 **`_init`** 函数。

```armasm{.line-numbers}
08048274 <_init>:
8048274: 55                     push %ebp
8048275: 89 e5                  mov %esp,%ebp
8048277: 53                     push %ebx
8048278: 83 ec 04               sub $0x4,%esp
804827b: e8 00 00 00 00         call 8048280 <_init+0xc>
8048280: 5b                     pop %ebx
8048281: 81 c3 74 1d 00 00      add $0x1d74,%ebx (.got.plt)
8048287: 8b 93 fc ff ff ff      mov -0x4(%ebx),%edx
804828d: 85 d2                  test %edx,%edx
804828f: 74 05                  je 8048296 <_init+0x22>
8048291: e8 1e 00 00 00         call 80482b4 <__gmon_start__@plt>
8048296: e8 d5 00 00 00         call 8048370 <frame_dummy>
804829b: e8 70 01 00 00         call 8048410 <__do_global_ctors_aux>
80482a0: 58                     pop %eax
80482a1: 5b                     pop %ebx
80482a2: c9                     leave
80482a3: c3                     ret
```

在上面代码中，第一个 call 指令非常有趣。它的目的与我们之前看到的那个 **`get_pc_thunk`** 调用非常相似。如果你仔细观察，就会发现这个 call 指令的目标，竟然就是紧随其后的下一条指令的地址。**<font color="red">这样做虽然能让程序继续顺序执行，就好像什么都没发生一样，但它带来了一个关键的"副作用"，下一条指令的地址（也就是返回地址）被压入到了栈中</font>**。紧接着，这个地址被从栈中弹出到 **`%ebx`** 寄存器，并被用来为访问全局偏移表（Global Offset Table）进行设置。

### 6.1 调用 **`__gmon_start__@plt`**

接下来，程序会获取 **`__gmon_start__`** 函数的地址。如果这个地址为零（即一个空指针），那么程序就不会调用该函数，而是直接跳转到后续指令，跳过函数调用。反之，如果地址有效（非零），程序就会调用 **`__gmon_start__`** 函数来启动性能分析（profiling）。

简单来说，**`__gmon_start__`** 函数是 GNU gprof 性能分析工具的运行时初始化例程。当你使用 GCC 或 Clang 编译器，并带上 **`-pg`** 选项来编译和链接你的程序时，链接器就会将 **`__gmon_start__`** 函数以及其他一些性能分析相关的代码链接到你的最终可执行文件中，此时 **`__gmon_start__`** 就会有一个有效的非零地址。启动代码检查到地址有效，就会调用它。

**`__gmon_start__`** 会调用 atexit，把自己准备好的一个"数据转储函数"注册进去，当程序运行结束时，这个被注册的函数就会自动执行，其任务是将性能分析期间收集到的数据写入名为 gmon.out 的文件中。

### 6.2 调用 **`frame_dummy`** 函数

接下来，程序会调用 **`frame_dummy`** 函数。实际上，调用 **`frame_dummy`** 的最终目的是为了调用 **`__register_frame_info`** 函数。**`frame_dummy`** 在此的作用是负责为 **`__register_frame_info`** 函数准备并设置好所需的参数。

这一系列操作的根本目的，是为了注册与异常处理相关的栈帧信息。当程序中出现异常时，操作系统或运行时库需要依据这些预先注册的信息来正确地回溯栈帧，以便清理资源、调用异常处理器等。

### 6.3 调用 **`__do_global_ctors_aux`** 函数

