# Redis 之集群

Redis 集群是 Redis 自己提供的一种分布式数据库方案，集群通过分片（sharding）来进行数据共享，并且提供数据的复制和故障转移功能。

## 一、节点

一个 Redis 集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。连接各个节点的工作可以使用 CLUSTER MEET 命令来完成，该命令的格式如下：CLUSTER MEET <ip> <port>。

从客户端向一个节点 node 发送 CLUSTER MEET 命令，可以让 node 节点与 ip 和 port 所指定的节点进行握手（handshake），当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。

```c{.line-numbers}
127.0.0.1:7000> CLUSTER MEET 127.0.0.1 7001
OK 
```

通过客户端向节点 7000 发送这个命令，我们可以将节点 7001 添加到节点 7000 所在的集群。

### 1.启动节点

一个节点就是一个运行在集群模式下的 Redis 服务器，**<font color="red">Redis 服务器在启动时会根据 cluster-enabled 配置选项的是否为 yes 来决定是否开启服务器的集群模式</font>**。如果为 yes，那么开启服务器的集群模式成为一个节点，否则的话，开启服务器的单机模式（stand alone），成为一个普通的 Redis 服务器。除此之外，对于那些只有在集群模式下才会用到的数据， 节点将它们保存到了 cluster.h/clusterNode 结构， 以及 cluster.h/clusterState 结构里面。

### 2.集群数据结构

clusterNode 结构保存了一个节点的当前状态，比如节点的创建时间，节点的名字，节点当前的配置纪元，节点的 IP 和地址，等等。每个节点都会使用一个 clusterNode 结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 clusterNode 结构，以此来记录其他节点的状态（保存在 clusterState 结构中的 nodes 字段中）：

```c{.line-numbers}
struct clusterNode{
    // 创建节点的时间
    mstime_t ctime;
    // 节点的名字，由40个十六进制字符组成
    char name[REDIS_CLUSTER_NAMELEN];
    // 节点标识
    int flags;
    // 节点当前的配置纪元
    uint64_t configEpoch;
    // 节点的IP地址
    char ip[REDIS_IP_STR_LEN];
    // 节点的端口号
    int port;
    // 保存连接节点所需要的所有信息
    clusterLink* link;
    // 此slots只记录了这个clusterNode结构代表的节点的槽指派信息
    unsigned char slots[16384/8];

    int numslots;
    // 如果这是一个从节点，那么指向主节点
    struct clusterNode* slaveof;
    // 正在复制这个主节点的从节点的数量
    int numslaves;
    // 一个数组，每个数组项指向一个正在复制这个主节点的从节点的clusterNode结构
    struct clusterNode** slaves;
    // 一个链表，记录了所有其它结点对该节点的下线报告
    list* fail_reports;
}; 
```

**<font color="red">每个节点都保存着一个 clusterState 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态</font>**——比如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类：

```c{.line-numbers}
struct clusterState{
    // 指向当前节点的指针
    clusterNode* myself;
    // 集群当前的配置纪元，用于实现故障转移
    uint64_t currentEpoch;
    // 集群当前的状态：是在线还是下线
    int state;
    // 集群中至少处理一个槽节点的数量
    int size;
    // 集群的节点名单
    dict* nodes;
    // 此slots数组记录了集群中所有槽的指派信息
    clusterNode* slots[16384];
    // 通过跳跃表记录数据库键与槽号之间的对应关系
    zskiplist* slots_to_keys;
} 
```

## 二、槽指派

Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个至 16384 个槽。当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。通过向节点发送 CLUSTER ADDSLOTS 命令，我们可以将一个或者多个槽指派给节点负责：

```c{.line-numbers}
127.0.0.1:7000> CLUSTER ADDSLOTS <slot> [slot...]
OK 
```

假设现在集群里面有 7000、7001、7002 三个节点，为了让这三个节点所在的集群进入上线状态，我们需要执行以下命令，分别将槽 0-5000 分配给节点 7000，将 5001-10000 分配给 7001、将 10001-16383 分配给节点 7002：

```c{.line-numbers}
127.0.0.1:7000> CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000
OK
127.0.0.1:7001> CLUSTER ADDSLOTS 5001 5002 5003 5004 ... 10000
OK
127.0.0.1:7002> CLUSTER ADDSLOTS 10001 10002 10003 10004 ... 16383
OK 
```

当以上三个 CLUSTER ADDSLOTS 命令都执行完毕之后，数据库中的 16383 个槽都已经被指派给相应节点，集群进入上线状态。

### 1.记录节点的槽指派信息

clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理哪些槽，如下：

```c{.line-numbers}
struct clusterNode{
    // .......
    int numslots;
    // 此slots只记录了这个clusterNode结构代表的节点的槽指派信息
    unsigned char slots[16384/8];
}; 
```

slots 属性是一个二进制位数组（bit array），这个数组的长度为 16384/8=2048 个字节，共包含 16384 个二进制位。Redis 以 0 为起始索引，16383 为终止索引，对 slots 数组中的 16384 个二进制位进行编号，并根据索引 i 上的二进制位的值来判断节点是否负责处理槽 i：

- 如果 slots 数组在索引 i 上的二进制位的值为 1，那么表示此节点负责处理槽 i；
- 如果 slots 数组在索引 i 上的二进制位的值为 0，那么表示此节点不负责处理槽 i；

### 2.传播节点的槽指派信息

一个节点除了会将自己负责处理的槽记录在 clusterNode 结构的 slots 属性和 numslots 属性之外，它还会将自己的 slots 数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。当节点 A 通过消息从节点 B 那里接收到节点 B 的 slots 数组时，节点 A 会在自己的 clusterState.nodes 字典中查找节点 B 对应的 clusterNode 结构，并对结构中的 slots 数组进行保存或者更新。

据此可知，因此，集群中的每个节点都会知道数据库中的 16384 个槽分别被指派给了集群中的哪些节点。

### 3.记录集群所有槽的指派信息

clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息：

```c{.line-numbers}
struct clusterState{
    // 指向当前节点的指针
    clusterNode* myself;
    // .......
    // 此slots数组记录了集群中所有槽的指派信息
    clusterNode* slots[16384];
} 
```

slots 数组包含了 16384 个项，每个数组项都是一个指向 clusterNode 结构的指针：

- 如果 slots[i] 指针指向 NULL，那么表示槽 i 尚未指派给任何节点。
- 如果 slots[i] 指针指向一个 clusterNode 结构，那么表示槽 i 已经指派给了 clusterNode 结构所代表的节点。

clusterState.slots 数组记录了集群中所有槽的指派信息，而 clusterNode.slots 数组只记录了 clusterNode 结构所代表的节点的槽指派信息，这是两个 slots 数组的关键区别所在。

## 三、在集群中执行命令

在对数据库中的 16384 个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。**<font color="red">当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己</font>**：

- 如果键所在的槽正好指派了当前节点，那么节点直接执行这个命令。
- 如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。

### 1.计算键属于哪个槽

节点使用以下算法来计算给定键 key 属于哪个槽：

```c{.line-numbers}
def slot_number(key):
    return CRC16(key) & 16383 
```

其中 CRC16(key) 语句用于计算键 key 的 CRC-16 校验和，而 & 16383 语句则用于求余计算出一个介于 0 至 16383 之间的整数作为键 key 的槽号。可以使用 CLUSTER KEYSLOT <key> 命令来查看一个给定的键属于哪个槽。

### 2.判断槽是否由当前节点负责

当节点计算出键所属的槽 i 之后，节点就会检查自己在 clusterState.slots 数组中的项 i，判断键所在的槽是否由自己负责。如果 clusterState.slots[i] 等于 clusterState.myself，那么说明槽 i 由当前节点负责，节点可以执行客户端发送的命令。否则的话，说明槽 i 并非由当前节点负责，节点会根据 clusterState.slots[i] 指向的 clusterNode 结构所记录的节点 IP 和端口，向客户端返回 MOVED 错误，指引客户端转向至正在处理槽 i 的节点。

### 3.MOVED 错误

当节点发现键所在的槽并非由自己负责处理时，节点会向客户端返回一个 MOVED 错误，指引客户端转向至正在负责槽的节点，MOVED 错误的格式为：

```c{.line-numbers}
MOVED <slot> <ip>:<port>
```

其中 slot 为键所在的槽，而 ip 和 port 则是槽所分配给的节点的 IP 地址和端口号。当客户端接收到节点返回的 MOVED 错误时，客户端会根据 MOVED 错误中提供的 IP 地址和端口号，转向至负责处理槽 slot 的节点，并向该节点重新发送之前想要执行的命令。

集群模式的 redis-cli 客户端在接收到 MOVED 错误时，并不会打印出 MOVED 错误，而是根据 MOVED 错误自动进行节点跳转，并打印出转向信息，所以我们是看不见节点返回的 MOVED 错误的。但是，如果我们使用单机（stand alone）模式的 redis-cli 客户端，再次向节点发送相同的命令，那么 MOVED 错误就会被客户端打印出来。

### 4.节点数据库的实现

集群节点保存键值对以及键值对过期时间的方式，与 Redis 单机服务器保存键值对以及键值对过期时间的方式相同。节点和单机服务器在数据库方面的一个区别是，节点只能使用 0 号数据库，而单机 Redis 服务器则没有这一限制。另外，除了将键值对保存在数据库里面之外，**<font color="red">节点还会用 clusterState 结构中的 slots_to_keys 跳跃表来保存键和槽之间的关系</font>**：

```c{.line-numbers}
typdef struct clusterState {
    // ...
    // 通过跳跃表记录数据库键与槽号之间的对应关系
    zskiplist *slots_to_keys;
} clusterState; 
```

slots_to_keys 跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键。通过在 slots_to_keys 跳跃表中记录各个数据库键所属的槽，节点可以很方便地对属于某个或某些槽的所有数据库键进行批量操作。比如命令 **_`CLUSTER GETKEYSINSLOT <slot> <count>`_** 可以最多返回 count 个属于槽 slot 的数据库键，而这个命令就是通过遍历 slots_to_keys 跳跃表实现的。

## 四、重新分片

### 1.重新分片介绍

**<font color="red">Redis 集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</font>**。重新分片操作可以在线（online）进行，在重新分片过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。Redis 集群的重新分片操作由 Redis 的集群管理软件 redis-trib 负责执行，Redis 提供了进行重新分片所需的所有命令，而 redis-trib 则通过向源节点和目标节点发送命令来进行重新分片操作。

### 2.ASK 错误

在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：

- 源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令；
- 相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令；

如果集群中的节点收到一个关于键 key 的命令请求，并且键 key 所属的槽 i 正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键 key，如果找到了的话，节点就直接执行客户端发送的命令。

与此相反，如果节点没有在自己的数据库里找到键 key，那么节点会检查自己的 **`clusterState.migrating_slots_to[i]`**，看键 key 所属的槽 i 是否正在进行迁移，如果槽 i 的确在进行迁移的话，那么节点会向客户端发送一个 ASK 错误，引导客户端到正在导入槽 i 的节点去超找键 key。接到 ASK 错误的客户端会根据错误提供的 IP 和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个 ASKING 命令，之后再重新发送原本想要执行的命令。

以前面的例子来说，当客户端收到节点7002返回的以下错误时：

```c{.line-numbers}
ASK 16198 127.0.0.1:7003 
```

客户端会转向至节点 7003，首先发送命令 **_`ASKING`_**，再次发送命令 **_`GET "love"`_** 并且获得回复 "you get the key 'love'"。

### 3.ASKING

**<font color="red">ASKING 命令唯一要做的就是打开发送该命令的客户端的 `REDIS_ASKING` 标识</font>**。在一般情况下，如果客户端向节点发送一个关于槽 i 的命令，而槽 i 又没有指派给这个节点的话，那么节点将向客户端返回一个 MOVED 错误；但是，如果节点的 clusterState.importing_slots_from[i] 显示节点正在导入槽 i， 并且发送命令的客户端带有 **`REDIS_ASKING`** 标识，那么节点将破例执行这个关于槽 i 的命令一次。

当客户端接收到 ASK 错误并转向至正在导入槽的节点时，客户端会先向节点发送一个 ASKING 命令，然后才重新发送想要执行的命令，这是因为如果客户端不发送 ASKING 命令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回 MOVED 错误。另外要注意的是，客户端的 **`REDIS_ASKING`** 标识是一个一次性标识，当节点执行了一个带有 **`REDIS_ASKING`** 标识的客户端发送的命令之后，客户端的 **`REDIS_ASKING`** 标识就会被移除。

### 4.总结

最后，总结一下，客户端向集群发送命令时，集群中节点的行为。客户端向节点发送一个关于槽 i 的命令，而槽 i 又没有指派给这个节点的话，首先去检查节点的 **`clusterState.importing_slots_from[i]`** 是否显示节点正在导入槽 i，如果是并且发送命令的客户端带有 **`REDIS_ASKING`** 标识，就会去执行命令，否则就会返回一个 MOVED 错误；如果槽 i 被指派给这个节点的话，如果节点在槽中找到指定的键，那么就会直接执行客户端发送的命令，否则节点会检查自己的 **`clusterState.migrating_slots_to[i]`**，看键 key 所属的槽 i 是否正在进行迁移，如果槽 i 的确在进行迁移的话，那么节点会向客户端发送一个 ASK 错误。

## 五、复制与故障转移

Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。向一个节点发送命令：

```c{.line-numbers}
CLUSTER REPLICATE <node_id>
```

可以让接收命令的节点成为 node_id 所指定节点的从节点，并开始对主节点进行复制。一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。

### 1.故障检测

**<font color="red">集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</font>**，如果接收 PING 消息的节点没有在规定的时间内，向发送 PING 消息的节点返回 PONG 消息，那么发送 PING 消息的节点就会将接收 PING 消息的节点标记为疑似下线（probable fail，PFAIL）。集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息。例如某个节点是出于在线状态、疑似下线状态（PFAIL）、还是已下线状态（FAIL）。

如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点 x 报告为疑似下线，那么这个主节点 x 将被标记为已下线（FAIL），将主节点 x 标记为已下线的节点会向集群广播一条关于主节点 x 的 FAIL 消息，所有收到这条 FAIL 消息的节点都会立即将主节点 x 标记为已下线。

### 2.故障转移

当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：

- 下线主节点的所有从节点里面，会有一个从节点被选中。
- 被选中的从节点会执行 SLAVEOF no one 命令，成为新的主节点。
- 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。
- **<font color="red">新的主节点向集群广播一条 PONG 消息，这条 PONG 消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点</font>**，并且这个主节点已经接管了原本由已下线节点负责处理的槽。
- 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成

其实就是从下线主节点的所有从节点中，选出一个来成为新的主节点，然后让这个新的主节点接管原来主节点的所有槽指派，并且接着处理客户端的命令请求。

## 六、消息

集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）。节点发送的消息主要有以下五种：

- MEET 消息：当发送者接到客户端发送的 CLUSTER MEET 命令时，发送者会向接收者发送 MEET 消息， 请求接收者加入到发送者当前所处的集群里面。
- PING 消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING 消息，以此来检测被选中的节点是否在线。除此以外，如果节点 A 最后一次收到节点 B 发送的 PONG 消息的时间，距离当前时间已经超过了节点 A 的 **`cluster-node-timeout`** 选项设置时长的一半，那么节点 A 也会向节点 B 发送 PING 消息，这可以防止节点 A 因为长时间没有随机选中节点 B 作为 PING 消息的发送对象而导致对节点 B 的信息更新滞后。
- PONG 消息：当接收者收到发送者发来的 MEET 消息或者 PING 消息时，为了向发送者确认这条 MEET 消息或者 PING 消息已到达，接收者会向发送者返回一条 PONG 消息。**<font color="red">另外，一个节点也可以通过向集群广播 PONG 消息来让集群中的其他节点立即刷新关于这个节点的认识</font>**，例如当一次故障转移操作成功之后，新的主节点会向集群广播一条 PONG 消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。
- FAIL 消息：当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条关于节点 B 的 FAIL 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线。