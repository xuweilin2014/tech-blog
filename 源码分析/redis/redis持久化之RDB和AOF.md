# Redis 持久化之 RDB 和 AOF 

## 一、Redis 持久化

Redis 作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行。

这样做有什么问题呢？其实，只要稍微有点计算机基础知识的人都知道，存储在内存当中的数据，只要服务器关机( 各种原因引起的)，内存中的数据就会消失了，不仅服务器关机会造成数据消失，Redis 服务器守护进程退出，内存中的数据也一样会消失。

对于只把 Redis 当缓存来用的项目来说，数据消失或许问题不大，重新从数据源把数据加载进来就可以了，但如果直接把用户提交的业务数据存储在 Redis 当中，把 Redis 作为数据库来使用，在其放存储重要业务数据，那么 Redis 的内存数据丢失所造成的影响也许是毁灭性。为了避免内存中数据丢失，Redis 提供了对持久化的支持，我们可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。

Redis 提供了 RDB 和 AOF 两种不同的数据持久化方式，下面我们就来详细介绍一下这种不同的持久化方式吧。

## 二、RDB 数据快照

### 1 RDB 文件的创建和载入

Redis 是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对。为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。RDB，提供一个某个时间点的数据的 Snapshot，保存在 RDB 文件中。它可以通过 SAVE/BGSAVE 命令手动执行，把数据 Snapshot 写到 RDB 文件，也可以通过配置，定时执行。该功能可以将某个时间点上的数据库状态保存到一个 RDB 文件，生成的 RDB 文件是一个经过压缩的二进制文件。Redis 也可以通过加载 RDB 文件，把数据从磁盘加载读取到 Redis 中。

#### 1.1 save 命令

```sql{.line-numbers}
# 同步数据到磁盘上
> save 
```

当客户端向服务器发送 save 命令请求进行持久化时，服务器会阻塞 save 命令之后的其他客户端的请求，直到数据同步完成。如果数据量太大，同步数据会执行很久，而这期间 Redis 服务器也无法接收其他请求，所以，最好不要在生产环境使用 save 命令。

#### 1.2 bgsave 命令

与 save 命令不同，bgsave 命令是一个异步操作。

```sql{.line-numbers}
# 异步保存数据集到磁盘上
> bgsave 
```

当客户端发服务发出 bgsave 命令时，Redis 服务器主进程会 forks 一个子进程来数据同步问题，在将数据保存到 rdb 文件之后，子进程会退出。所以，与 save 命令相比，Redis 服务器在处理 bgsave 采用子进程进行 IO 写入，而主进程仍然可以接收其他请求，**<font color="red">但 forks 子进程是同步的，所以 forks 子进程时，一样不能接收其他请求</font>**，这意味着，如果 forks 一个子进程花费的时间太久( 一般是很快的)，bgsave 命令仍然有阻塞其他客户端的请求的情况发生。

创建 RDB 文件实际上是由 rdb.c/rdbSave 函数完成的，SAVE 命令与 BGSAVE 命令会以不同的方式调用这个函数，以下伪代码可以看出这两个命令的区别：

```java{.line-numbers}
def SAVE():
    #创建rdb文件
    rdbSave()

def BGSAVE():
    #创建子进程
    pid = fork()
    
    if pid == 0:
        #子进程负责创建rdb文件
        rdbSave()
        #完成之后向父进程发送信号
        signal_parent()
    elif pid > 0:
        #父进程继续处理命令请求，并且通过轮询子进程的信号
        handle_request_and_wait_signal()
    else:
        #处理出错情况
        handle_fork_error() 
```

RDB 的载入工作是在 Redis 服务器启动时自动完成的，所以 Redis 并没有专门用于载入 RDB 的命令，只要 Redis 启动时检测到 RDB 文件的存在，它就会自动载入 RDB 文件。另外，由于 AOF 文件的更新频率要大于 RDB 文件，所以：

- 如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库的状态
- 只有在 AOF 持久化关闭的时候，服务器才会使用 RDB 文件来还原数据库状态

载入 RDB 由 rdb.c/rdbLoad 函数完成。

#### 1.3 SAVE 命令执行时的服务器状态

正如前面所说的，当 SAVE 命令执行时，Redis 服务器会被阻塞，所以当 SAVE 命令正在执行时，客户端发送的所有命令请求都会被拒绝。只有在服务器执行完 SAVE 命令，客户端发送的命令才会被处理。

#### 1.4 BGSAVE 命令执行时的服务器状态

**<font color="red">在 BGSAVE 命令执行期间，客户端发送的 SAVE 命令会被拒绝</font>**，禁止 SAVE 命令和 BGSAVE 命令同时执行是因为可以避免父进程( 服务器进程，执行 SAVE 操作) 和子进程( 执行 BGSAVE 操作) 同时调用 rdbSave 函数，产生竞争条件

**<font color="red">在 BGSAVE 命令执行期间，客户端发送的 BGSAVE 命令会被拒绝</font>**。这是因为如果允许的话，服务器会产生另外一个子进程，这样就有两个子进程调用 rdbSave 函数，也会产生竞争条件。

**<font color="red">另外，BGREWRITEAOF 和 AOF 命令也不能同时执行</font>**：

- 如果 BGREWRITEAOF 命令正在执行，那么客户端发送的 BGSAVE 命令会被拒绝
- 如果 BGSAVE 命令正在进行，那么客户端发送的 BGREWRITEAOF 命令会被延迟到 BGSAVE 执行完毕后执行

BGREWRITEAOF 和 AOF 命令也不能同时执行实际上是出于性能方面的考虑，并发两个子进程，并且这两个子进程都同时执行大量的磁盘写入 IO 操作，这并不是一个好主意。

#### 1.5 RDB 